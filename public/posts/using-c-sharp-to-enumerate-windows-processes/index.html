<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using C Sharp to Enumerate Windows Processes | Stephan Bridger</title><meta name=keywords content="windows,csharp,process enumeration"><meta name=description content="In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.
And how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.
But in this post, we&rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.
SYSTEM_PROCESS_INFORMATION Structure
Microsoft tells us in their documentation that this structure holds various entries which hold system and process information."><meta name=author content="Stephan Bridger"><link rel=canonical href=https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/><link crossorigin=anonymous href=/assets/css/stylesheet.793a8ff569756a2027f6b93c889ec37d86f8750c1c450ebac658c67d856ed6af.css integrity="sha256-eTqP9Wl1aiAn9rk8iJ7DfYb4dQwcRQ66xljGfYVu1q8=" rel="preload stylesheet" as=style><link rel=icon href=https://hexagram.foo/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hexagram.foo/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hexagram.foo/favicon-32x32.png><link rel=apple-touch-icon href=https://hexagram.foo/apple-touch-icon.png><link rel=mask-icon href=https://hexagram.foo/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/"><meta property="og:site_name" content="Stephan Bridger"><meta property="og:title" content="Using C Sharp to Enumerate Windows Processes"><meta property="og:description" content="In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.
And how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.
But in this post, we’ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.
SYSTEM_PROCESS_INFORMATION Structure Microsoft tells us in their documentation that this structure holds various entries which hold system and process information."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-03T00:00:00+00:00"><meta property="article:tag" content="Windows"><meta property="article:tag" content="Csharp"><meta property="article:tag" content="Process Enumeration"><meta property="og:image" content="https://hexagram.foo/fog.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hexagram.foo/fog.jpeg"><meta name=twitter:title content="Using C Sharp to Enumerate Windows Processes"><meta name=twitter:description content="In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.
And how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.
But in this post, we&rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.
SYSTEM_PROCESS_INFORMATION Structure
Microsoft tells us in their documentation that this structure holds various entries which hold system and process information."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hexagram.foo/posts/"},{"@type":"ListItem","position":2,"name":"Using C Sharp to Enumerate Windows Processes","item":"https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using C Sharp to Enumerate Windows Processes","name":"Using C Sharp to Enumerate Windows Processes","description":"In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.\nAnd how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.\nBut in this post, we\u0026rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.\nSYSTEM_PROCESS_INFORMATION Structure Microsoft tells us in their documentation that this structure holds various entries which hold system and process information.\n","keywords":["windows","csharp","process enumeration"],"articleBody":"In previous posts, I covered how to observe process information in Windbg by starting a debugging session and dumping the Process Environment Block.\nAnd how we can view the EPROCESS structure, including a doubly linked-list of active processes via ActiveProcessLinks.\nBut in this post, we’ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the SYSTEM_PROCESS_INFORMATION structure.\nSYSTEM_PROCESS_INFORMATION Structure Microsoft tells us in their documentation that this structure holds various entries which hold system and process information.\nWhen the SystemInformationClass parameter is SystemProcessInformation, the buffer pointed to by the SystemInformation parameter contains a SYSTEM_PROCESS_INFORMATION structure for each process. Each of these structures is immediately followed in memory by one or more SYSTEM_THREAD_INFORMATION structures that provide info for each thread in the preceding process. For more information about SYSTEM_THREAD_INFORMATION, see the section about this structure in this article.\nThe buffer pointed to by the SystemInformation parameter should be large enough to hold an array that contains as many SYSTEM_PROCESS_INFORMATION and SYSTEM_THREAD_INFORMATION structures as there are processes and threads running in the system. This size is specified by the ReturnLength parameter.\nMicrosoft goes on to give us the following type definition for the SYSTEM_PROCESS_INFORMATION structure, which gives us access to process variables like ImageNames, UniqueProcessId, and more:\ntypedef struct _SYSTEM_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[48]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[6]; } SYSTEM_PROCESS_INFORMATION; NTDLL, Home of .. Many Functions In previous posts, I talked about how NTDLL.dll is where Windows user space frequently calls into in order to talk to relevant low-level parts of Windows and to do stuff in general. And this case is no exception.\nIn retrieving information from the SYSTEM_PROCESS_INFORMATION, we’ll need to communicate with NTDLL through a couple of system calls. To reach the SYSTEM_PROCESS_INFORMATION structure, we’ll need to do so through the Windows API via the QuerySystemInformation function, which Microsoft provides us with the following type definition for:\n__kernel_entry NTSTATUS NtQuerySystemInformation( [in] SYSTEM_INFORMATION_CLASS SystemInformationClass, [in, out] PVOID SystemInformation, [in] ULONG SystemInformationLength, [out, optional] PULONG ReturnLength ); Using Csharp to Talk to NTDLL We’ll translate this type definition to C# and create the following declaration to call the NtQuerySystemInformation function and access the SYSTEM_PROCESS_INFORMATION structure. Since this function resides in NTDLL, we’ll use the extern keyword to tell the compiler this.\nPVOID, a pointer to void, is an IntPtr in C#, an integer whose size is that of a pointer. This is for referencing unmanaged memory. Per Microsoft’s documentation:\nThe IntPtr type can be used by languages that support pointers and as a common means of referring to data between languages that do and do not support pointers. IntPtr objects can also be used to hold handles. For example, instances of IntPtr are used extensively in the System.IO.\nAnd SystemInformationLength is a ulong, or unsigned integer, which is a uint in C#. And ReturnLength is also a uint. So, our initial declaration looks like this:\nusing System; using System.Diagnostics; using System.Runtime.InteropServices; public class Program { [DllImport(\"ntdll.dll\")] public static extern uint NtQuerySystemInformation(uint SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, out uint ReturnLength); } To correctly read the outputs from the Windows API, as well as this structure, we’ll need to utilize Unicode. This signature is straightforward. We have a Length, Max Length, and Buffer. Microsoft clarifies this in their documentation:\nWhen the ProcessInformationClass parameter is ProcessImageFileName, the buffer pointed to by the ProcessInformation parameter should be large enough to hold a UNICODE_STRING structure as well as the string itself. The string stored in the Buffer member is the name of the image file.\nIf the buffer is too small, the function fails with the STATUS_INFO_LENGTH_MISMATCH error code and the ReturnLength parameter is set to the required buffer size.\nThe UNICODE_STRING signature in C# is as follows:\n[StructLayout(LayoutKind.Sequential)] public struct UNICODE_STRING { public ushort Length; public ushort MaximumLength; public IntPtr Buffer; } Next, we’ll need to Marshal the unmanaged SYSTEM_PROCESS_INFORMATION structure. Microsoft provides us this type definition:\ntypedef struct _SYSTEM_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[48]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[6]; } SYSTEM_PROCESS_INFORMATION; But if we dig a bit deeper, we find this type definition provided by Microsoft is seemingly incomplete. Software analyst Geoff Chappell has provided a much more thorough overview of this structure.\nIf we reference Geoff Chappell’s documentation, we see the SYSTEM_PROCESS_INFORMATION structure actually includes many attributes that Microsoft doesn’t officially list.\nSo, here we’ll use Geoff Chappell’s analysis for reference since it provides a much more comprehensive layout of the structure.\nWe’ll once again use a C# StructLayout to Marshal this information so our program can handle it. After converting the types, our layout for the SYSTEM_PROCESS_INFORMATION structure looks like this:\n[StructLayout(LayoutKind.Sequential)] public struct SYSTEM_PROCESS_INFORMATION { public uint NextEntryOffset; public uint NumberOfThreads; public LARGE_INTEGER WorkingSetPrivateSize; public uint HardFaultCount; public uint NumberOfThreadsHighWatermark; public ulong CycleTime; public LARGE_INTEGER CreateTime; public LARGE_INTEGER UserTime; public LARGE_INTEGER KernelTime; public UNICODE_STRING ImageName; public int BasePriority; public IntPtr UniqueProcessId; public IntPtr InheritedFromUniqueProcessId; public uint HandleCount; public uint SessionId; public IntPtr UniqueProcessKey; public IntPtr PeakVirtualSize; public IntPtr VirtualSize; public uint PageFaultCount; public IntPtr PeakWorkingSetSize; public IntPtr WorkingSetSize; public IntPtr QuotaPeakPagedPoolUsage; public IntPtr QuotaPagedPoolUsage; public IntPtr QuotaPeakNonPagedPoolUsage; public IntPtr QuotaNonPagedPoolUsage; public IntPtr PagefileUsage; public IntPtr PeakPagefileUsage; public IntPtr PrivatePageCount; public LARGE_INTEGER ReadOperationCount; public LARGE_INTEGER WriteOperationCount; public LARGE_INTEGER OtherOperationCount; public LARGE_INTEGER ReadTransferCount; public LARGE_INTEGER WriteTransferCount; public LARGE_INTEGER OtherTransferCount; } The large_integer will need to be correctly defined too. This was used in the aforementioned documentation. And it represents a 64-bit signed integer, e.g. long QuadPart:\n[StructLayout(LayoutKind.Sequential)] public struct LARGE_INTEGER { public long QuadPart; } Next we’ll declare and initialize the variables for our function. These will all be unsigned integers with the exception of the IntPtr. dwRet will hold our return value from NtQuerySystemInformation. dwSize represents the size of the memory buffers we’ll be operating on. We’ll initialize this to zero. And dwStatus represents a default error code indicating that a length mismatch has occurred. We’ll set this as the default error status for now. And last, we’ll initialize our pointer to zero.\npublic static void Main() { uint dwRet; uint dwSize = 0x0; uint dwStatus = 0xC0000004; IntPtr p = IntPtr.Zero; } We initialize a loop where we first check if the pointer p is not zero. If it is not, we free the previously allocated memory using Marshal.FreeHGlobal(p).\nNext, we allocate memory for the buffer by using Marshal.AllocHGlobal((int)dwSize), where dwSize specifies the amount of memory needed for our result.\nAfterward, we call NtQuerySystemInformation, passing the allocated buffer p, the size of the buffer dwSize, and a variable dwRet to hold the number of bytes returned.\nIf NtQuerySystemInformation returns a status code of 0, our query was successful, and we can break the loop and process the data. If the status code is 0xC0000004, there’s a length mismatch, e.g. our buffer size wasn’t large enough to hold all the data.\nIn this case, we don’t bail out of the loop immediately but instead adjust the buffer size with dwSize = dwRet + (2 \u003c\u003c 12), increasing dwSize to accommodate the full result.\nIf we encounter any other error code, however, we print an error message, free the memory, and exit the loop.\nwhile (true) { if (p != IntPtr.Zero) Marshal.FreeHGlobal(p); p = Marshal.AllocHGlobal((int)dwSize); dwStatus = NtQuerySystemInformation(5, p, dwSize, out dwRet); if (dwStatus == 0) { break; } else if (dwStatus != 0xC0000004) { Marshal.FreeHGlobal(p); p = IntPtr.Zero; Console.WriteLine(\"Data retrieval failed\"); return; } dwSize = dwRet + (2 \u003c\u003c 12); } Finally, we can loop through the entries and print the attributes from the SYSTEM_PROCESS_INFORMATION structure.\nWe use Marshal.PtrToStructure to reference the unmanaged memory we’ve marshaled into the currentPtr. This allows us to map raw memory to the specific C# SYSTEM_PROCESS_INFORMATION typedef we defined earlier. C sharp’s use of static typing ensures the data is retrieved safely and with the correct types.\nvar processInfo = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(currentPtr, typeof(SYSTEM_PROCESS_INFORMATION)); And then we write out output with Console.WriteLine, checking the values of the attributes we’re referencing. If the ImageName.Buffer is non-zero, we likely have a valid ImageName. So we call Marshal.PtrToStringUni(processInfo.ImageName.Buffer) on it to get the Unicode ImageName. And to extract the UniqueProcessId, we convert the value to a Int64, a signed integer.\nAfter each record, we move to the next entry using the NextEntryOffset value. We convert this to a 32-bit integer, though. Per Microsoft’s documentation:\nNextEntryOffset (4 bytes): A 32-bit unsigned integer that MUST specify the offset, in bytes, from the current FILE_LINK_ENTRY_INFORMATION structure to the next FILE_LINK_ENTRY_INFORMATION structure. A value of 0 indicates this is the last entry structure.\nAltogether, our last bit of code will look like this:\nIntPtr currentPtr = p; do { var processInfo = (SYSTEM_PROCESS_INFORMATION)Marshal.PtrToStructure(currentPtr, typeof(SYSTEM_PROCESS_INFORMATION)); Console.WriteLine($\"[*] Image name: {(processInfo.ImageName.Buffer != IntPtr.Zero ? Marshal.PtrToStringUni(processInfo.ImageName.Buffer) : \"\")}\"); Console.WriteLine($\" \u003e PID: {processInfo.UniqueProcessId.ToInt64()}\"); Console.WriteLine(); // Calculate the offset to the next process entry int offset = (int)processInfo.NextEntryOffset; if (offset == 0) break; // Move to the next process entry currentPtr = IntPtr.Add(currentPtr, offset); } while (true); Marshal.FreeHGlobal(p); } On Github I’ve uploaded the C# code for this demonstration to a small repository dubbed “Cardinal.”\nAfter compiling, we can do:\n\u003e.\\Cardinal\\bin\\Debug\\Cardinal.exe [*] Image name: \u003e PID: 0 [*] Image name: System \u003e PID: 4 [*] Image name: Registry \u003e PID: 116 [*] Image name: smss.exe \u003e PID: 444 [*] Image name: csrss.exe \u003e PID: 636 [*] Image name: wininit.exe \u003e PID: 708 ","wordCount":"1617","inLanguage":"en","image":"https://hexagram.foo/fog.jpeg","datePublished":"2023-09-03T00:00:00Z","dateModified":"2023-09-03T00:00:00Z","author":{"@type":"Person","name":"Stephan Bridger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hexagram.foo/posts/using-c-sharp-to-enumerate-windows-processes/"},"publisher":{"@type":"Organization","name":"Stephan Bridger","logo":{"@type":"ImageObject","url":"https://hexagram.foo/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hexagram.foo/ accesskey=h title="Stephan Bridger (Alt + H)">Stephan Bridger</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hexagram.foo/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://hexagram.foo/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://hexagram.foo/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://hexagram.foo/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Using C Sharp to Enumerate Windows Processes</h1><div class=post-meta><span title='2023-09-03 00:00:00 +0000 UTC'>September 3, 2023</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1617 words</span>&nbsp;·&nbsp;<span>Stephan Bridger</span></div></header><div class=post-content><p>In previous posts, I covered how to observe process information <a href=https://hexagr.blogspot.com/2023/08/windows-process-initialization.html>in Windbg by starting a debugging session and dumping the Process Environment Block</a>.</p><p>And how we can view the EPROCESS structure, including a doubly linked-list of <a href=https://hexagram.foo/posts/finding-active-processes-with-windbg/>active processes via ActiveProcessLinks</a>.</p><p>But in this post, we&rsquo;ll discuss yet another way of gleaning information about processes in Windows, this time from another structure within the Windows ecosystem: the <code>SYSTEM_PROCESS_INFORMATION</code> structure.</p><h2 id=system_process_information-structure>SYSTEM_PROCESS_INFORMATION Structure<a hidden class=anchor aria-hidden=true href=#system_process_information-structure>#</a></h2><p>Microsoft tells us in their documentation that this structure holds various entries which hold system and process information.</p><blockquote><p>When the <code>SystemInformationClass</code> parameter is <code>SystemProcessInformation</code>, the buffer pointed to by the <code>SystemInformation</code> parameter contains a <code>SYSTEM_PROCESS_INFORMATION</code> structure for each process. Each of these structures is immediately followed in memory by one or more <code>SYSTEM_THREAD_INFORMATION</code> structures that provide info for each thread in the preceding process. For more information about <code>SYSTEM_THREAD_INFORMATION</code>, see the section about this structure in this article.</p></blockquote><blockquote><p>The buffer pointed to by the <code>SystemInformation</code> parameter should be large enough to hold an array that contains as many <code>SYSTEM_PROCESS_INFORMATION</code> and <code>SYSTEM_THREAD_INFORMATION</code> structures as there are processes and threads running in the system. This size is specified by the <code>ReturnLength</code> parameter.</p></blockquote><p>Microsoft goes on to give us the following type definition for the <strong><code>SYSTEM_PROCESS_INFORMATION</code></strong> structure, which gives us access to process variables like <strong><code>ImageNames</code></strong>, <strong><code>UniqueProcessId</code></strong>, and more:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_SYSTEM_PROCESS_INFORMATION</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>NextEntryOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>NumberOfThreads</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span> <span class=n>Reserved1</span><span class=p>[</span><span class=mi>48</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>UNICODE_STRING</span> <span class=n>ImageName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>KPRIORITY</span> <span class=n>BasePriority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>UniqueProcessId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>HandleCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>SessionId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakVirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>VirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Reserved4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakWorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>WorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>QuotaPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>QuotaNonPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakPagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PrivatePageCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LARGE_INTEGER</span> <span class=n>Reserved7</span><span class=p>[</span><span class=mi>6</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=ntdll-home-of--many-functions>NTDLL, Home of .. Many Functions<a hidden class=anchor aria-hidden=true href=#ntdll-home-of--many-functions>#</a></h2><p>In previous posts, I talked about how <code>NTDLL.dll</code> is where Windows user space frequently calls into in order to talk to relevant low-level parts of Windows and to do stuff in general. And this case is no exception.</p><p>In retrieving information from the <code>SYSTEM_PROCESS_INFORMATION</code>, we&rsquo;ll need to communicate with <code>NTDLL</code> through a couple of system calls. To reach the <code>SYSTEM_PROCESS_INFORMATION</code> structure, we&rsquo;ll need to do so through the Windows API via the <code>QuerySystemInformation</code> function, which Microsoft provides us with the following type definition for:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>__kernel_entry</span> <span class=n>NTSTATUS</span> <span class=nf>NtQuerySystemInformation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>            <span class=n>SYSTEM_INFORMATION_CLASS</span> <span class=n>SystemInformationClass</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>out</span><span class=p>]</span>       <span class=n>PVOID</span>                    <span class=n>SystemInformation</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>            <span class=n>ULONG</span>                    <span class=n>SystemInformationLength</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>out</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span> <span class=n>PULONG</span>                   <span class=n>ReturnLength</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><h2 id=using-csharp-to-talk-to-ntdll>Using Csharp to Talk to NTDLL<a hidden class=anchor aria-hidden=true href=#using-csharp-to-talk-to-ntdll>#</a></h2><p>We&rsquo;ll translate this type definition to C# and create the following declaration to call the <code>NtQuerySystemInformation</code> function and access the <code>SYSTEM_PROCESS_INFORMATION</code> structure. Since this function resides in <code>NTDLL</code>, we&rsquo;ll use the <code>extern</code> keyword to tell the compiler this.</p><p><code>PVOID</code>, a pointer to void, is an <code>IntPtr</code> in C#, an integer whose size is that of a pointer. This is for referencing unmanaged memory. Per Microsoft&rsquo;s documentation:</p><blockquote><p>The <code>IntPtr</code> type can be used by languages that support pointers and as a common means of referring to data between languages that do and do not support pointers. <code>IntPtr</code> objects can also be used to hold handles. For example, instances of <code>IntPtr</code> are used extensively in the <code>System.IO</code>.</p></blockquote><p>And <code>SystemInformationLength</code> is a <code>ulong</code>, or unsigned integer, which is a <code>uint</code> in C#. And <code>ReturnLength</code> is also a <code>uint</code>. So, our initial declaration looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Diagnostics</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Runtime.InteropServices</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Program</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=na>    [DllImport(&#34;ntdll.dll&#34;)]</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>extern</span> <span class=kt>uint</span> <span class=n>NtQuerySystemInformation</span><span class=p>(</span><span class=kt>uint</span> <span class=n>SystemInformationClass</span><span class=p>,</span> <span class=n>IntPtr</span> <span class=n>SystemInformation</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>SystemInformationLength</span><span class=p>,</span> <span class=k>out</span> <span class=kt>uint</span> <span class=n>ReturnLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To correctly read the outputs from the Windows API, as well as this structure, we&rsquo;ll need to utilize Unicode. This signature is straightforward. We have a <code>Length</code>, <code>Max Length</code>, and <code>Buffer</code>. Microsoft clarifies this in their documentation:</p><blockquote><p>When the <code>ProcessInformationClass</code> parameter is <code>ProcessImageFileName</code>, the buffer pointed to by the <code>ProcessInformation</code> parameter should be large enough to hold a <code>UNICODE_STRING</code> structure as well as the string itself. The string stored in the <code>Buffer</code> member is the name of the image file.</p><p>If the buffer is too small, the function fails with the <code>STATUS_INFO_LENGTH_MISMATCH</code> error code and the <code>ReturnLength</code> parameter is set to the required buffer size.</p></blockquote><p>The <code>UNICODE_STRING</code> signature in C# is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[StructLayout(LayoutKind.Sequential)]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>struct</span> <span class=nc>UNICODE_STRING</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>ushort</span> <span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>ushort</span> <span class=n>MaximumLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>Buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Next, we&rsquo;ll need to Marshal the unmanaged <code>SYSTEM_PROCESS_INFORMATION</code> structure. Microsoft provides us this type definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_SYSTEM_PROCESS_INFORMATION</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>NextEntryOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>NumberOfThreads</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span> <span class=n>Reserved1</span><span class=p>[</span><span class=mi>48</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>UNICODE_STRING</span> <span class=n>ImageName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>KPRIORITY</span> <span class=n>BasePriority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>UniqueProcessId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>HandleCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>SessionId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakVirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>VirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Reserved4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakWorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>WorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>QuotaPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>QuotaNonPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PeakPagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SIZE_T</span> <span class=n>PrivatePageCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LARGE_INTEGER</span> <span class=n>Reserved7</span><span class=p>[</span><span class=mi>6</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>;</span>
</span></span></code></pre></div><p>But if we dig a bit deeper, we find this type definition provided by Microsoft is seemingly incomplete. Software analyst Geoff Chappell has provided a much more thorough overview of this structure.</p><p>If we reference <a href=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/process.htm>Geoff Chappell&rsquo;s documentation</a>, we see the <code>SYSTEM_PROCESS_INFORMATION</code> structure actually includes many attributes that Microsoft doesn&rsquo;t officially list.</p><p>So, here we&rsquo;ll use Geoff Chappell&rsquo;s analysis for reference since it provides a much more comprehensive layout of the structure.</p><p>We&rsquo;ll once again use a C# <code>StructLayout</code> to Marshal this information so our program can handle it. After converting the types, our layout for the <code>SYSTEM_PROCESS_INFORMATION</code> structure looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[StructLayout(LayoutKind.Sequential)]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>struct</span> <span class=nc>SYSTEM_PROCESS_INFORMATION</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>NextEntryOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>NumberOfThreads</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>WorkingSetPrivateSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>HardFaultCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>NumberOfThreadsHighWatermark</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>ulong</span> <span class=n>CycleTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>CreateTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>UserTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>KernelTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>UNICODE_STRING</span> <span class=n>ImageName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=n>BasePriority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>UniqueProcessId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>InheritedFromUniqueProcessId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>HandleCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>SessionId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>UniqueProcessKey</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>PeakVirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>VirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>uint</span> <span class=n>PageFaultCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>PeakWorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>WorkingSetSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>QuotaPeakPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>QuotaPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>QuotaPeakNonPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>QuotaNonPagedPoolUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>PagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>PeakPagefileUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>IntPtr</span> <span class=n>PrivatePageCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>ReadOperationCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>WriteOperationCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>OtherOperationCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>ReadTransferCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>WriteTransferCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>LARGE_INTEGER</span> <span class=n>OtherTransferCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>large_integer</code> will need to be correctly defined too. This was used in the aforementioned documentation. And it represents a 64-bit signed integer, e.g. <code>long QuadPart</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[StructLayout(LayoutKind.Sequential)]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>struct</span> <span class=nc>LARGE_INTEGER</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>long</span> <span class=n>QuadPart</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Next we&rsquo;ll declare and initialize the variables for our function. These will all be unsigned integers with the exception of the <code>IntPtr</code>. <code>dwRet</code> will hold our return value from <code>NtQuerySystemInformation</code>. <code>dwSize</code> represents the size of the memory buffers we&rsquo;ll be operating on. We&rsquo;ll initialize this to zero. And <code>dwStatus</code> represents a default error code indicating that a length mismatch has occurred. We&rsquo;ll set this as the default error status for now. And last, we&rsquo;ll initialize our pointer to zero.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=n>dwRet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=n>dwSize</span> <span class=p>=</span> <span class=m>0x0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=n>dwStatus</span> <span class=p>=</span> <span class=m>0xC0000004</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>IntPtr</span> <span class=n>p</span> <span class=p>=</span> <span class=n>IntPtr</span><span class=p>.</span><span class=n>Zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We initialize a loop where we first check if the pointer p is not zero. If it is not, we free the previously allocated memory using <code>Marshal.FreeHGlobal(p)</code>.</p><p>Next, we allocate memory for the buffer by using <code>Marshal.AllocHGlobal((int)dwSize)</code>, where <code>dwSize</code> specifies the amount of memory needed for our result.</p><p>Afterward, we call <code>NtQuerySystemInformation</code>, passing the allocated buffer <code>p</code>, the size of the buffer <code>dwSize</code>, and a variable <code>dwRet</code> to hold the number of bytes returned.</p><p>If <code>NtQuerySystemInformation</code> returns a status code of 0, our query was successful, and we can break the loop and process the data. If the status code is <code>0xC0000004</code>, there&rsquo;s a length mismatch, e.g. our buffer size wasn&rsquo;t large enough to hold all the data.</p><p>In this case, we don&rsquo;t bail out of the loop immediately but instead adjust the buffer size with <code>dwSize = dwRet + (2 &lt;&lt; 12)</code>, increasing dwSize to accommodate the full result.</p><p>If we encounter any other error code, however, we print an error message, free the memory, and exit the loop.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=p>!=</span> <span class=n>IntPtr</span><span class=p>.</span><span class=n>Zero</span><span class=p>)</span> <span class=n>Marshal</span><span class=p>.</span><span class=n>FreeHGlobal</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=p>=</span> <span class=n>Marshal</span><span class=p>.</span><span class=n>AllocHGlobal</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span><span class=n>dwSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>dwStatus</span> <span class=p>=</span> <span class=n>NtQuerySystemInformation</span><span class=p>(</span><span class=m>5</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>dwSize</span><span class=p>,</span> <span class=k>out</span> <span class=n>dwRet</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>dwStatus</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span> <span class=k>break</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>dwStatus</span> <span class=p>!=</span> <span class=m>0xC0000004</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Marshal</span><span class=p>.</span><span class=n>FreeHGlobal</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=p>=</span> <span class=n>IntPtr</span><span class=p>.</span><span class=n>Zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Data retrieval failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dwSize</span> <span class=p>=</span> <span class=n>dwRet</span> <span class=p>+</span> <span class=p>(</span><span class=m>2</span> <span class=p>&lt;&lt;</span> <span class=m>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Finally, we can loop through the entries and print the attributes from the <code>SYSTEM_PROCESS_INFORMATION</code> structure.</p><p>We use <code>Marshal.PtrToStructure</code> to reference the unmanaged memory we&rsquo;ve marshaled into the <code>currentPtr</code>. This allows us to map raw memory to the specific C# SYSTEM_PROCESS_INFORMATION typedef we defined earlier. C sharp&rsquo;s use of static typing ensures the data is retrieved safely and with the correct types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>processInfo</span> <span class=p>=</span> <span class=p>(</span><span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>)</span><span class=n>Marshal</span><span class=p>.</span><span class=n>PtrToStructure</span><span class=p>(</span><span class=n>currentPtr</span><span class=p>,</span> <span class=k>typeof</span><span class=p>(</span><span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>));</span>
</span></span></code></pre></div><p>And then we write out output with <code>Console.WriteLine</code>, checking the values of the attributes we&rsquo;re referencing. If the <code>ImageName.Buffer</code> is non-zero, we likely have a valid <code>ImageName</code>. So we call <code>Marshal.PtrToStringUni(processInfo.ImageName.Buffer)</code> on it to get the Unicode <strong>ImageName</strong>. And to extract the <strong>UniqueProcessId</strong>, we convert the value to a <code>Int64</code>, a signed integer.</p><p>After each record, we move to the next entry using the <code>NextEntryOffset</code> value. We convert this to a 32-bit integer, though. Per Microsoft&rsquo;s documentation:</p><blockquote><p><code>NextEntryOffset</code> (4 bytes): A 32-bit unsigned integer that MUST specify the offset, in bytes, from the current <code>FILE_LINK_ENTRY_INFORMATION</code> structure to the next <code>FILE_LINK_ENTRY_INFORMATION</code> structure. A value of 0 indicates this is the last entry structure.</p></blockquote><p>Altogether, our last bit of code will look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>IntPtr</span> <span class=n>currentPtr</span> <span class=p>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>processInfo</span> <span class=p>=</span> <span class=p>(</span><span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>)</span><span class=n>Marshal</span><span class=p>.</span><span class=n>PtrToStructure</span><span class=p>(</span><span class=n>currentPtr</span><span class=p>,</span> <span class=k>typeof</span><span class=p>(</span><span class=n>SYSTEM_PROCESS_INFORMATION</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;[*] Image name: {(processInfo.ImageName.Buffer != IntPtr.Zero ? Marshal.PtrToStringUni(processInfo.ImageName.Buffer) : &#34;&#34;)}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;    &gt; PID: {processInfo.UniqueProcessId.ToInt64()}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate the offset to the next process entry</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>offset</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>processInfo</span><span class=p>.</span><span class=n>NextEntryOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move to the next process entry</span>
</span></span><span class=line><span class=cl>    <span class=n>currentPtr</span> <span class=p>=</span> <span class=n>IntPtr</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>currentPtr</span><span class=p>,</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Marshal</span><span class=p>.</span><span class=n>FreeHGlobal</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>On Github I&rsquo;ve uploaded the C# code for this demonstration to a <a href=https://github.com/hexagr/Cardinal>small repository dubbed &ldquo;Cardinal.&rdquo;</a></p><p>After compiling, we can do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=p>&gt;.\</span><span class=n>Cardinal</span><span class=p>\</span><span class=n>bin</span><span class=p>\</span><span class=n>Debug</span><span class=p>\</span><span class=n>Cardinal</span><span class=p>.</span><span class=py>exe</span>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span> <span class=n>System</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span> <span class=n>Registry</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>116</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span> <span class=n>smss</span><span class=p>.</span><span class=py>exe</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>444</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span> <span class=n>csrss</span><span class=p>.</span><span class=py>exe</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>636</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[*]</span> <span class=n>Image</span> <span class=n>name</span><span class=err>:</span> <span class=n>wininit</span><span class=p>.</span><span class=py>exe</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=n>PID</span><span class=err>:</span> <span class=mf>708</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://hexagram.foo/tags/windows/>Windows</a></li><li><a href=https://hexagram.foo/tags/csharp/>Csharp</a></li><li><a href=https://hexagram.foo/tags/process-enumeration/>Process Enumeration</a></li></ul><nav class=paginav><a class=prev href=https://hexagram.foo/posts/a-sideblog-on-blogspot/><span class=title>« Prev</span><br><span>A Sideblog on Blogspot</span>
</a><a class=next href=https://hexagram.foo/posts/finding-active-processes-with-windbg/><span class=title>Next »</span><br><span>Finding Active Processes with Windbg</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on x" href="https://x.com/intent/tweet/?text=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f&amp;hashtags=windows%2ccsharp%2cprocessenumeration"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f&amp;title=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes&amp;summary=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes&amp;source=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f&title=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on whatsapp" href="https://api.whatsapp.com/send?text=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes%20-%20https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on telegram" href="https://telegram.me/share/url?text=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes&amp;url=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using C Sharp to Enumerate Windows Processes on ycombinator" href="https://news.ycombinator.com/submitlink?t=Using%20C%20Sharp%20to%20Enumerate%20Windows%20Processes&u=https%3a%2f%2fhexagram.foo%2fposts%2fusing-c-sharp-to-enumerate-windows-processes%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hexagram.foo/>Stephan Bridger</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a><br><br><hr><br><a href=https://github.com/hexagr/ title="Stephan Bridger on Github">github</a> /
<a href=https://hackerone.com/hexagr/badges/ title="Stephan Bridger on HackerOne">hackerone</a> /
<a href=https://x.com/hexagr title="Stephan Bridger on X.com">x</a> /
<a href=https://flickr.com/hexagr title="Stephan Bridger on flickr">flickr</a> /
<a href=https://mastodon.social/@hexagr rel=me title="Stephan Bridger on mastodon">mastodon</a> /
<a href=https://bsky.app/profile/hexagr.bsky.social title="Stephan Bridger on bluesky">bluesky</a> /
<a href=https://hexagr.blogspot.com title="Stephan Bridger on blogspot">blogspot</a> /
<a href=https://vimeo.com/hexagr title="Stephan Bridger on vimeo">vimeo</a> /
<a href=https://bugcrowd.com/hexagr title="Stephan Bridger on bugcrowd">bugcrowd</a> /
<a href=https://gitlab.com/hexagr title="Stephan Bridger on gitlab">gitlab</a> /
<a href=https://youtube.com/@hexagr/ title="Stephan Bridger on youtube">youtube</a> /
<a href=https://hexagr.tumblr.com title="Stephan Bridger on tumblr">tumblr</a>
</span><span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><style>::-webkit-scrollbar-thumb{opacity:0;transition:opacity .3s ease}body.scrolling ::-webkit-scrollbar-thumb{opacity:1}</style><script>let scrollTimeout;window.addEventListener("scroll",()=>{document.body.classList.add("scrolling"),clearTimeout(scrollTimeout),scrollTimeout=setTimeout(()=>{document.body.classList.remove("scrolling")},1e3)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>